From 6afa02119556a82c1b2765782df30b456a64adcb Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Sun, 27 Mar 2016 14:01:25 +0800
Subject: [PATCH] mtk: add supporting packages for MTK IMS service

Change-Id: I0dbeaf175085392d35963a7ad135b63837d6db76
---
 Android.mk                                         |   3 +
 packages/Android.mk                                |   1 +
 packages/WifiOffload/Android.mk                    |  58 ++
 packages/WifiOffload/AndroidManifest.xml           |  16 +
 packages/WifiOffload/README                        |  22 +
 .../jni/com_mediatek_wfo_WifiOffloadService.c      | 283 +++++++
 .../lib/src/com/mediatek/wfo/DisconnectCause.aidl  |   6 +
 .../lib/src/com/mediatek/wfo/DisconnectCause.java  |  50 ++
 .../src/com/mediatek/wfo/IWifiOffloadListener.aidl |   9 +
 .../src/com/mediatek/wfo/IWifiOffloadService.aidl  |  15 +
 .../src/com/mediatek/wfo/WifiOffloadManager.java   |  43 +
 packages/WifiOffload/proguard.flags                |   0
 .../src/com/mediatek/wfo/impl/WfoApp.java          |  63 ++
 .../com/mediatek/wfo/impl/WifiOffloadService.java  | 719 ++++++++++++++++
 packages/simservs/Android.mk                       |  18 +
 packages/simservs/README                           |  23 +
 .../simservs/capability/ActionCapabilities.java    | 134 +++
 .../capability/BarringServiceCapability.java       |  56 ++
 .../simservs/capability/CapabilitiesType.java      | 125 +++
 .../simservs/capability/ConditionCapabilities.java | 227 ++++++
 .../capability/DiversionServiceCapability.java     |  76 ++
 .../simservs/capability/MediaConditions.java       |  70 ++
 .../simservs/capability/ServiceCapabilities.java   |  29 +
 .../simservs/client/CommunicationDiversion.java    | 346 ++++++++
 .../simservs/client/CommunicationWaiting.java      |  42 +
 .../mediatek/simservs/client/DefaultBehaviour.java |  93 +++
 .../client/IncomingCommunicationBarring.java       | 177 ++++
 .../client/OriginatingIdentityPresentation.java    |  42 +
 ...OriginatingIdentityPresentationRestriction.java | 154 ++++
 .../client/OutgoingCommunicationBarring.java       | 178 ++++
 .../src/com/mediatek/simservs/client/SimServs.java | 904 +++++++++++++++++++++
 .../com/mediatek/simservs/client/SimservType.java  | 212 +++++
 .../client/TerminatingIdentityPresentation.java    |  41 +
 ...TerminatingIdentityPresentationRestriction.java | 129 +++
 .../mediatek/simservs/client/policy/Actions.java   | 155 ++++
 .../simservs/client/policy/Conditions.java         | 733 +++++++++++++++++
 .../mediatek/simservs/client/policy/ForwardTo.java | 401 +++++++++
 .../com/mediatek/simservs/client/policy/Rule.java  | 221 +++++
 .../mediatek/simservs/client/policy/RuleSet.java   | 392 +++++++++
 .../mediatek/simservs/client/policy/Sphere.java    |  29 +
 .../simservs/client/policy/Transformations.java    |  29 +
 .../com/mediatek/simservs/client/policy/Until.java |  29 +
 .../mediatek/simservs/client/policy/Validity.java  |  29 +
 .../com/mediatek/simservs/xcap/Attributable.java   |  33 +
 .../com/mediatek/simservs/xcap/ConfigureType.java  |  17 +
 .../com/mediatek/simservs/xcap/InquireType.java    | 144 ++++
 .../src/com/mediatek/simservs/xcap/RuleType.java   |  40 +
 .../com/mediatek/simservs/xcap/XcapElement.java    | 575 +++++++++++++
 .../com/mediatek/simservs/xcap/XcapException.java  |  79 ++
 packages/simservs/test/SimservsTest.java           | 565 +++++++++++++
 packages/xcap/Android.mk                           |  16 +
 packages/xcap/NOTICE                               |  15 +
 packages/xcap/README                               |  19 +
 .../xcap/src/com/mediatek/xcap/XcapClient.java     | 492 +++++++++++
 .../xcap/src/com/mediatek/xcap/XcapConstants.java  |  82 ++
 .../xcap/src/com/mediatek/xcap/XcapDebugParam.java | 371 +++++++++
 .../xcap/src/com/mediatek/xcap/uri/XcapUri.java    | 418 ++++++++++
 packages/xcap/test/XcapTester.java                 | 290 +++++++
 58 files changed, 9538 insertions(+)
 create mode 100644 packages/Android.mk
 create mode 100644 packages/WifiOffload/Android.mk
 create mode 100644 packages/WifiOffload/AndroidManifest.xml
 create mode 100644 packages/WifiOffload/README
 create mode 100644 packages/WifiOffload/jni/com_mediatek_wfo_WifiOffloadService.c
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.aidl
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.java
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadService.aidl
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/WifiOffloadManager.java
 create mode 100644 packages/WifiOffload/proguard.flags
 create mode 100644 packages/WifiOffload/src/com/mediatek/wfo/impl/WfoApp.java
 create mode 100644 packages/WifiOffload/src/com/mediatek/wfo/impl/WifiOffloadService.java
 create mode 100644 packages/simservs/Android.mk
 create mode 100644 packages/simservs/README
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/ActionCapabilities.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/BarringServiceCapability.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/CapabilitiesType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/ConditionCapabilities.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/DiversionServiceCapability.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/MediaConditions.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/ServiceCapabilities.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/CommunicationDiversion.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/CommunicationWaiting.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/DefaultBehaviour.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/IncomingCommunicationBarring.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentation.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentationRestriction.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/OutgoingCommunicationBarring.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/SimServs.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/SimservType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentation.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentationRestriction.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Actions.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Conditions.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/ForwardTo.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Rule.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/RuleSet.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Sphere.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Transformations.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Until.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Validity.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/Attributable.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/ConfigureType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/InquireType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/RuleType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/XcapElement.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/XcapException.java
 create mode 100644 packages/simservs/test/SimservsTest.java
 create mode 100644 packages/xcap/Android.mk
 create mode 100644 packages/xcap/NOTICE
 create mode 100644 packages/xcap/README
 create mode 100644 packages/xcap/src/com/mediatek/xcap/XcapClient.java
 create mode 100644 packages/xcap/src/com/mediatek/xcap/XcapConstants.java
 create mode 100644 packages/xcap/src/com/mediatek/xcap/XcapDebugParam.java
 create mode 100644 packages/xcap/src/com/mediatek/xcap/uri/XcapUri.java
 create mode 100644 packages/xcap/test/XcapTester.java

diff --git a/Android.mk b/Android.mk
index ee92ea6eab5..10d68946a8e 100644
--- a/Android.mk
+++ b/Android.mk
@@ -26,3 +26,6 @@ LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE := ims-common
 
 include $(BUILD_JAVA_LIBRARY)
+
+# build MTK ImsService
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/packages/Android.mk b/packages/Android.mk
new file mode 100644
index 00000000000..5053e7d6438
--- /dev/null
+++ b/packages/Android.mk
@@ -0,0 +1 @@
+include $(call all-subdir-makefiles)
diff --git a/packages/WifiOffload/Android.mk b/packages/WifiOffload/Android.mk
new file mode 100644
index 00000000000..b5972b8c9e9
--- /dev/null
+++ b/packages/WifiOffload/Android.mk
@@ -0,0 +1,58 @@
+LOCAL_PATH:= $(call my-dir)
+
+# interface lib
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(call all-java-files-under, lib/src)
+
+LOCAL_AIDL_INCLUDES := $(LOCAL_PATH)/lib/src
+
+# aidl
+LOCAL_SRC_FILES += \
+    lib/src/com/mediatek/wfo/IWifiOffloadService.aidl \
+    lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl
+
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := wfo-common
+
+include $(BUILD_STATIC_JAVA_LIBRARY)
+
+# JNI
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+    jni/com_mediatek_wfo_WifiOffloadService.c
+
+LOCAL_MULTILIB := both
+LOCAL_ARM_MODE := arm
+
+LOCAL_SHARED_LIBRARIES := \
+    libnativehelper \
+    libcutils \
+    liblog \
+    libutils \
+    libmal \
+    libmdfx
+
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := libwfo_jni
+
+include $(BUILD_SHARED_LIBRARY)
+
+# apk
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_JAVA_LIBRARIES += telephony-common ims-common
+LOCAL_STATIC_JAVA_LIBRARIES += wfo-common
+
+LOCAL_MODULE_TAGS := optional
+LOCAL_PACKAGE_NAME := WfoService
+LOCAL_CERTIFICATE := platform
+LOCAL_PRIVILEGED_MODULE := true
+
+LOCAL_PROGUARD_ENABLED := disabled
+LOCAL_PROGUARD_FLAGS := $(proguard.flags)
+
+include $(BUILD_PACKAGE)
diff --git a/packages/WifiOffload/AndroidManifest.xml b/packages/WifiOffload/AndroidManifest.xml
new file mode 100644
index 00000000000..13386e4259c
--- /dev/null
+++ b/packages/WifiOffload/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:androidprv="http://schemas.android.com/apk/prv/res/android"
+        package="com.mediatek.wfo.impl"
+        coreApp="true"
+        android:sharedUserId="android.uid.phone">
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+
+    <application android:name="WfoApp"
+                 android:persistent="true">
+<!--        <uses-library android:name="wfo-common"
+                      android:required="true" /> -->
+    </application>
+</manifest>
diff --git a/packages/WifiOffload/README b/packages/WifiOffload/README
new file mode 100644
index 00000000000..35991531b35
--- /dev/null
+++ b/packages/WifiOffload/README
@@ -0,0 +1,22 @@
+The WfoService apk is a service for communication between Java layer and MAL module to achieve
+Wifi-Offload functionality.
+
+WHAT IT DOES?
+=============
+The main tasks of WfoService are
+ - Passes user profiles such as VoLTE enabled, WifiCalling enabled and WifiCalling mode informations
+   to MAL module.
+ - Passes Wifi states such as MAC address, IP address and interface name to MAL module.
+ - Provides API to get ran type from MAL.
+ - Provides listener registration to receive handover events.
+
+HOW IT WAS BUILT?
+==================
+WfoService apk is built from MTK internal build process if ePDG feature is enable.
+
+HOW TO USE IT?
+==============
+It's a persist apk. It will be launched by AMS and add WifiOffloadService when application is
+created. Client can get WifiOffloadService by
+ServiceManager.getService(WifiOffloadManager.WFO_SERVICE),and use it by interfaces defined in
+wfo-common library.
diff --git a/packages/WifiOffload/jni/com_mediatek_wfo_WifiOffloadService.c b/packages/WifiOffload/jni/com_mediatek_wfo_WifiOffloadService.c
new file mode 100644
index 00000000000..b858dfba5d5
--- /dev/null
+++ b/packages/WifiOffload/jni/com_mediatek_wfo_WifiOffloadService.c
@@ -0,0 +1,283 @@
+#include <jni.h>
+#include <JNIHelp.h>
+#include <utils/Log.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <mal.h>
+#include <entity/rds/rds_if.h>
+
+#define LOG_TAG "WifiOffloadService"
+#define LOG_NDEBUG 0
+
+JavaVM* g_vm = 0;
+jobject g_obj = 0;
+
+void *g_conn_ptr = NULL;
+
+/**
+ * Define the values of handover stages.
+ */
+int HANDOVER_START = 0;
+int HANDOVER_END = 1;
+int HANDOVER_FAILED = -1;
+
+int handover_callback(rds_ho_status_t *status)
+{
+    JNIEnv *env = 0;
+    if (g_vm == NULL)
+    {
+        ALOGE("[handover_callback] NULL JVM");
+        return 0;
+    }
+    if ((*g_vm)->AttachCurrentThread(g_vm, &env, NULL) != JNI_OK)
+    {
+        ALOGE("[handover_callback] AttachCurrentThread failure");
+        return 0;
+    }
+    jclass clazz = (*env)->GetObjectClass(env, g_obj);
+    if (clazz == NULL)
+    {
+        ALOGD("handover_callback() clazz is NULL");
+        return 0;
+    }
+    jmethodID mid = (*env)->GetMethodID(env, clazz, "onHandover", "(II)V");
+    if (mid != NULL)
+    {
+        int stage = -1;
+        if (status->fgho_result == 0) {
+            // HANDOVER_FAILED
+            (*env)->CallVoidMethod(env, g_obj, mid, HANDOVER_FAILED, status->etarget_ran_type);
+        } else {
+            // HANDOVER_START(0) or HANDOVER_END(1)
+            (*env)->CallVoidMethod(env, g_obj, mid, status->ucho_status, status->etarget_ran_type);
+        }
+    }
+    (*g_vm)->DetachCurrentThread(g_vm);
+    return 0;
+}
+
+int roveout_callback(rds_rvout_alert_t *pralert)
+{
+    JNIEnv *env = 0;
+    if (g_vm == NULL)
+    {
+        ALOGE("[roveout_callback] NULL JVM");
+        return 0;
+    }
+    if ((*g_vm)->AttachCurrentThread(g_vm, &env, NULL) != JNI_OK)
+    {
+        ALOGE("[roveout_callback] AttachCurrentThread failure");
+        return 0;
+    }
+    jclass clazz = (*env)->GetObjectClass(env, g_obj);
+    if (clazz == NULL)
+    {
+        ALOGD("roveout_callback() clazz is NULL");
+        return 0;
+    }
+    jmethodID mid = (*env)->GetMethodID(env, clazz, "onRoveOut", "(ZI)V");
+    if (mid != NULL)
+    {
+        (*env)->CallVoidMethod(env, g_obj, mid, pralert->rvalert_en, pralert->i4wifirssi);
+    }
+    (*g_vm)->DetachCurrentThread(g_vm);
+    return 0;
+}
+
+int pdnStateChanged_callback(rds_wifi_pdnact_t *pralert)
+{
+    JNIEnv *env = 0;
+    if (g_vm == NULL)
+    {
+        ALOGE("[roveout_callback] NULL JVM");
+        return 0;
+    }
+    if ((*g_vm)->AttachCurrentThread(g_vm, &env, NULL) != JNI_OK)
+    {
+        ALOGE("[roveout_callback] AttachCurrentThread failure");
+        return 0;
+    }
+    jclass clazz = (*env)->GetObjectClass(env, g_obj);
+    if (clazz == NULL)
+    {
+        ALOGD("roveout_callback() clazz is NULL");
+        return 0;
+    }
+    jmethodID mid = (*env)->GetMethodID(env, clazz, "onPdnStateChanged", "(Z)V");
+    if (mid != NULL)
+    {
+        (*env)->CallVoidMethod(env, g_obj, mid, pralert->pdn_rdy);
+    }
+    (*g_vm)->DetachCurrentThread(g_vm);
+    return 0;
+}
+
+void init(JNIEnv *env, jobject obj)
+{
+    (*env)->GetJavaVM(env, &g_vm);
+    g_obj = (*env)->NewGlobalRef(env, obj);
+    // rds_get_verno();
+    rds_notify_funp_t rds_fp = {0};
+    rds_fp.pfrds_ho_status_ind = handover_callback;
+    rds_fp.pfrds_rvout_alert_ind = roveout_callback;
+    rds_fp.pfrds_wifi_pdnact_ind = pdnStateChanged_callback;
+    g_conn_ptr = epdgs_rds_conn_init(&rds_fp);
+}
+
+jint get_rat_type(JNIEnv *env, jobject obj)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("get_rat_type conn_ptr is NULL");
+        return RDS_RAN_UNSPEC;
+    }
+    rds_rb_get_demand_req_t req;
+    // TODO: set req.u4pdn_id
+    rds_rb_get_ran_type_rsp_t rsp = {.i4rds_ret = RDS_FALSE, .u4ran_type = RDS_RAN_UNSPEC};
+    rds_get_ran_type(&req, &rsp, g_conn_ptr);
+    return rsp.u4ran_type;
+}
+
+jobject get_disconnect_cause(JNIEnv *env, jobject obj)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("get_disconnect_cause conn_ptr is NULL");
+        return NULL;
+    }
+    rds_rb_get_demand_req_t req;
+    // TODO: set req.u4pdn_id
+    rds_rb_get_last_err_rsp_t rsp = {.i4rds_ret = RDS_FALSE, .i4lasterr = 0, .i4lastsuberr = 0};
+    rds_get_last_err(&req, &rsp, g_conn_ptr);
+    // new DisconnectCause object
+    jclass clazz = (*env)->FindClass(env, "com/mediatek/wfo/DisconnectCause");
+    if (clazz == NULL)
+    {
+        ALOGE("get_disconnect_cause FindClass return NULL");
+        return NULL;
+    }
+    jmethodID ctor = (*env)->GetMethodID(env, clazz, "<init>", "(II)V");
+    if (ctor == NULL)
+    {
+        ALOGE("get_disconnect_cause GetMethodID return NULL");
+        return NULL;
+    }
+    return (*env)->NewObject(env, clazz, ctor, rsp.i4lasterr, rsp.i4lastsuberr);
+}
+
+void set_wos_profile(JNIEnv *env, jobject obj, jboolean volte_enabled, jboolean wfc_enabled, jstring fqdn,
+        jboolean wifi_enabled, jint wifi_mode, jint dataRoaming_enabled)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("get_rat_type conn_ptr is NULL");
+        return;
+    }
+    rds_ru_set_uiparam_req_t req = {
+        .fgimsolte_en = volte_enabled,
+        .fgwfc_en = wfc_enabled,
+        .omacp_fqdn = {0},
+        .fgwifiui_en = wifi_enabled,
+        .rdspolicy = wifi_mode,
+        .fgdata_roaming_ui_en = dataRoaming_enabled
+    };
+    const char *pcFqdn = (*env)->GetStringUTFChars(env, fqdn, 0);
+    strncpy(req.omacp_fqdn, pcFqdn, RDS_FQDN_LEN - 1);
+    ALOGD("set_wos_profile wfc_enabled is %d, req.omacp_fqdn is %s\n", req.fgwfc_en, req.omacp_fqdn);
+    rds_set_ui_param(&req, g_conn_ptr);
+    (*env)->ReleaseStringUTFChars(env, fqdn, pcFqdn);
+}
+
+void set_wifi_state(JNIEnv *env, jobject obj, jboolean wifi_connected, jstring if_name, jstring ipv4, jstring ipv6, jstring mac)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("set_wifi_state conn_ptr is NULL");
+        return;
+    }
+    rds_ru_set_wifistat_req_t req = {
+        .fgwifi_en = wifi_connected,
+        .szwifi_ifname = {0},
+        .szwifi_ipv4addr = {0},
+        .szwifi_ipv6addr = {0},
+        .szwifi_macaddr = {0}
+    };
+
+    const char *pcIfName = (*env)->GetStringUTFChars(env, if_name, 0);
+    const char *pcIpv4 = (*env)->GetStringUTFChars(env, ipv4, 0);
+    const char *pcIpv6 = (*env)->GetStringUTFChars(env, ipv6, 0);
+    const char *pcMac = (*env)->GetStringUTFChars(env, mac, 0);
+    strncpy(req.szwifi_ifname, pcIfName, RDS_STR_LEN - 1);
+    strncpy(req.szwifi_ipv4addr, pcIpv4, 2 * RDS_STR_LEN - 1);
+    strncpy(req.szwifi_ipv6addr, pcIpv6, 2 * RDS_STR_LEN - 1);
+    strncpy(req.szwifi_macaddr, pcMac, 2 * RDS_STR_LEN - 1);
+    ALOGD("set_wifi_state req.szwifi_ifname is %s\n", req.szwifi_ifname);
+    ALOGD("set_wifi_state req.szwifi_ipv4addr is %s\n", req.szwifi_ipv4addr);
+    ALOGD("set_wifi_state req.szwifi_ipv6addr is %s\n", req.szwifi_ipv6addr);
+    ALOGD("set_wifi_state req.szwifi_macaddr is %s\n", req.szwifi_macaddr);
+    rds_set_wifistat(&req, g_conn_ptr);
+    (*env)->ReleaseStringUTFChars(env, if_name, pcIfName);
+    (*env)->ReleaseStringUTFChars(env, ipv4, pcIpv4);
+    (*env)->ReleaseStringUTFChars(env, ipv6, pcIpv6);
+    (*env)->ReleaseStringUTFChars(env, mac, pcMac);
+}
+
+void set_call_state(JNIEnv *env, jobject obj, jboolean in_call, jint call_type)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("set_call_state conn_ptr is NULL");
+        return;
+    }
+    ALOGD("set_call_state: In call is %d, call type is %d\n", in_call, call_type);
+    rds_ru_set_callstat_req_t req = {
+        .in_call = in_call,
+        .call_type = call_type
+    };
+    rds_set_callstat(&req, g_conn_ptr);
+}
+
+void setServiceState(JNIEnv *env, jobject obj,
+        jint mdIdx, jint simIdx, jboolean isDataRoaming, jint ratType, jint serviceState) {
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("set_call_state conn_ptr is NULL");
+        return;
+    }
+    ALOGD("set_service_state: isDataRoaming is %d, ratType is %d, serviceState is %d\n",
+            isDataRoaming, ratType, serviceState);
+
+    rds_ru_set_mdstat_req_t req = {
+        .md_idx = mdIdx,
+        .sim_idx = simIdx,
+        .fgisroaming = isDataRoaming,
+        .md_rat = ratType,
+        .srv_state = serviceState
+    };
+    rds_set_mdstat(&req, g_conn_ptr);
+}
+
+static JNINativeMethod method_table[] = {
+    { "nativeInit", "()V", (void *)init },
+    { "nativeGetRatType", "()I", (void *)get_rat_type },
+    { "nativeGetDisconnectCause", "()Lcom/mediatek/wfo/DisconnectCause;", (void *)get_disconnect_cause },
+    { "nativeSetWosProfile", "(ZZLjava/lang/String;ZII)V", (void *)set_wos_profile },
+    { "nativeSetWifiStatus", "(ZLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", (void *)set_wifi_state },
+    { "nativeSetCallState", "(ZI)V", (void *)set_call_state },
+    { "nativeSetServiceState", "(IIZII)V", (void *)setServiceState }
+};
+
+jint JNI_OnLoad(JavaVM* vm, void* reserved)
+{
+    JNIEnv* env;
+    if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_4) != JNI_OK) {
+        return JNI_FALSE;
+    }
+
+    jniRegisterNativeMethods(env, "com/mediatek/wfo/impl/WifiOffloadService",
+            method_table, NELEM(method_table));
+
+    return JNI_VERSION_1_4;
+}
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.aidl b/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.aidl
new file mode 100644
index 00000000000..a1e3c4fe088
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.aidl
@@ -0,0 +1,6 @@
+/**
+ * {@hide}
+ */
+package com.mediatek.wfo;
+
+parcelable DisconnectCause;
\ No newline at end of file
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.java b/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.java
new file mode 100644
index 00000000000..980e8bd2897
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.java
@@ -0,0 +1,50 @@
+package com.mediatek.wfo;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class DisconnectCause implements Parcelable {
+    private int errorCause;
+    private int subErrorCause;
+
+    public DisconnectCause(int error, int subError) {
+        errorCause = error;
+        subErrorCause = subError;
+    }
+
+    public int getErrorCause() {
+        return errorCause;
+    }
+
+    public int getSubErrorCause() {
+        return subErrorCause;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(errorCause);
+        dest.writeInt(subErrorCause);
+    }
+
+    public static final Creator<DisconnectCause> CREATOR = new Creator<DisconnectCause>() {
+        public DisconnectCause createFromParcel(Parcel source) {
+            int error = source.readInt();
+            int subError = source.readInt();
+            return new DisconnectCause(error, subError);
+        }
+
+        public DisconnectCause[] newArray(int size) {
+            return new DisconnectCause[size];
+        }
+    };
+
+    public String toString() {
+        return "DisconnectCause {errorCause=" + errorCause + ", subErrorCause=" + subErrorCause
+                + "}";
+    }
+}
\ No newline at end of file
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl b/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl
new file mode 100644
index 00000000000..1fc0e3138ce
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl
@@ -0,0 +1,9 @@
+/**
+ * {@hide}
+ */
+package com.mediatek.wfo;
+
+interface IWifiOffloadListener {
+    void onHandover(in int stage, in int ratType);
+    void onRoveOut(in boolean roveOut, in int rssi);
+}
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadService.aidl b/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadService.aidl
new file mode 100644
index 00000000000..fd55bbd7d95
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadService.aidl
@@ -0,0 +1,15 @@
+/**
+ * {@hide}
+ */
+package com.mediatek.wfo;
+
+import com.mediatek.wfo.IWifiOffloadListener;
+import com.mediatek.wfo.DisconnectCause;
+
+interface IWifiOffloadService {
+    void registerForHandoverEvent(in IWifiOffloadListener listener);
+    void unregisterForHandoverEvent(in IWifiOffloadListener listener);
+    int getRatType();
+    DisconnectCause getDisconnectCause();
+    void setEpdgFqdn(in String fqdn, in boolean wfcEnabled);
+}
\ No newline at end of file
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/WifiOffloadManager.java b/packages/WifiOffload/lib/src/com/mediatek/wfo/WifiOffloadManager.java
new file mode 100644
index 00000000000..34082e93d57
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/WifiOffloadManager.java
@@ -0,0 +1,43 @@
+package com.mediatek.wfo;
+
+public class WifiOffloadManager {
+    /**
+     * For accessing the WifiOffload related service.
+     * Internal use only.
+     */
+    public static final String WFO_SERVICE = "wfo";
+
+    public static final String ACTION_NOTIFY_CONNECTION_ERROR =
+            "android.intent.action.NOTIFY_CONNECTION_ERROR";
+
+    public static final String EXTRA_ERROR_CODE = "error_code";
+
+    /**
+     * Alert need to send when user moves out of Wifi area
+     * and no LTE is available to camp on
+     */
+    public static final String ACTION_ROVE_OUT_ALERT = "android.intent.action.ROVE_OUT_ALERT";
+
+    public static final int RAN_TYPE_UNSPEC = 0;
+    public static final int RAN_TYPE_MOBILE_3GPP = 1;
+    public static final int RAN_TYPE_WIFI = 2;
+    public static final int RAN_TYPE_MOBILE_3GPP2 = 3;
+    // deny by PS
+    public static final int RAN_TYPE_NONE = -2;
+    // deny by RDS
+    public static final int RAN_TYPE_DENY = -1;
+
+    public static final int HANDOVER_START = 0;
+    public static final int HANDOVER_END = 1;
+    public static final int HANDOVER_FAILED = -1;
+
+    /**
+     * Listener interface for WifiOffload events.
+     */
+    public abstract static class Listener extends IWifiOffloadListener.Stub {
+        @Override
+        public void onHandover(int stage, int ratType) {};
+        @Override
+        public void onRoveOut(boolean roveOut, int rssi) {};
+    }
+}
diff --git a/packages/WifiOffload/proguard.flags b/packages/WifiOffload/proguard.flags
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/packages/WifiOffload/src/com/mediatek/wfo/impl/WfoApp.java b/packages/WifiOffload/src/com/mediatek/wfo/impl/WfoApp.java
new file mode 100644
index 00000000000..8500bf4748c
--- /dev/null
+++ b/packages/WifiOffload/src/com/mediatek/wfo/impl/WfoApp.java
@@ -0,0 +1,63 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2015. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.wfo.impl;
+
+import android.app.Application;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.mediatek.wfo.WifiOffloadManager;
+import com.mediatek.wfo.impl.WifiOffloadService;
+
+/**
+ * Top-level Application class for the WifiOffload app.
+ */
+public class WfoApp extends Application {
+    private static final String TAG = "WfoApp";
+
+    public WfoApp() {
+    }
+
+    @Override
+    public void onCreate() {
+        if (UserHandle.myUserId() == 0) {
+            Log.d(TAG, "WfoApp new WifiOffloadService");
+            WifiOffloadService service = new WifiOffloadService(this);
+            ServiceManager.addService(WifiOffloadManager.WFO_SERVICE, service.asBinder(), true);
+        }
+    }
+}
\ No newline at end of file
diff --git a/packages/WifiOffload/src/com/mediatek/wfo/impl/WifiOffloadService.java b/packages/WifiOffload/src/com/mediatek/wfo/impl/WifiOffloadService.java
new file mode 100644
index 00000000000..1873ec17c37
--- /dev/null
+++ b/packages/WifiOffload/src/com/mediatek/wfo/impl/WifiOffloadService.java
@@ -0,0 +1,719 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2015. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.wfo.impl;
+
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.INetworkManagementEventObserver;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkInfo;
+import android.net.NetworkRequest;
+import android.net.Uri;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.provider.Settings;
+
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
+import com.android.server.net.BaseNetworkObserver;
+
+import com.mediatek.wfo.DisconnectCause;
+import com.mediatek.wfo.IWifiOffloadService;
+import com.mediatek.wfo.IWifiOffloadListener;
+import com.mediatek.wfo.WifiOffloadManager;
+
+public class WifiOffloadService extends IWifiOffloadService.Stub {
+    static {
+        System.loadLibrary("wfo_jni");
+    }
+
+    private native void nativeInit();
+    private native int nativeGetRatType();
+    private native DisconnectCause nativeGetDisconnectCause();
+    private native void nativeSetWosProfile(boolean volteEnabled, boolean wfcEnabled,
+            String fqdn, boolean wifiEnabled, int wfcMode, int dataRoaming_enabled);
+    private native void nativeSetWifiStatus(boolean wifiConnected, String ifNmae, String ipv4, String ipv6, String mac);
+    private native void nativeSetCallState(boolean inCall, int callType);
+    private native void nativeSetServiceState(
+            int mdIdx, int simIdx, boolean isDataRoaming, int ratType, int serviceState);
+
+    static final String TAG = "WifiOffloadService";
+
+    private Set<IWifiOffloadListener> mListeners = new CopyOnWriteArraySet<IWifiOffloadListener>();
+
+    private Context mContext;
+    private WifiManager mWifiManager;
+    private ConnectivityManager mConnectivityManager;
+    private INetworkManagementService mNetworkManager;
+    private SubscriptionManager mSubscriptionManager;
+    private TelephonyManager mTelephonyManager;
+
+    // from user settings
+    private boolean mIsVolteEnabled;
+    private boolean mIsWfcEnabled;
+    private int mWfcMode;
+    private boolean mIsWifiEnabled;
+
+    // for VoWiFi Provisioning utilising SMS
+    private String mFqdn = "";
+
+    // wifi state
+    private boolean mIsWifiConnected = false;
+    private String mWifiApMac = "";
+    private String mWifiIpv4Address = "";
+    private String mWifiIpv6Address = "";
+    private String mIfName ="";
+
+    // call type
+    private static final int IMSCALL_NONE = 0;
+    private static final int IMSCALL_IR92_VOICE_CALL = 1;
+    private static final int IMSCALL_IR94_VIDEO_CALL = 2;
+
+    // data roaming, service states.
+    private int mSimCount;
+    private int mDataRoamingEnabled = SubscriptionManager.DATA_ROAMING_DISABLE;
+    private boolean[] mIsCurDataRoaming;
+    private int[] mRadioTechnology;
+
+    // subId -> PhoneStateListener
+    private Map<Integer, PhoneStateListener> mPhoneServicesStateListeners
+            = new ConcurrentHashMap<Integer, PhoneStateListener>();
+
+     /**
+     * @see ServiceState
+     * STATE_IN_SERVICE, STATE_OUT_OF_SERVICE, STATE_EMERGENCY_ONLY, STATE_POWER_OFF
+     */
+    private int[] mDataRegState;
+
+    private WifiManager.WifiLock mWifiLock;
+
+    private SettingsObserver mSettingsObserver = new SettingsObserver(null);
+
+    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Log.d(TAG, "onReceive action:" + intent.getAction());
+            if (intent.getAction().equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
+                if (mWifiManager == null) {
+                    Log.d(TAG, "Unexpected error, mWifiManager is null!");
+                    return;
+                }
+
+                boolean isWifiEnabled = mWifiManager.isWifiEnabled();
+                if (isWifiEnabled != mIsWifiEnabled) {
+                    mIsWifiEnabled = isWifiEnabled;
+                    notifyMalUserProfile();
+                }
+            } else if (intent.getAction().equals(
+                    PhoneConstants.ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED)) {
+                int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY,
+                        RILConstants.NO_PHONE);
+                if (phoneType != RILConstants.IMS_PHONE) {
+                    Log.d(TAG, "not IMS phone");
+                    return;
+                }
+                boolean inCall = false;
+                int callType = IMSCALL_NONE;
+                String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+                if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                        || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                    inCall = true;
+                    // TODO: detect voice or video call if MAL needs it
+                    callType = IMSCALL_IR92_VOICE_CALL;
+                }
+                notifyCallState(inCall, callType);
+            }
+        }
+    };
+
+    private INetworkManagementEventObserver mNetworkObserver = new BaseNetworkObserver() {
+        @Override
+        public void addressUpdated(String iface, LinkAddress address) {
+            Log.d(TAG, "mNetworkObserver.addressUpdated: iface=" + iface
+                    + ", address = " + address);
+            if (iface != null && iface.startsWith("wlan")
+                    && address != null && address.getAddress() instanceof Inet6Address
+                    && address.isGlobalPreferred()) {
+                // At this timing, just refresh IPV6 address without changing 'mIsWifiConnected'.
+                // mIsWifiConnected depends on ConnectivityManager.NetworkCallback.onAvailable.
+                Message msg = mHandler.obtainMessage(
+                        EVENT_WIFI_NETWORK_STATE_CHANGE,
+                        mIsWifiConnected?1:0,  // isConnected
+                        0, null);
+                mHandler.sendMessage(msg);
+            }
+        }
+    };
+
+    private class SettingsObserver extends ContentObserver {
+        private final Uri VOLTE_ENABLED_URI = Settings.Global
+                .getUriFor(android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED);
+        private final Uri WFC_ENABLED_URI = Settings.Global
+                .getUriFor(android.provider.Settings.Global.WFC_IMS_ENABLED);
+        private final Uri WFC_MODE_URI = Settings.Global
+                .getUriFor(android.provider.Settings.Global.WFC_IMS_MODE);
+
+        public SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        private void register() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(VOLTE_ENABLED_URI, false, this);
+            resolver.registerContentObserver(WFC_ENABLED_URI, false, this);
+            resolver.registerContentObserver(WFC_MODE_URI, false, this);
+        }
+
+        private void unregister() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.unregisterContentObserver(this);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            onChange(selfChange, null);
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            if (VOLTE_ENABLED_URI.equals(uri)) {
+                mIsVolteEnabled = ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mContext);
+            }
+            if (WFC_ENABLED_URI.equals(uri)) {
+                mIsWfcEnabled = ImsManager.isWfcEnabledByUser(mContext);
+            }
+            if (WFC_MODE_URI.equals(uri)) {
+                mWfcMode = ImsManager.getWfcMode(mContext);
+            }
+            notifyMalUserProfile();
+        }
+    }
+
+    private SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangedlistener =
+            new SubscriptionManager.OnSubscriptionsChangedListener() {
+
+            @Override
+            public void onSubscriptionsChanged() {
+                mHandler.sendMessage(mHandler.obtainMessage(EVENT_SUBSCRIPTION_INFO_CHANGED));
+           }
+    };
+
+    // Message codes. See mHandler below.
+    private static final int EVENT_WIFI_NETWORK_STATE_CHANGE = 1;
+    private static final int EVENT_SUBSCRIPTION_INFO_CHANGED = 2;
+    private static final int EVENT_NOTIFY_SERVICE_STATE_CHANGE = 3;
+
+    private Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case EVENT_WIFI_NETWORK_STATE_CHANGE:
+                    updateWifiConnectedInfo(msg.arg1);
+                    break;
+                case EVENT_SUBSCRIPTION_INFO_CHANGED:
+                    updateServiceStateListeners();
+                    updateDataRoamingSetting();
+                    break;
+                case EVENT_NOTIFY_SERVICE_STATE_CHANGE:
+                    updateServiceState(msg.arg1, (ServiceState)msg.obj);
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+
+    public WifiOffloadService(Context context) {
+        nativeInit();
+        mContext = context;
+        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        mConnectivityManager = ConnectivityManager.from(mContext);
+        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
+        mNetworkManager = INetworkManagementService.Stub.asInterface(b);
+
+        mSubscriptionManager = SubscriptionManager.from(mContext);
+        mSubscriptionManager.addOnSubscriptionsChangedListener(mSubscriptionsChangedlistener);
+
+        mTelephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+
+        mIsVolteEnabled = ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mContext);
+        mIsWfcEnabled = ImsManager.isWfcEnabledByUser(mContext);
+        mWfcMode = ImsManager.getWfcMode(mContext);
+        mIsWifiEnabled = mWifiManager.isWifiEnabled();
+        mDataRoamingEnabled = getDataRoamingSetting();
+
+        if (mTelephonyManager != null) {
+            mSimCount = mTelephonyManager.getSimCount();
+            mIsCurDataRoaming = new boolean[mSimCount];
+            mRadioTechnology = new int[mSimCount];
+            mDataRegState = new int[mSimCount];
+        }
+
+        if (mWifiManager != null) {
+            mWifiLock = mWifiManager.createWifiLock("WifiOffloadService-Wifi Lock");
+            if (mWifiLock != null) {
+                mWifiLock.setReferenceCounted(false);
+            }
+        }
+
+        // force update user profile to MAL at first time.
+        notifyMalUserProfile();
+
+        mSettingsObserver.register();
+        registerForBroadcast();
+        setupCallbacksForWifiStatus();
+        updateServiceStateListeners();
+        Log.d(TAG, "Initialize finish");
+    }
+
+    private void updateServiceStateListeners() {
+        if (mSubscriptionManager == null) {
+            Log.d(TAG, "Unexpected error, mSubscriptionManager=null");
+            return;
+        }
+        if (mTelephonyManager == null) {
+            Log.d(TAG, "Unexpected error, mTelephonyManager=null");
+            return;
+        }
+
+        HashSet<Integer> unUsedSubscriptions =
+                new HashSet<Integer>(mPhoneServicesStateListeners.keySet());
+        final List<SubscriptionInfo> slist = mSubscriptionManager.getActiveSubscriptionInfoList();
+
+        if (slist != null) {
+            for (SubscriptionInfo subInfoRecord : slist) {
+                int subId = subInfoRecord.getSubscriptionId();
+                if (mPhoneServicesStateListeners.get(subId) == null) {
+                    // Create listeners for new subscriptions.
+                    Log.d(TAG, "create ServicesStateListener for " + subId);
+                    PhoneStateListener listener = new PhoneStateListener(subId) {
+                            @Override
+                            public void onServiceStateChanged(ServiceState serviceState) {
+                                if (serviceState == null) {
+                                    Log.d(TAG, "onServiceStateChanged-" + this.mSubId
+                                            + ": serviceState is null");
+                                    return;
+                                }
+                                mHandler.sendMessage(
+                                mHandler.obtainMessage(EVENT_NOTIFY_SERVICE_STATE_CHANGE,
+                                        this.mSubId, 0, serviceState));
+                            }
+                    };
+
+                    mTelephonyManager.listen(
+                            listener, PhoneStateListener.LISTEN_SERVICE_STATE);
+                    mPhoneServicesStateListeners.put(subId, listener);
+                } else {
+                    // this is still a valid subscription.
+                    Log.d(TAG, "ServicesStateListener-" + subId + " is used.");
+                    unUsedSubscriptions.remove(subId);
+                }
+            }
+        }
+
+        for (Integer key: unUsedSubscriptions) {
+            Log.d(TAG, "remove unused ServicesStateListener for " + key);
+            mTelephonyManager.listen(mPhoneServicesStateListeners.get(key), 0);
+            mPhoneServicesStateListeners.remove(key);
+        }
+    }
+
+    @Override
+    public void registerForHandoverEvent(IWifiOffloadListener listener) {
+        mListeners.add(listener);
+    }
+
+    @Override
+    public void unregisterForHandoverEvent(IWifiOffloadListener listener) {
+        mListeners.remove(listener);
+    }
+
+    @Override
+    public int getRatType() {
+        int result = nativeGetRatType();
+        Log.d(TAG, "rat type is " + result);
+        return result;
+    }
+
+    @Override
+    public DisconnectCause getDisconnectCause() {
+        DisconnectCause result = nativeGetDisconnectCause();
+        Log.d(TAG, "disconnect cause is " + result);
+        return result;
+    }
+
+    @Override
+    public void setEpdgFqdn(String fqdn, boolean wfcEnabled) {
+        if (fqdn == null) {
+            Log.d(TAG, "fqdn is null");
+            return;
+        }
+        mFqdn = fqdn;
+        mIsWfcEnabled = wfcEnabled;
+        notifyMalUserProfile();
+    }
+
+    private void registerForBroadcast() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(PhoneConstants.ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED);
+        mContext.registerReceiver(mReceiver, filter);
+    }
+
+    private void updateWifiConnectedInfo(int isConnected) {
+        Log.d(TAG, "updateWifiConnectedInfo isConnected=" + isConnected);
+
+        boolean changed = false;
+
+        if (isConnected == 0) {
+            if (mIsWifiConnected) {
+                mIsWifiConnected = false;
+                mWifiApMac = "";
+                mWifiIpv4Address = "";
+                mWifiIpv6Address = "";
+                mIfName ="";
+                changed = true;
+            }
+        } else {
+            String wifiApMac = "", ipv4Address = "", ipv6Address = "", ifName = "";
+
+            if (!mIsWifiConnected) {
+                mIsWifiConnected = true;
+                changed = true;
+            }
+
+            // get MAC address of the current access point
+            WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
+            if (wifiInfo != null) {
+                wifiApMac = wifiInfo.getBSSID();
+                if (!mWifiApMac.equals(wifiApMac)) {
+                    mWifiApMac = (wifiApMac == null ? "" : wifiApMac);
+                    changed = true;
+                }
+            }
+
+            // get ip
+            for (Network nw : mConnectivityManager.getAllNetworks()) {
+                LinkProperties prop = mConnectivityManager.getLinkProperties(nw);
+                // MAL only care about wlan
+                if (prop == null || prop.getInterfaceName() == null
+                        || !prop.getInterfaceName().startsWith("wlan")) {
+                    continue;
+                }
+                for (InetAddress address : prop.getAddresses()) {
+                    if (address instanceof Inet4Address) {
+                        ipv4Address = address.getHostAddress();
+                    } else if (address instanceof Inet6Address && !address.isLinkLocalAddress()) {
+                        // Filters out link-local address. If cannot find non-link-local address,
+                        // pass empty string to MAL.
+                        ipv6Address = address.getHostAddress();
+                    }
+                }
+                // get interface name
+                ifName = prop.getInterfaceName();
+            }
+            if (!mWifiIpv4Address.equals(ipv4Address)) {
+                mWifiIpv4Address = (ipv4Address == null ? "" : ipv4Address);
+                changed = true;
+            }
+            if (!mWifiIpv6Address.equals(ipv6Address)) {
+                mWifiIpv6Address = (ipv6Address == null ? "" : ipv6Address);
+                changed = true;
+            }
+            if (!mIfName.equals(ifName)) {
+                mIfName = (ifName == null ? "" : ifName);
+                changed = true;
+            }
+        }
+
+        if (changed) {
+            notifyMalWifiState();
+        }
+    }
+
+    // Currently it only care about MD1's data roaming setting.
+    private int getDataRoamingSetting() {
+        if (mSubscriptionManager == null) {
+            Log.d(TAG, "Unexpected error, mSubscriptionManager=null");
+            return SubscriptionManager.DATA_ROAMING_DISABLE;
+        }
+
+        int mainCapabilityPhoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(
+                mainCapabilityPhoneId);
+        Log.d(TAG, "getDataRoamingSetting: mainCapabilityPhoneId=" + mainCapabilityPhoneId
+                + " , subInfo=" + subInfo);
+
+        if (subInfo != null) {
+            return subInfo.getDataRoaming();
+        } else {
+            Log.d(TAG, "Cannot get subscription information for slot:" + mainCapabilityPhoneId);
+            return SubscriptionManager.DATA_ROAMING_DISABLE;
+        }
+    }
+
+    private void updateDataRoamingSetting() {
+        int isDataRoamingEnabled = getDataRoamingSetting();
+        if (isDataRoamingEnabled != mDataRoamingEnabled) {
+            mDataRoamingEnabled = isDataRoamingEnabled;
+            notifyMalUserProfile();
+        }
+    }
+
+    private void updateServiceState(int subId, ServiceState state) {
+        boolean isDataRoaming = state.getDataRoaming();
+        int radioTechnology = state.getRilDataRadioTechnology();
+        int dataRegState = state.getDataRegState();
+
+        if (radioTechnology == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
+            dataRegState = ServiceState.STATE_OUT_OF_SERVICE;
+        }
+
+        int simId = SubscriptionManager.getPhoneId(subId);
+        int mainCapabilityPhoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        int mdIdx = mainCapabilityPhoneId==simId?0:1;
+
+        if (simId < 0 || simId >= mSimCount) {
+            Log.d(TAG, "updateServiceState: sim-" + simId + " sub-" + subId
+                    + ": invalid simId");
+            return;
+        }
+
+        Log.d(TAG, "updateServiceState: sim-" + simId + " sub-" + subId
+                + ", isDataRoaming=" + isDataRoaming
+                + ", radioTechnology=" + radioTechnology
+                + ", dataRegState=" + dataRegState);
+
+        if (mIsCurDataRoaming[simId] != isDataRoaming
+                || mRadioTechnology[simId] != radioTechnology
+                || mDataRegState[simId] != dataRegState) {
+            mIsCurDataRoaming[simId] = isDataRoaming;
+            mRadioTechnology[simId] = radioTechnology;
+            mDataRegState[simId] = dataRegState;
+            notifyMalServiceState(simId, subId);
+        }
+    }
+
+    private void notifyMalUserProfile() {
+        Log.d(TAG, "notifyMalUserProfile mIsVolteEnabled: " + mIsVolteEnabled + " mIsWfcEnabled: "
+                + mIsWfcEnabled + " mFqdn: " + mFqdn + " mIsWifiEnabled: " + mIsWifiEnabled
+                + " mWfcMode: " + mWfcMode + " mDataRoamingEnabled: " + mDataRoamingEnabled);
+        nativeSetWosProfile(mIsVolteEnabled, mIsWfcEnabled, mFqdn,
+                mIsWifiEnabled, mWfcMode, mDataRoamingEnabled);
+    }
+
+    private void notifyMalWifiState() {
+        Log.d(TAG, "notifyMalWifiState mIsWifiConnected: " + mIsWifiConnected + " mIfaceName: "
+                + mIfName + " mWifiIpv4Address: " + mWifiIpv4Address + " mWifiIpv6Address: "
+                + mWifiIpv6Address + " mWifiApMac: " + mWifiApMac);
+        nativeSetWifiStatus(mIsWifiConnected, mIfName, mWifiIpv4Address, mWifiIpv6Address,
+                mWifiApMac);
+    }
+
+    private void notifyCallState(boolean inCall, int callType) {
+        Log.d(TAG, "notifyCallState inCall: " + inCall + " callType: " + callType);
+        nativeSetCallState(inCall, callType);
+    }
+
+    private void notifyMalServiceState(int simIdx, int mdIdx) {
+        Log.d(TAG, "nativeSetServiceState simIdx: " + simIdx
+                + "mdIdx: " + mdIdx
+                + "mIsCurDataRoaming: " + mIsCurDataRoaming[simIdx]
+                + ", mRadioTechnology: " + mRadioTechnology[simIdx]
+                + ", mDataRegState: " + mDataRegState[simIdx]);
+        nativeSetServiceState(mdIdx, simIdx, mIsCurDataRoaming[simIdx],
+                mRadioTechnology[simIdx], mDataRegState[simIdx]);
+    }
+
+    /**
+     * callback from MAL when IMS PDN handover.
+     * @param stage handover start/end
+     * @param ratType current rat type
+     */
+    private void onHandover(int stage, int ratType) {
+        for (IWifiOffloadListener listener : mListeners) {
+            if (listener != null) {
+                try {
+                    listener.onHandover(stage, ratType);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onHandover: RemoteException occurs!");
+                }
+            }
+        }
+    }
+
+    /**
+     * callback from MAL when rove out condition meets.
+     * @param roveOut is rove out or not
+     * @param rssi current WiFi rssi
+     */
+    private void onRoveOut(boolean roveOut, int rssi) {
+        Log.d(TAG, "onRoveOut: roveOut is " + roveOut + " rssi " + rssi);
+        for (IWifiOffloadListener listener : mListeners) {
+            if (listener != null) {
+                try {
+                    listener.onRoveOut(roveOut, rssi);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onRoveOut: RemoteException occurs!");
+                }
+            }
+        }
+    }
+
+    /**
+     * callback from MAL when IMS PDN is lost
+     */
+    private void onLost() {
+        // TODO: broadcast
+    }
+
+    /**
+     * callback from MAL when IMS PDN is unavailable
+     */
+    private void onUnavailable() {
+        // TODO: broadcast
+    }
+
+    /**
+     * callback from MAL when PDN over ePDG is active.
+     * @param active is PDN over ePDG active or in-active.
+     */
+    private void onPdnStateChanged(boolean active) {
+        Log.d(TAG, "onPdnStateChanged: active=" + active);
+        if (mWifiLock == null) {
+            Log.d(TAG, "Unexpected error, mWifiLock is null");
+        }
+
+        if (active) {
+            mWifiLock.acquire();
+        } else {
+            mWifiLock.release();
+        }
+    }
+
+    /**
+     * setup callbacks from ConnectivityService when WiFi is changed.
+     */
+    private void setupCallbacksForWifiStatus() {
+        if (mConnectivityManager == null) {
+            Log.d(TAG, "Unexpected error, mConnectivityManager=null");
+            return;
+        }
+
+        if (mNetworkManager == null) {
+            Log.d(TAG, "Unexpected error, mNetworkManager=null");
+            return;
+        }
+
+
+        NetworkRequest request = new NetworkRequest.Builder()
+                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
+                .build();
+        mConnectivityManager.registerNetworkCallback(request,
+                new ConnectivityManager.NetworkCallback() {
+                    /**
+                     * @param network
+                     */
+                    @Override
+                    public void onAvailable(Network network) {
+                        Log.d(TAG, "NetworkCallback.onAvailable, network=" + network);
+
+                        Message msg = mHandler.obtainMessage(
+                                EVENT_WIFI_NETWORK_STATE_CHANGE,
+                                1,  // isConnected
+                                0, null);
+                        mHandler.sendMessage(msg);
+                    }
+
+                    /**
+                     * @param network
+                     */
+                    @Override
+                    public void onLost(Network network) {
+                        Log.d(TAG, "NetworkCallback.onLost, network=" + network);
+
+                        Message msg = mHandler.obtainMessage(
+                                EVENT_WIFI_NETWORK_STATE_CHANGE,
+                                0,  // isConnected
+                                0, null);
+                        mHandler.sendMessage(msg);
+                    }
+                });
+
+        try {
+            mNetworkManager.registerObserver(mNetworkObserver);
+        } catch (Exception e) {
+            Log.d(TAG, "mNetworkManager.registerObserver failed: " + e);
+        }
+    }
+}
diff --git a/packages/simservs/Android.mk b/packages/simservs/Android.mk
new file mode 100644
index 00000000000..573551b5d0b
--- /dev/null
+++ b/packages/simservs/Android.mk
@@ -0,0 +1,18 @@
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_JAVA_LIBRARIES := okhttp
+LOCAL_STATIC_JAVA_LIBRARIES := xcap
+
+# Include all the java files.
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_MODULE_TAGS := optional
+
+# The name of the jar file to create.
+LOCAL_MODULE := Simservs
+
+# Build a static jar file.
+include $(BUILD_STATIC_JAVA_LIBRARY)
+
diff --git a/packages/simservs/README b/packages/simservs/README
new file mode 100644
index 00000000000..4a85f260401
--- /dev/null
+++ b/packages/simservs/README
@@ -0,0 +1,23 @@
+Library of MTK IMS VoLTE Supplementary Service features, including call forwarding (communication diversion),
+call barring (communication barring), call waiting (communication waiting).
+
+This library is pre-built by MediaTek internal.
+
+
+WHAT IT DOES?
+=============
+MMTelSS module will depend on Simservs to query/update each and every VoLTE Supplementary Service.
+
+HOW IT WAS BUILT?
+==================
+It needs the following library from MediaTek:
+1.  xcap
+
+All source/dependency modules of this module are already put in
+'vendor/mediatek/proprietary/protect/external' folder.
+
+HOW TO USE IT?
+==============
+Provide api for MMTelSS to communicate with XCAP server.
+
+All the source code of this library were written by MediaTek co..
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/ActionCapabilities.java b/packages/simservs/src/com/mediatek/simservs/capability/ActionCapabilities.java
new file mode 100644
index 00000000000..5681effaa7e
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/ActionCapabilities.java
@@ -0,0 +1,134 @@
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * Action capability class.
+ */
+public class ActionCapabilities extends ServiceCapabilities implements ConfigureType {
+
+    public static final String NODE_NAME = "serv-cap-actions";
+
+    static final String TAG_TARGET = "serv-cap-target";
+    static final String TAG_NOTIFY_CALLER = "serv-cap-notify-caller";
+    static final String TAG_NOTIFY_SERVED_USER = "serv-cap-notify-served-user";
+    static final String TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL =
+            "serv-cap-notify-served-user-on-outbound-call";
+    static final String TAG_REVEAL_IDENTITY_TO_CALLER = "serv-cap-reveal-identity-to-caller";
+    static final String TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER =
+            "serv-cap-reveal-served-user-identity-to-caller";
+    static final String TAG_REVEAL_IDENTITY_TO_TARGET = "serv-cap-reveal-identity-to-target";
+
+    public boolean mNotifyCallerProvisioned = false;
+    public boolean mNotifyServedUserProvisioned = false;
+    public boolean mNotifyServedUserOnOutboundCallProvisioned = false;
+    public boolean mRevealIdentityToCallerProvisioned = false;
+    public boolean mRevealServedUserIdentityToCallerProvisioned = false;
+    public boolean mRevealIdentityToTargetProvisioned = false;
+
+    /**
+     * Constructor without XML Node.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public ActionCapabilities(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor without XML Node.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param nodes         pre-define action capability node
+     */
+    public ActionCapabilities(XcapUri xcapUri, String parentUri, String intendedId,
+            Node nodes) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(nodes);
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+
+        NodeList conditionNode = domElement.getElementsByTagName(TAG_NOTIFY_CALLER);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mNotifyCallerProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_NOTIFY_SERVED_USER);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mNotifyServedUserProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mNotifyServedUserOnOutboundCallProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_REVEAL_IDENTITY_TO_CALLER);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRevealIdentityToCallerProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRevealServedUserIdentityToCallerProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_REVEAL_IDENTITY_TO_TARGET);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRevealIdentityToTargetProvisioned = provisioned.equals(TRUE);
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    public boolean isNotifyCallerProvisioned() {
+        return mNotifyCallerProvisioned;
+    }
+
+    public boolean isNotifyServedUserProvisioned() {
+        return mNotifyServedUserProvisioned;
+    }
+
+    public boolean isNotifyServedUserOnOutboundCallProvisioned() {
+        return mNotifyServedUserOnOutboundCallProvisioned;
+    }
+
+    public boolean isRevealIdentityToCallerProvisioned() {
+        return mRevealIdentityToCallerProvisioned;
+    }
+
+    public boolean isRevealServedUserIdentityToCallerProvisioned() {
+        return mRevealServedUserIdentityToCallerProvisioned;
+    }
+
+    public boolean isRevealIdentityToTargetProvisioned() {
+        return mRevealIdentityToTargetProvisioned;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/BarringServiceCapability.java b/packages/simservs/src/com/mediatek/simservs/capability/BarringServiceCapability.java
new file mode 100644
index 00000000000..1f16bb67822
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/BarringServiceCapability.java
@@ -0,0 +1,56 @@
+
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Barring Service Capability class.
+ *
+ */
+public class BarringServiceCapability extends CapabilitiesType {
+
+    public static final String NODE_NAME = "communication-barring-serv-cap";
+
+    ConditionCapabilities mConditionCapabilities;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public BarringServiceCapability(XcapUri xcapUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    public ConditionCapabilities getConditionCapabilities() {
+        return mConditionCapabilities;
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList conditionsNode = domDoc.getElementsByTagName(ConditionCapabilities.NODE_NAME);
+        if (conditionsNode.getLength() > 0) {
+            Element conditionNode = (Element) conditionsNode.item(0);
+            mConditionCapabilities = new ConditionCapabilities(mXcapUri, NODE_NAME, mIntendedId,
+                    conditionNode);
+        }
+
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/CapabilitiesType.java b/packages/simservs/src/com/mediatek/simservs/capability/CapabilitiesType.java
new file mode 100644
index 00000000000..c971a69c65e
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/CapabilitiesType.java
@@ -0,0 +1,125 @@
+
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.InquireType;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+import java.io.StringReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Capability type abstract class.
+ *
+ */
+public abstract class CapabilitiesType extends InquireType {
+
+    static final String ATT_ACTIVE = "active";
+
+    public boolean mActived = false;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public CapabilitiesType(XcapUri xcapUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(xcapUri, parentUri, intendedId);
+        loadConfiguration();
+    }
+
+    /**
+     * Instantiate from server XML text.
+     *
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    private void loadConfiguration() throws XcapException, ParserConfigurationException {
+        String xmlContent = getContent();
+        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+        InputSource is = new InputSource();
+        is.setCharacterStream(new StringReader(xmlContent));
+        Document doc;
+        try {
+            doc = db.parse(is);
+        } catch (SAXException e) {
+            e.printStackTrace();
+            // Throws a server error
+            throw new XcapException(500);
+        } catch (IOException e) {
+            e.printStackTrace();
+            // Throws a server error
+            throw new XcapException(500);
+        }
+        NodeList currentNode = doc.getElementsByTagName(getNodeName());
+
+        if (currentNode.getLength() > 0) {
+            Element activeElement = (Element) currentNode.item(0);
+            NamedNodeMap map = activeElement.getAttributes();
+            if (map.getLength() > 0) {
+                for (int i = 0; i < map.getLength(); i++) {
+                    Node node = map.item(i);
+                    if (node.getNodeName().equals(ATT_ACTIVE)) {
+                        mActived = node.getNodeValue().endsWith(TRUE);
+                        break;
+                    }
+                }
+            }
+        }
+        initServiceInstance(doc);
+    }
+
+    /**
+     * Decide Active by attribute.
+     *
+     * @return active value
+     * @throws XcapException    if XCAP error
+     */
+    public boolean isActive() throws XcapException {
+        String value = getByAttrName("active");
+        if (value == null) {
+            return true;
+        } else {
+            return getByAttrName("active").equals("true");
+        }
+    }
+
+    /**
+     * Set Active.
+     *
+     * @param active           active value
+     * @throws XcapException    if XCAP error
+     */
+    public void setActive(boolean active) throws XcapException {
+        if (active) {
+            setByAttrName("active", "true");
+        } else {
+            setByAttrName("active", "false");
+        }
+    }
+
+    /**
+     * Instantiate from XML text.
+     *
+     * @param domDoc  DOM document source
+     */
+    public abstract void initServiceInstance(Document domDoc);
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/ConditionCapabilities.java b/packages/simservs/src/com/mediatek/simservs/capability/ConditionCapabilities.java
new file mode 100644
index 00000000000..517074e89f0
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/ConditionCapabilities.java
@@ -0,0 +1,227 @@
+
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * Condition Capabilities class.
+ *
+ */
+public class ConditionCapabilities extends ServiceCapabilities implements ConfigureType {
+    public static final String NODE_NAME = "serv-cap-conditions";
+
+    static final String TAG_ANONYMOUS = "serv-cap-anonymous";
+    static final String TAG_REQUEST_NAME = "serv-cap-request-name";
+    static final String TAG_COMMUNICATION_DIVERTED = "serv-cap-communication-diverted";
+    static final String TAG_EXTERNAL_LIST = "serv-cap-external-list";
+    static final String TAG_IDENTITY = "serv-cap-identity";
+    static final String TAG_INTERNATIONAL = "serv-cap-international";
+    static final String TAG_INTERNATIONAL_EXHC = "serv-cap-international-exHC";
+    static final String TAG_MEDIA = "serv-cap-media";
+    static final String TAG_OTHER_IDENTITY = "serv-cap-other-identity";
+    static final String TAG_PRESENCE_STATUS = "serv-cap-presence-status";
+    static final String TAG_ROAMING = "serv-cap-roaming";
+    static final String TAG_RULE_DEACTIVATED = "serv-cap-rule-deactivated";
+    static final String TAG_VALIDITY = "serv-cap-validity";
+    static final String TAG_BUSY = "serv-cap-busy";
+    static final String TAG_NOT_REGISTERED = "serv-cap-not-registered";
+    static final String TAG_NO_ANSWER = "serv-cap-no-answer";
+    static final String TAG_NOT_REACHABLE = "serv-cap-not-reachable";
+
+    public boolean mAnonymousProvisioned = false;
+    public boolean mRequestNameProvisioned = false;
+    public boolean mCommunicationDivertedProvisioned = false;
+    public boolean mExternalListProvisioned = false;
+    public boolean mIdentityProvisioned = false;
+    public boolean mInternationalProvisioned = false;
+    public boolean mInternationalexHCProvisioned = false;
+    public boolean mOtherIdentityProvisioned = false;
+    public boolean mPresenceStatusProvisioned = false;
+    public boolean mRoamingProvisioned = false;
+    public boolean mRuleDeactivatedProvisioned = false;
+    public boolean mValidityProvisioned = false;
+
+    MediaConditions mMediaConditions;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public ConditionCapabilities(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor with XML nodes.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param nodes         XML nodes
+     */
+    public ConditionCapabilities(XcapUri xcapUri, String parentUri, String intendedId,
+            Node nodes) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(nodes);
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+
+        NodeList conditionNode = domElement.getElementsByTagName(TAG_ANONYMOUS);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mAnonymousProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_REQUEST_NAME);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRequestNameProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_COMMUNICATION_DIVERTED);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mCommunicationDivertedProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_EXTERNAL_LIST);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mExternalListProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_IDENTITY);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mIdentityProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_INTERNATIONAL);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mInternationalProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_INTERNATIONAL_EXHC);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mInternationalexHCProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_OTHER_IDENTITY);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mOtherIdentityProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_PRESENCE_STATUS);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mPresenceStatusProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_ROAMING);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRoamingProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_RULE_DEACTIVATED);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRuleDeactivatedProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_VALIDITY);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mValidityProvisioned = provisioned.equals(TRUE);
+        }
+
+        NodeList mediassNode = domElement.getElementsByTagName(TAG_MEDIA);
+        if (mediassNode.getLength() > 0) {
+            mMediaConditions = new MediaConditions(mXcapUri, NODE_NAME, mIntendedId,
+                    (Element) mediassNode.item(0));
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    public boolean isAnonymousProvisioned() {
+        return mAnonymousProvisioned;
+    }
+
+    public boolean isRequestNameProvisioned() {
+        return mRequestNameProvisioned;
+    }
+
+    public boolean isCommunicationDivertedProvisioned() {
+        return mCommunicationDivertedProvisioned;
+    }
+
+    public boolean isExternalListProvisioned() {
+        return mExternalListProvisioned;
+    }
+
+    public boolean isIdentityProvisioned() {
+        return mIdentityProvisioned;
+    }
+
+    public boolean isInternationalProvisioned() {
+        return mInternationalProvisioned;
+    }
+
+    public boolean isInternationalexHCProvisioned() {
+        return mInternationalexHCProvisioned;
+    }
+
+    public boolean isOtherIdentityProvisioned() {
+        return mOtherIdentityProvisioned;
+    }
+
+    public boolean isPresenceStatusProvisioned() {
+        return mPresenceStatusProvisioned;
+    }
+
+    public boolean isRoamingProvisioned() {
+        return mRoamingProvisioned;
+    }
+
+    public boolean isRuleDeactivatedProvisioned() {
+        return mRuleDeactivatedProvisioned;
+    }
+
+    public boolean isValidityProvisioned() {
+        return mValidityProvisioned;
+    }
+
+    public MediaConditions getMediaConditions() {
+        return mMediaConditions;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/DiversionServiceCapability.java b/packages/simservs/src/com/mediatek/simservs/capability/DiversionServiceCapability.java
new file mode 100644
index 00000000000..f97aec8579e
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/DiversionServiceCapability.java
@@ -0,0 +1,76 @@
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Communication Diversion Capability class.
+ *
+ */
+public class DiversionServiceCapability extends CapabilitiesType {
+    public static final String NODE_NAME = "communication-diversion-serv-cap";
+
+    ConditionCapabilities mConditionCapabilities;
+    ActionCapabilities mActionCapabilities;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public DiversionServiceCapability(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Get available condition configuration items.
+     *
+     * @return  condition capabilities
+     */
+    public ConditionCapabilities getConditionCapabilities() {
+        return mConditionCapabilities;
+    }
+
+    /**
+     * Get available action configuration items.
+     *
+     * @return  action capabilities
+     */
+    public ActionCapabilities getActionCapabilities() {
+        return mActionCapabilities;
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList actionsNode = domDoc.getElementsByTagName(ActionCapabilities.NODE_NAME);
+        if (actionsNode.getLength() > 0) {
+            Element actionNode = (Element) actionsNode.item(0);
+            mActionCapabilities = new ActionCapabilities(mXcapUri, NODE_NAME, mIntendedId,
+                    actionNode);
+        }
+
+        NodeList conditionsNode = domDoc.getElementsByTagName(ConditionCapabilities.NODE_NAME);
+        if (conditionsNode.getLength() > 0) {
+            Element conditionNode = (Element) conditionsNode.item(0);
+            mConditionCapabilities = new ConditionCapabilities(mXcapUri, NODE_NAME, mIntendedId,
+                    conditionNode);
+        }
+
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/MediaConditions.java b/packages/simservs/src/com/mediatek/simservs/capability/MediaConditions.java
new file mode 100644
index 00000000000..71a8897719a
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/MediaConditions.java
@@ -0,0 +1,70 @@
+
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Media Conditions class.
+ */
+public class MediaConditions extends XcapElement implements ConfigureType {
+    public static final String NODE_NAME = "serv-cap-media";
+
+    static final String TAG_MEDIA = "media";
+
+    List<String> mMedias;
+
+    /**
+     * Construct without XML.
+     *
+     * @param xcapUri           XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     */
+    public MediaConditions(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Construct with XML.
+     *
+     * @param xcapUri           XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @param domElement        XML element
+     */
+    public MediaConditions(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        NodeList mediasNode = domElement.getElementsByTagName(TAG_MEDIA);
+        mMedias = new LinkedList<String>();
+        for (int i = 0; i < mediasNode.getLength(); i++) {
+            Element mediaElement = (Element) mediasNode.item(i);
+            mMedias.add(mediaElement.getTextContent());
+        }
+
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    public List<String> getMedias() {
+        return mMedias;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/ServiceCapabilities.java b/packages/simservs/src/com/mediatek/simservs/capability/ServiceCapabilities.java
new file mode 100644
index 00000000000..fad780717b9
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/ServiceCapabilities.java
@@ -0,0 +1,29 @@
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Service Capability class.
+ */
+public class ServiceCapabilities extends XcapElement {
+
+    public static final String ATT_PROVISIONED = "provisioned";
+
+    /**
+     * Construct ServiceCapabilities instance.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public ServiceCapabilities(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return null;
+    }
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/CommunicationDiversion.java b/packages/simservs/src/com/mediatek/simservs/client/CommunicationDiversion.java
new file mode 100644
index 00000000000..15c2638835b
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/CommunicationDiversion.java
@@ -0,0 +1,346 @@
+
+package com.mediatek.simservs.client;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.RuleType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import java.util.LinkedList;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Communication Diversion class.
+ *
+ */
+public class CommunicationDiversion extends SimservType implements RuleType {
+
+    public static final String NODE_NAME = "communication-diversion";
+
+    NoReplyTimer mNoReplyTimer;
+    RuleSet mRuleSet;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri XCAP document URI
+     * @param parentUri   XCAP root directory URI
+     * @param intendedId  X-3GPP-Intended-Id
+     * @throws XcapException if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public CommunicationDiversion(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Instantiate from DOM XML.
+     *
+     * @param   domDoc  DOM document
+     */
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList noReplyTimerNode = domDoc.getElementsByTagName("NoReplyTimer");
+        if (noReplyTimerNode.getLength() > 0) {
+            Log.d("CommunicationDiversion", "Got NoReplyTimer");
+            Element noReplyTimerElement = (Element) noReplyTimerNode.item(0);
+            String val = noReplyTimerElement.getTextContent();
+            int noReplyTimer = Integer.parseInt(val);
+            mNoReplyTimer = new NoReplyTimer(mXcapUri, NODE_NAME, mIntendedId,
+                    noReplyTimer);
+            if (mNetwork != null) {
+                mNoReplyTimer.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mNoReplyTimer.setContext(mContext);
+            }
+
+            if (mEtag != null) {
+                mNoReplyTimer.setEtag(mEtag);
+            }
+        } else {
+            noReplyTimerNode = domDoc.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    "NoReplyTimer");
+            if (noReplyTimerNode.getLength() > 0) {
+                Log.d("CommunicationDiversion", "Got NoReplyTimer");
+                Element noReplyTimerElement = (Element) noReplyTimerNode.item(0);
+                String val = noReplyTimerElement.getTextContent();
+                int noReplyTimer = Integer.parseInt(val);
+                mNoReplyTimer = new NoReplyTimer(mXcapUri, NODE_NAME, mIntendedId,
+                        noReplyTimer);
+                if (mNetwork != null) {
+                    mNoReplyTimer.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mNoReplyTimer.setContext(mContext);
+                }
+
+                if (mEtag != null) {
+                    mNoReplyTimer.setEtag(mEtag);
+                }
+            } else {
+                noReplyTimerNode = domDoc.getElementsByTagName(XCAP_ALIAS + ":" + "NoReplyTimer");
+                if (noReplyTimerNode.getLength() > 0) {
+                    Log.d("CommunicationDiversion", "Got NoReplyTimer");
+                    Element noReplyTimerElement = (Element) noReplyTimerNode.item(0);
+                    String val = noReplyTimerElement.getTextContent();
+                    int noReplyTimer = Integer.parseInt(val);
+                    mNoReplyTimer = new NoReplyTimer(mXcapUri, NODE_NAME, mIntendedId,
+                            noReplyTimer);
+                    if (mNetwork != null) {
+                        mNoReplyTimer.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mNoReplyTimer.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mNoReplyTimer.setEtag(mEtag);
+                    }
+                } else {
+                    mNoReplyTimer = new NoReplyTimer(mXcapUri, NODE_NAME, mIntendedId,
+                            -1);
+                    if (mNetwork != null) {
+                        mNoReplyTimer.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mNoReplyTimer.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mNoReplyTimer.setEtag(mEtag);
+                    }
+                }
+            }
+        }
+
+        NodeList ruleSetNode = domDoc.getElementsByTagName("ruleset");
+        if (ruleSetNode.getLength() > 0) {
+            Log.d("CommunicationDiversion", "Got ruleset");
+            Element nruleSetElement = (Element) ruleSetNode.item(0);
+            mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId, nruleSetElement);
+            if (mNetwork != null) {
+                mRuleSet.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mRuleSet.setContext(mContext);
+            }
+
+            if (mEtag != null) {
+                mRuleSet.setEtag(mEtag);
+            }
+        } else {
+            ruleSetNode = domDoc.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "ruleset");
+            if (ruleSetNode.getLength() > 0) {
+                Log.d("CommunicationDiversion", "Got ruleset");
+                Element nruleSetElement = (Element) ruleSetNode.item(0);
+                mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                        nruleSetElement);
+                if (mNetwork != null) {
+                    mRuleSet.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mRuleSet.setContext(mContext);
+                }
+
+                if (mEtag != null) {
+                    mRuleSet.setEtag(mEtag);
+                }
+            } else {
+                ruleSetNode = domDoc.getElementsByTagName("cp:ruleset");
+                if (ruleSetNode.getLength() > 0) {
+                    Log.d("CommunicationDiversion", "Got ruleset");
+                    Element nruleSetElement = (Element) ruleSetNode.item(0);
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                            nruleSetElement);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                } else {
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                }
+            }
+        }
+    }
+
+    public int getNoReplyTimer() {
+        return mNoReplyTimer.getValue();
+    }
+
+    /**
+     * Set noreply timer.
+     *
+     * @param   timerValue  time value in second
+     * @throws  XcapException if XCAP error
+     */
+    public void setNoReplyTimer(int timerValue) throws XcapException {
+        mNoReplyTimer.setValue(timerValue);
+        String noReplyTimerXml = mNoReplyTimer.toXmlString();
+        mNoReplyTimer.setContent(noReplyTimerXml);
+        if (mNoReplyTimer.getEtag() != null) {
+            this.mEtag = mNoReplyTimer.getEtag();
+        }
+    }
+
+    /**
+    * Get rule set.
+    *
+    * @return Ruleset
+    */
+    @Override
+    public RuleSet getRuleSet() {
+        return mRuleSet;
+    }
+
+    /**
+     * Save ruleset to server.
+     *
+     * @throws  XcapException if XCAP error
+     */
+    @Override
+    public void saveRuleSet() throws XcapException {
+        String ruleXml = mRuleSet.toXmlString();
+        mRuleSet.setContent(ruleXml);
+        if (mRuleSet.getEtag() != null) {
+            this.mEtag = mRuleSet.getEtag();
+        }
+    }
+
+    /**
+     * Create ruleset.
+     *
+     * @return  ruleset
+     */
+    @Override
+    public RuleSet createNewRuleSet() {
+        mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+        if (mNetwork != null) {
+            mRuleSet.setNetwork(mNetwork);
+        }
+        if (mEtag != null) {
+            mRuleSet.setEtag(mEtag);
+        }
+        return mRuleSet;
+    }
+
+    /**
+     * Save rule to server.
+     *
+     * @param ruleId rule to be saved by the id
+     * @throws  XcapException if XCAP error
+     */
+    @Override
+    public void saveRule(String ruleId) throws XcapException {
+        if (ruleId != null && !ruleId.isEmpty()) {
+            LinkedList<Rule> rules =  (LinkedList<Rule>) mRuleSet.getRules();
+            for (Rule rule : rules) {
+                if (ruleId.equals(rule.mId)) {
+                    String ruleXml = rule.toXmlString();
+                    rule.setContent(ruleXml);
+                    if (rule.getEtag() != null) {
+                        this.mEtag = rule.getEtag();
+                    }
+                    break;
+                }
+            }
+        } else {
+            Log.d("saveRule", "ruleId is null");
+        }
+    }
+
+    /**
+     * NoReplyTimer class.
+     *
+     */
+    public class NoReplyTimer extends XcapElement {
+
+        public static final String NODE_NAME = "NoReplyTimer";
+        public int mValue;
+
+        /**
+         * Constructor without initial time value.
+         *
+         * @param cdUri       XCAP document URI
+         * @param parentUri   XCAP root directory URI
+         * @param intendedId  X-3GPP-Intended-Id
+         */
+        public NoReplyTimer(XcapUri cdUri, String parentUri, String intendedId) {
+            super(cdUri, parentUri, intendedId);
+        }
+
+        /**
+         * Constructor with initial time value.
+         *
+         * @param cdUri       XCAP document URI
+         * @param parentUri   XCAP root directory URI
+         * @param intendedId  X-3GPP-Intended-Id
+         * @param initValue   time value
+         */
+        public NoReplyTimer(XcapUri cdUri, String parentUri, String intendedId, int initValue) {
+            super(cdUri, parentUri, intendedId);
+            mValue = initValue;
+        }
+
+        @Override
+        protected String getNodeName() {
+            return NODE_NAME;
+        }
+
+        public int getValue() {
+            return mValue;
+        }
+
+        public void setValue(int value) {
+            mValue = value;
+        }
+
+        /**
+         * Convert to XML string.
+         *
+         * @return XML string
+         */
+        public String toXmlString() {
+            return "<NoReplyTimer>" + String.valueOf(mValue)
+                    + "</NoReplyTimer>";
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/CommunicationWaiting.java b/packages/simservs/src/com/mediatek/simservs/client/CommunicationWaiting.java
new file mode 100644
index 00000000000..e8da86e6085
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/CommunicationWaiting.java
@@ -0,0 +1,42 @@
+
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Communication Waiting class.
+ *
+ */
+public class CommunicationWaiting extends SimservType {
+
+    public static final String NODE_NAME = "communication-waiting";
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public CommunicationWaiting(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        // No content need to be parsed for this service
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/DefaultBehaviour.java b/packages/simservs/src/com/mediatek/simservs/client/DefaultBehaviour.java
new file mode 100644
index 00000000000..8b723b0b10e
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/DefaultBehaviour.java
@@ -0,0 +1,93 @@
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
+/**
+ * Default Behaviour class.
+ *
+ */
+public class DefaultBehaviour extends XcapElement {
+
+    public static final String NODE_NAME = "default-behaviour";
+
+    public static final String DEFAULT_BEHAVIOUR_PRESENTATION_RESTRICTED =
+            "presentation-restricted";
+    public static final String DEFAULT_BEHAVIOUR_PRESENTATION_NOT_RESTRICTED =
+            "presentation-not-restricted";
+
+    public boolean mPresentationRestricted;
+
+    /**
+     * Constructor.
+     *
+     * @param cdUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public DefaultBehaviour(XcapUri cdUri, String parentUri, String intendedId) {
+        super(cdUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    XML element
+     */
+    public DefaultBehaviour(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        String content = domElement.getTextContent();
+        mPresentationRestricted = content.equals(DEFAULT_BEHAVIOUR_PRESENTATION_RESTRICTED);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Convert to XML string.
+     *
+     * @return  XML string
+     */
+    public String toXmlString() {
+        if (mPresentationRestricted) {
+            return "<default-behaviour>" + DEFAULT_BEHAVIOUR_PRESENTATION_RESTRICTED
+                    + "</default-behaviour>";
+        } else {
+            return "<default-behaviour>" + DEFAULT_BEHAVIOUR_PRESENTATION_NOT_RESTRICTED
+                    + "</default-behaviour>";
+        }
+    }
+
+    /**
+     * Convert to XML element.
+     *
+     * @param   document    DOM document
+     * @return  XML element
+     */
+    public Element toXmlElement(Document document) {
+        Element defaultElement = (Element) document.createElement(NODE_NAME);
+        if (mPresentationRestricted) {
+            defaultElement.setTextContent(DEFAULT_BEHAVIOUR_PRESENTATION_RESTRICTED);
+        } else {
+            defaultElement.setTextContent(DEFAULT_BEHAVIOUR_PRESENTATION_NOT_RESTRICTED);
+        }
+        return defaultElement;
+    }
+
+    public boolean isPresentationRestricted() {
+        return mPresentationRestricted;
+    }
+
+    public void setPresentationRestricted(boolean presentationRestricted) {
+        mPresentationRestricted = presentationRestricted;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/IncomingCommunicationBarring.java b/packages/simservs/src/com/mediatek/simservs/client/IncomingCommunicationBarring.java
new file mode 100644
index 00000000000..6cda67bbe84
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/IncomingCommunicationBarring.java
@@ -0,0 +1,177 @@
+package com.mediatek.simservs.client;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.RuleType;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import java.util.LinkedList;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Incoming Communication Barring class.
+ *
+ */
+public class IncomingCommunicationBarring extends SimservType implements RuleType {
+
+    public static final String NODE_NAME = "incoming-communication-barring";
+
+    RuleSet mRuleSet;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public IncomingCommunicationBarring(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList ruleSetNode = domDoc.getElementsByTagName("ruleset");
+        if (ruleSetNode.getLength() > 0) {
+            Log.d("IncomingCommunicationBarring", "Got ruleset");
+            Element nruleSetElement = (Element) ruleSetNode.item(0);
+            mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId, nruleSetElement);
+            if (mNetwork != null) {
+                mRuleSet.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mRuleSet.setContext(mContext);
+            }
+
+            if (mEtag != null) {
+                mRuleSet.setEtag(mEtag);
+            }
+        } else {
+            ruleSetNode = domDoc.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "ruleset");
+            if (ruleSetNode.getLength() > 0) {
+                Log.d("IncomingCommunicationBarring", "Got ruleset");
+                Element nruleSetElement = (Element) ruleSetNode.item(0);
+                mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                        nruleSetElement);
+                if (mNetwork != null) {
+                    mRuleSet.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mRuleSet.setContext(mContext);
+                }
+
+                if (mEtag != null) {
+                    mRuleSet.setEtag(mEtag);
+                }
+            } else {
+                ruleSetNode = domDoc.getElementsByTagName("cp:ruleset");
+                if (ruleSetNode.getLength() > 0) {
+                    Log.d("IncomingCommunicationBarring", "Got cp:ruleset");
+                    Element nruleSetElement = (Element) ruleSetNode.item(0);
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                            nruleSetElement);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                } else {
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Get ruleset.
+     *
+     * @return ruleset
+     */
+    @Override
+    public RuleSet getRuleSet() {
+        return mRuleSet;
+    }
+
+    /**
+     * Save ruleset configuration to server.
+     *
+     * @throws XcapException    if XCAP error
+     */
+    @Override
+    public void saveRuleSet() throws XcapException {
+        String ruleXml = mRuleSet.toXmlString();
+        mRuleSet.setContent(ruleXml);
+    }
+
+    /**
+     * Create ruleset.
+     *
+     * @return new ruleset
+     */
+    @Override
+    public RuleSet createNewRuleSet() {
+        mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+        if (mNetwork != null) {
+            mRuleSet.setNetwork(mNetwork);
+        }
+        if (mEtag != null) {
+            mRuleSet.setEtag(mEtag);
+        }
+        return mRuleSet;
+    }
+
+    /**
+     * Save rule to server.
+     *
+     * @param ruleId rule to be saved by the id
+     * @throws  XcapException if XCAP error
+     */
+    @Override
+    public void saveRule(String ruleId) throws XcapException {
+        if (ruleId != null && !ruleId.isEmpty()) {
+            LinkedList<Rule> rules =  (LinkedList<Rule>) mRuleSet.getRules();
+            for (Rule rule : rules) {
+                if (ruleId.equals(rule.mId)) {
+                    String ruleXml = rule.toXmlString();
+                    rule.setContent(ruleXml);
+                }
+            }
+        } else {
+            Log.d("saveRule", "ruleId is null");
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentation.java b/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentation.java
new file mode 100644
index 00000000000..904cde90bbf
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentation.java
@@ -0,0 +1,42 @@
+
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Originating Identity Presentation class.
+ */
+public class OriginatingIdentityPresentation extends SimservType {
+
+    public static final String NODE_NAME = "originating-identity-presentation";
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public OriginatingIdentityPresentation(XcapUri documentUri, String parentUri,
+            String intendedId) throws XcapException,
+            ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        // No content need to be parsed for this service
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentationRestriction.java b/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentationRestriction.java
new file mode 100644
index 00000000000..7492a3126c2
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentationRestriction.java
@@ -0,0 +1,154 @@
+
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+
+/**
+ * Originating Identity Presentation Restriction class.
+ */
+public class OriginatingIdentityPresentationRestriction extends SimservType {
+
+    public static final String NODE_NAME = "originating-identity-presentation-restriction";
+    public DefaultBehaviour mDefaultBehaviour;
+    public boolean mContainDefaultBehaviour = false;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param xui               X-3GPP-Intended-Id
+     * @throws  Exception       if error
+     */
+    public OriginatingIdentityPresentationRestriction(XcapUri documentUri, String parentUri,
+            String xui) throws Exception {
+        super(documentUri, parentUri, xui);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList defaultBehaviour = domDoc.getElementsByTagName(DefaultBehaviour.NODE_NAME);
+        if (defaultBehaviour.getLength() > 0) {
+            mContainDefaultBehaviour = true;
+            Element defaultBehaviourElement = (Element) defaultBehaviour.item(0);
+            mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId,
+                    defaultBehaviourElement);
+
+            if (mNetwork != null) {
+                mDefaultBehaviour.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mDefaultBehaviour.setContext(mContext);
+            }
+        } else {
+            defaultBehaviour = domDoc.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    DefaultBehaviour.NODE_NAME);
+            if (defaultBehaviour.getLength() > 0) {
+                mContainDefaultBehaviour = true;
+                Element defaultBehaviourElement = (Element) defaultBehaviour.item(0);
+                mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId,
+                        defaultBehaviourElement);
+
+                if (mNetwork != null) {
+                    mDefaultBehaviour.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mDefaultBehaviour.setContext(mContext);
+                }
+            } else {
+                mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId);
+
+                if (mNetwork != null) {
+                    mDefaultBehaviour.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mDefaultBehaviour.setContext(mContext);
+                }
+            }
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Save configuration to server.
+     *
+     * @throws XcapException    if XCAP error
+     */
+    public void saveConfiguration() throws XcapException {
+        String serviceXml = toXmlString();
+        setContent(serviceXml);
+        mContainDefaultBehaviour = true;
+    }
+
+    /**
+     * Convert DOM to XML string.
+     *
+     * @return XML string
+     */
+    public String toXmlString() {
+        Element root = null;
+        String xmlString = null;
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document document = builder.newDocument();
+            root = (Element) document.createElement(NODE_NAME);
+            document.appendChild(root);
+            Element defaultElement = mDefaultBehaviour.toXmlElement(document);
+            root.appendChild(defaultElement);
+            xmlString = domToXmlText(root);
+        } catch (ParserConfigurationException pce) {
+            // Parser with specified options can't be built
+            pce.printStackTrace();
+        } catch (TransformerConfigurationException e) {
+            e.printStackTrace();
+        } catch (TransformerException e) {
+            e.printStackTrace();
+        }
+        return xmlString;
+    }
+
+    public boolean isContainDefaultBehaviour() {
+        return mContainDefaultBehaviour;
+    }
+
+    public boolean isDefaultPresentationRestricted() {
+        return mDefaultBehaviour.isPresentationRestricted();
+    }
+
+    /**
+     * set Default Presentation Restricted value.
+     *
+     * @param presentationRestricted default restricted value
+     * @throws XcapException if XCAP error
+     */
+    public void setDefaultPresentationRestricted(boolean presentationRestricted) throws
+            XcapException {
+        mDefaultBehaviour.setPresentationRestricted(presentationRestricted);
+
+        if (isDefaultPresentationRestricted()) {
+            String defaultBehaviourXml = mDefaultBehaviour.toXmlString();
+            mDefaultBehaviour.setContent(defaultBehaviourXml);
+        } else {
+            saveConfiguration();
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/OutgoingCommunicationBarring.java b/packages/simservs/src/com/mediatek/simservs/client/OutgoingCommunicationBarring.java
new file mode 100644
index 00000000000..0781bb2cd89
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/OutgoingCommunicationBarring.java
@@ -0,0 +1,178 @@
+package com.mediatek.simservs.client;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.RuleType;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import java.util.LinkedList;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Outgoing Communication Barring class.
+ */
+public class OutgoingCommunicationBarring extends SimservType implements RuleType {
+
+    public static final String NODE_NAME = "outgoing-communication-barring";
+
+    RuleSet mRuleSet;
+
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public OutgoingCommunicationBarring(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList ruleSetNode = domDoc.getElementsByTagName("ruleset");
+        if (ruleSetNode.getLength() > 0) {
+            Log.d("OutgoingCommunicationBarring", "Got ruleset");
+            Element nruleSetElement = (Element) ruleSetNode.item(0);
+            mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId, nruleSetElement);
+            if (mNetwork != null) {
+                mRuleSet.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mRuleSet.setContext(mContext);
+            }
+
+            if (mEtag != null) {
+                mRuleSet.setEtag(mEtag);
+            }
+        } else {
+            ruleSetNode = domDoc.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "ruleset");
+            if (ruleSetNode.getLength() > 0) {
+                Log.d("OutgoingCommunicationBarring", "Got ruleset");
+                Element nruleSetElement = (Element) ruleSetNode.item(0);
+                mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                        nruleSetElement);
+                if (mNetwork != null) {
+                    mRuleSet.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mRuleSet.setContext(mContext);
+                }
+
+                if (mEtag != null) {
+                    mRuleSet.setEtag(mEtag);
+                }
+            } else {
+                ruleSetNode = domDoc.getElementsByTagName("cp:ruleset");
+                if (ruleSetNode.getLength() > 0) {
+                    Log.d("OutgoingCommunicationBarring", "Got cp:ruleset");
+                    Element nruleSetElement = (Element) ruleSetNode.item(0);
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                            nruleSetElement);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                } else {
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Get ruleset.
+     *
+     * @return ruleset
+     */
+    @Override
+    public RuleSet getRuleSet() {
+        return mRuleSet;
+    }
+
+    /**
+     * Save ruleset to configuration on server.
+     *
+     * @throws XcapException if error
+     */
+    @Override
+    public void saveRuleSet() throws XcapException {
+        String ruleXml = mRuleSet.toXmlString();
+        mRuleSet.setContent(ruleXml);
+    }
+
+    /**
+     * Save ruleset to configuration on server.
+     *
+     * @return ruleset
+     */
+    @Override
+    public RuleSet createNewRuleSet() {
+        mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+        if (mNetwork != null) {
+            mRuleSet.setNetwork(mNetwork);
+        }
+        if (mEtag != null) {
+            mRuleSet.setEtag(mEtag);
+        }
+        return mRuleSet;
+    }
+
+    /**
+     * Save rule to server.
+     *
+     * @param ruleId rule to be saved by the id
+     * @throws  XcapException if XCAP error
+     */
+    @Override
+    public void saveRule(String ruleId) throws XcapException {
+        if (ruleId != null && !ruleId.isEmpty()) {
+            LinkedList<Rule> rules =  (LinkedList<Rule>) mRuleSet.getRules();
+            for (Rule rule : rules) {
+                if (ruleId.equals(rule.mId)) {
+                    String ruleXml = rule.toXmlString();
+                    rule.setContent(ruleXml);
+                }
+            }
+        } else {
+            Log.d("saveRule", "ruleId is null");
+        }
+    }
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/SimServs.java b/packages/simservs/src/com/mediatek/simservs/client/SimServs.java
new file mode 100644
index 00000000000..44925fd31e0
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/SimServs.java
@@ -0,0 +1,904 @@
+
+package com.mediatek.simservs.client;
+
+import android.content.Context;
+import android.net.Network;
+import android.os.SystemProperties;
+import android.util.Log;
+
+import com.mediatek.simservs.capability.BarringServiceCapability;
+import com.mediatek.simservs.capability.DiversionServiceCapability;
+import com.mediatek.xcap.client.XcapDebugParam;
+import com.mediatek.xcap.client.uri.XcapUri;
+import com.mediatek.xcap.client.uri.XcapUri.XcapDocumentSelector;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * Simservs class.
+ */
+public class SimServs {
+    public static boolean sDebug = false;
+    public static final String TAG = "SimServs";
+
+    public static final int OPERATOR_DEFAULT = 0;
+    public static final int OPERATOR_OP01 = OPERATOR_DEFAULT + 1;
+    public static final int OPERATOR_OP07 = OPERATOR_DEFAULT + 2;
+
+    public static final boolean LIB_CONFIG_MULTIPLE_RULE_CONDITIONS = true;
+
+    public static final int CARDTYPE_UNSPECIFIED = 0;
+    public static final int CARDTYPE_USIM = 1;
+    public static final int CARDTYPE_ISIM = 2;
+
+    public static final String SIMSERVS_FILENAME = "simservs.xml";
+    public static final String AUID_SIMSERVS = "simservs.ngn.etsi.org";
+
+    public static SimServs sInstance = null;
+    private int mCardType = CARDTYPE_UNSPECIFIED;
+    private static String sXcapRoot = null;
+    private static String sXui = null;
+    private String mIntendedId = null;
+    private String mImsi = null;
+    private String mMnc = null;
+    private String mMcc = null;
+    private String mImpi = null;
+    private String mImpu = null;
+    private String mUsername = null;
+    private String mPassword = null;
+    public XcapDocumentSelector mDocumentSelector;
+    public URI mDocumentUri;
+    public XcapUri mXcapUri;
+    private static XcapDebugParam sXcapDebugParam;
+    private Context mContext;
+    /**
+     * Constructor.
+     *
+     */
+    public SimServs() {
+        String debugProperty = SystemProperties.get("mediatek.simserv.debug", "0");
+        if (debugProperty.equals("1")) {
+            sDebug = true;
+            Log.d(TAG, "sDebug enabled.");
+        }
+    }
+
+    /**
+     * Get SimServs instance.
+     *
+     * @return Simservs instance
+     */
+    static public SimServs getInstance() {
+        if (sInstance == null) {
+            sInstance = new SimServs();
+        }
+
+        initializeDebugParam();
+        return sInstance;
+    }
+
+    /**
+     * Get XcapDebugParam.
+     *
+     * @return XcapDebugParam
+     */
+    public XcapDebugParam getXcapDebugParam() {
+        return sXcapDebugParam;
+    }
+
+    /**
+     * Set XCAP root URL.
+     *
+     * @param xcapRoot XCAP root directory URI
+     */
+    public void setXcapRoot(String xcapRoot) {
+        sXcapRoot = xcapRoot;
+        try {
+            buildDocumentUri();
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+            sXcapRoot = null;
+        }
+    }
+
+    /**
+     * Set XCAP root URL by IMPI.
+     *
+     * @param impi IMPI
+     */
+    public void setXcapRootByImpi(String impi) {
+        mCardType = CARDTYPE_ISIM;
+        mImpi = impi;
+        try {
+            buildRootUri();
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Set XCAP root URL by PLMN.
+     *
+     * @param mcc MCC
+     * @param mnc MNC
+     */
+    public void setXcapRootByMccMnc(String mcc, String mnc) {
+        mCardType = CARDTYPE_USIM;
+        mMcc = mcc;
+        mMnc = mnc;
+        try {
+            buildRootUri();
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void setXui(String xui) {
+        sXui = xui;
+    }
+
+    /**
+     * Set XUI by IMPU.
+     *
+     * @param impu IMPU
+     */
+    public void setXuiByImpu(String impu) {
+        mCardType = CARDTYPE_ISIM;
+        mImpu = impu;
+        sXui = impu;
+    }
+
+    /**
+     * Set XUI by IMSI and PLMN.
+     *
+     * @param imsi IMSI
+     * @param mcc  MCC
+     * @param mnc  MNC
+     */
+    public void setXuiByImsiMccMnc(String imsi, String mcc, String mnc) {
+        mCardType = CARDTYPE_USIM;
+        mImsi = imsi;
+        mMcc = mcc;
+        mMnc = mnc;
+
+        sXui = String.format("sip:%s@ims.mnc%03d.mcc%03d.3gppnetwork.org", imsi,
+                             Integer.parseInt(mnc), Integer.parseInt(mcc));
+    }
+
+    public void setIntendedId(String intendedId) {
+        mIntendedId = intendedId;
+    }
+
+    public void setHttpCredential(String username, String password){
+        // TODO: remove in the future
+    }
+
+    /**
+     * Set to use HTTP protocol scheme.
+     *
+     * @param value true/false
+     */
+    public void setUseHttpProtocolScheme(boolean value) {
+        if (value) {
+            System.setProperty("xcap.protocol", "http");
+        } else {
+            System.setProperty("xcap.protocol", "https");
+        }
+    }
+
+    /**
+     * Set content-type while updating XML element.
+     *
+     * In 3GPP spec, "application/xcap-el+xml" is used.
+     * Som operator will have it's own specific content-type,
+     * ex: "application/vnd.etsi.simservs+xml"
+     *
+     * @param specdefined true to use "application/xcap-el+xml", false to use assigned type.
+     * @param type content-type
+     */
+    public void setElementUpdateContentType(boolean specdefined, String type) {
+        if (specdefined) {
+            System.setProperty("xcap.putelcontenttype", "application/xcap-el+xml");
+        } else {
+            System.setProperty("xcap.putelcontenttype", type);
+        }
+    }
+
+    /**
+     * Set to handle HTTP 409 error message content.
+     *
+     * @param value true/false
+     */
+    public void setHandleError409(boolean value) {
+        if (value) {
+            System.setProperty("xcap.handl409", "true");
+        } else {
+            System.setProperty("xcap.handl409", "false");
+        }
+    }
+
+    /**
+     * Set to fill complete ForwardTo elements according to 3GPP TS 24.604
+     *
+     * Usually only <target>, phone number,  will be used in <forward-to> element,
+     * Some operaters require to fill complete elements in <forward-to>.
+     *
+     * @param value true/false
+     */
+    public void setFillCompleteForwardTo(boolean value) {
+        if (value) {
+            System.setProperty("xcap.completeforwardto", "true");
+        } else {
+            System.setProperty("xcap.completeforwardto", "false");
+        }
+    }
+
+    /**
+     * Set to add namespace prefix "ss:".
+     * as namespace prefix for http://uri.etsi.org/ngn/params/xml/simservs/xcap
+     *
+     * @param value true/false
+     */
+    public void setXcapNSPrefixSS(boolean value) {
+        if (value) {
+            System.setProperty("xcap.ns.ss", "true");
+        } else {
+            System.setProperty("xcap.ns.ss", "false");
+        }
+    }
+
+    public String getXcapRoot() {
+        return sXcapRoot;
+    }
+
+    public String getXui() {
+        return sXui;
+    }
+
+    public String getIntendedId() {
+        return mIntendedId;
+    }
+
+    /**
+     * Set context.
+     *
+     * @param ctxt context to set
+     */
+    public void setContext(Context ctxt) {
+        mContext = ctxt;
+    }
+
+    /**
+     * Configure operator-specific requirement parameters.
+     *
+     * @param operator operator choice
+     */
+    public void setOperator(int operator) {
+        switch(operator) {
+            case OPERATOR_OP01:
+                System.setProperty("xcap.op", "01");
+                System.setProperty("xcap.protocol", "http");
+                System.setProperty("xcap.putelcontenttype", "application/vnd.etsi.simservs+xml");
+                System.setProperty("xcap.handl409", "false");
+                break;
+            case OPERATOR_OP07:
+                System.setProperty("xcap.op", "07");
+                System.setProperty("xcap.protocol", "https");
+                System.setProperty("xcap.putelcontenttype", "application/xcap-el+xml");
+                System.setProperty("xcap.handl409", "true");
+                break;
+            case OPERATOR_DEFAULT:
+            default:
+                System.setProperty("xcap.op", "00");
+                System.setProperty("xcap.protocol", "https");
+                System.setProperty("xcap.putelcontenttype", "application/xcap-el+xml");
+                System.setProperty("xcap.handl409", "false");
+                break;
+        }
+    }
+
+    /**
+     * Initialization debug utility.
+     */
+    static private void initializeDebugParam() {
+        sXcapDebugParam = XcapDebugParam.getInstance();
+        sXcapDebugParam.load();
+        sXcapRoot = null;
+        sXui = null;
+
+        String xcapRoot = sXcapDebugParam.getXcapRoot();
+        //systemproperty ex: http://xcap.ims.msg.t-mobile.com:8090/
+
+        if (xcapRoot != null && !xcapRoot.isEmpty()) {
+            sXcapRoot = xcapRoot;
+        }
+
+        String xui = sXcapDebugParam.getXcapXui();
+
+        if (xui != null && !xui.isEmpty()) {
+            sXui = xui;
+        }
+    }
+
+    /**
+     * Get domain from IMPI.
+     */
+    private String getImpiDomain() {
+        if (mImpi != null && !mImpi.isEmpty() && mImpi.contains("@")) {
+            String[] temp;
+            String delimiter = "@";
+            temp = mImpi.split(delimiter);
+            return temp[1];
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Build the XCAP root URI according to TS 23.003 13.9.
+     *
+     * @throws URISyntaxException
+     */
+    private void buildRootUri() throws URISyntaxException {
+        StringBuilder xcapRoot = new StringBuilder();
+        Log.d("Simservs", "xcap.protocol=" + System.getProperty("xcap.protocol"));
+
+        String protocol = System.getProperty("xcap.protocol", "https");
+
+        if (mCardType == CARDTYPE_USIM) {
+            xcapRoot.append(protocol + "://xcap.ims.mnc")
+                .append(mMnc)
+                .append(".mcc")
+                .append(mMcc)
+                .append(".pub.3gppnetwork.org");
+        } else if (mCardType == CARDTYPE_ISIM) {
+            if (mImpi != null && mImpi.endsWith("3gppnetwork.org")) {
+                String domain = getImpiDomain();
+                xcapRoot.append(protocol + "://xcap.");
+                xcapRoot.append(domain.substring(0, domain.indexOf(".3gppnetwork.org")));
+                if (mImpi.contains(".pub")) {
+                    xcapRoot.append(".3gppnetwork.org");
+                } else {
+                    xcapRoot.append(".pub.3gppnetwork.org");
+                }
+            } else {
+                String domain = getImpiDomain();
+                if (domain == null) {
+                    return;
+                }
+                xcapRoot.append(protocol + "://xcap.")
+                        .append(domain);
+            }
+        } else {
+            return;
+        }
+
+        xcapRoot.append("/");
+        sXcapRoot = xcapRoot.toString();
+        buildDocumentUri();
+    }
+
+    /**
+     * Build document URI.
+     *
+     * @throws URISyntaxException if URI syntax error
+     */
+    public void buildDocumentUri() throws URISyntaxException {
+        String xcapDocumentName = sXcapDebugParam.getXcapDocumentName();
+        mDocumentSelector = new XcapDocumentSelector(
+                AUID_SIMSERVS, sXui, (xcapDocumentName != null && !xcapDocumentName.isEmpty()) ?
+                xcapDocumentName : SIMSERVS_FILENAME);
+        Log.d(TAG, "document selector is " + mDocumentSelector.toString());
+        //[Fix bug by mtk01411 2013-1003]mXcapUri is member of class SimServs
+        //XcapUri mXcapUri = new XcapUri(); //Only new instance for local variable mXcapUri
+        //instead of class member mXcapUri
+        mXcapUri = new XcapUri();
+        Log.d(TAG, "buildDocumentUri():Create instance for mXcapUri");
+        mXcapUri.setXcapRoot(sXcapRoot).setDocumentSelector(mDocumentSelector);
+
+        mDocumentUri = mXcapUri.toURI();
+    }
+
+    public String getDocumentUri() {
+        return mDocumentUri.toString();
+    }
+
+    /**
+     * Get a CommunicationWaiting instance.
+     *
+     * @param  syncInstance not use
+     * @return CommunicationWaiting instance
+     * @throws Exception if error
+     */
+    public CommunicationWaiting getCommunicationWaiting(boolean syncInstance) throws Exception {
+        CommunicationWaiting cw = new CommunicationWaiting(mXcapUri, null, mIntendedId);
+        if (mContext != null) {
+            cw.setContext(mContext);
+        }
+
+        cw.loadConfiguration();
+        return cw;
+    }
+
+    /**
+     * Get a CommunicationWaiting instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return CommunicationWaiting instance
+     * @throws Exception if error
+     */
+    public CommunicationWaiting getCommunicationWaiting(boolean syncInstance, Network network)
+            throws Exception {
+        CommunicationWaiting cw = new CommunicationWaiting(mXcapUri, null, mIntendedId);
+        if (network != null) {
+            cw.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            cw.setContext(mContext);
+        }
+
+        cw.loadConfiguration();
+        return cw;
+    }
+
+    /**
+     * Get a CommunicationWaiting instance.
+     * For test purpose.
+     *
+     * @param documentUri       XCAP document URI
+     * @return CommunicationWaiting instance
+     * @throws Exception if error
+     */
+    public CommunicationWaiting getCommunicationWaiting(XcapUri documentUri) throws Exception {
+        return new CommunicationWaiting(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentation instance.
+     *
+     * @param  syncInstance not use
+     * @return OriginatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentation getOriginatingIdentityPresentation(boolean syncInstance)
+            throws Exception {
+        OriginatingIdentityPresentation oip = new OriginatingIdentityPresentation(mXcapUri, null,
+                mIntendedId);
+        if (mContext != null) {
+            oip.setContext(mContext);
+        }
+
+        oip.loadConfiguration();
+        return oip;
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentation instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return OriginatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentation getOriginatingIdentityPresentation(boolean syncInstance,
+            Network network) throws Exception {
+        OriginatingIdentityPresentation oip = new OriginatingIdentityPresentation(mXcapUri, null,
+                mIntendedId);
+        if (network != null) {
+            oip.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            oip.setContext(mContext);
+        }
+
+        oip.loadConfiguration();
+        return oip;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentation instance.
+     *
+     * @param  syncInstance not use
+     * @return TerminatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentation getTerminatingIdentityPresentation(boolean syncInstance)
+            throws Exception {
+        TerminatingIdentityPresentation tip = new TerminatingIdentityPresentation(mXcapUri, null,
+                mIntendedId);
+
+        if (mContext != null) {
+            tip.setContext(mContext);
+        }
+
+        tip.loadConfiguration();
+        return tip;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentation instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return TerminatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentation getTerminatingIdentityPresentation(boolean syncInstance,
+            Network network) throws Exception {
+        TerminatingIdentityPresentation tip = new TerminatingIdentityPresentation(mXcapUri, null,
+                mIntendedId);
+        if (network != null) {
+            tip.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            tip.setContext(mContext);
+        }
+
+        tip.loadConfiguration();
+        return tip;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentation instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     *
+     * @return OriginatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentation getOriginatingIdentityPresentation(
+            XcapUri documentUri) throws Exception {
+        return new OriginatingIdentityPresentation(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentation instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return TerminatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentation getTerminatingIdentityPresentation(
+            XcapUri documentUri) throws Exception {
+        return new TerminatingIdentityPresentation(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentationRestriction instance.
+     *
+     * @param  syncInstance not use
+     * @return OriginatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentationRestriction getOriginatingIdentityPresentationRestriction(
+            boolean syncInstance) throws Exception {
+        OriginatingIdentityPresentationRestriction oip =
+                new OriginatingIdentityPresentationRestriction(mXcapUri, null, mIntendedId);
+        if (mContext != null) {
+            oip.setContext(mContext);
+        }
+
+        oip.loadConfiguration();
+        return oip;
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentationRestriction instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return OriginatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentationRestriction getOriginatingIdentityPresentationRestriction(
+            boolean syncInstance, Network network) throws Exception {
+        OriginatingIdentityPresentationRestriction oipr =
+                new OriginatingIdentityPresentationRestriction(mXcapUri, null, mIntendedId);
+        if (network != null) {
+            oipr.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            oipr.setContext(mContext);
+        }
+
+        oipr.loadConfiguration();
+        return oipr;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentationRestriction instance.
+     *
+     * @param  syncInstance not use
+     * @return TerminatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentationRestriction getTerminatingIdentityPresentationRestriction(
+            boolean syncInstance) throws Exception {
+        TerminatingIdentityPresentationRestriction tipr =
+                new TerminatingIdentityPresentationRestriction(mXcapUri, null, mIntendedId);
+
+        if (mContext != null) {
+            tipr.setContext(mContext);
+        }
+
+        tipr.loadConfiguration();
+        return tipr;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentationRestriction instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return TerminatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentationRestriction getTerminatingIdentityPresentationRestriction(
+            boolean syncInstance, Network network) throws Exception {
+        TerminatingIdentityPresentationRestriction tipr =
+                new TerminatingIdentityPresentationRestriction(mXcapUri, null, mIntendedId);
+        if (network != null) {
+            tipr.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            tipr.setContext(mContext);
+        }
+
+        tipr.loadConfiguration();
+        return tipr;
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentationRestriction instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return OriginatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentationRestriction getOriginatingIdentityPresentationRestriction(
+            XcapUri documentUri) throws Exception {
+        return new OriginatingIdentityPresentationRestriction(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentationRestriction instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return TerminatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentationRestriction getTerminatingIdentityPresentationRestriction(
+            XcapUri documentUri) throws Exception {
+        return new TerminatingIdentityPresentationRestriction(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a CommunicationDiversion instance.
+     *
+     * @param syncInstance not use
+     * @return CommunicationDiversion instance
+     * @throws Exception if error
+     */
+    public CommunicationDiversion getCommunicationDiversion(boolean syncInstance) throws
+            Exception {
+        CommunicationDiversion cd = new CommunicationDiversion(mXcapUri, null, mIntendedId);
+
+        if (mContext != null) {
+            cd.setContext(mContext);
+        }
+
+        cd.loadConfiguration();
+        return cd;
+    }
+
+    /**
+     * Get a CommunicationDiversion instance with specific network.
+     *
+     * @param syncInstance not use
+     * @param network dedicated network
+     * @return CommunicationDiversion instance
+     * @throws Exception if error
+     */
+    public CommunicationDiversion getCommunicationDiversion(boolean syncInstance,
+            Network network) throws Exception {
+        CommunicationDiversion cd = new CommunicationDiversion(mXcapUri, null, mIntendedId);
+        if (network != null) {
+            cd.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            cd.setContext(mContext);
+        }
+        cd.loadConfiguration();
+        return cd;
+    }
+
+    /**
+     * Get a CommunicationDiversion instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return CommunicationDiversion instance
+     * @throws Exception if error
+     */
+    public CommunicationDiversion getCommunicationDiversion(
+            XcapUri documentUri) throws Exception {
+        return new CommunicationDiversion(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a IncomingCommunicationBarring instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return IncomingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public IncomingCommunicationBarring getIncomingCommunicationBarring(
+            XcapUri documentUri) throws Exception {
+        return new IncomingCommunicationBarring(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a IncomingCommunicationBarring instance.
+     *
+     * @param syncInstance not use
+     * @return IncomingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public IncomingCommunicationBarring getIncomingCommunicationBarring(boolean syncInstance) throws
+            Exception {
+        IncomingCommunicationBarring icb = new IncomingCommunicationBarring(mXcapUri, null,
+                mIntendedId);
+
+        if (mContext != null) {
+            icb.setContext(mContext);
+        }
+
+        icb.loadConfiguration();
+        return icb;
+    }
+
+    /**
+     * Get a IncomingCommunicationBarring instance.
+     *
+     * @param syncInstance not use
+     * @param network dedicated network
+     * @return IncomingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public IncomingCommunicationBarring getIncomingCommunicationBarring(
+            boolean syncInstance, Network network) throws Exception {
+        IncomingCommunicationBarring icb = new IncomingCommunicationBarring(mXcapUri, null,
+                mIntendedId);
+        if (network != null) {
+            icb.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            icb.setContext(mContext);
+        }
+
+        icb.loadConfiguration();
+        return icb;
+    }
+
+    /**
+     * Get a OutgoingCommunicationBarring instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return OutgoingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public OutgoingCommunicationBarring getOutgoingCommunicationBarring(
+            XcapUri documentUri) throws Exception {
+        return new OutgoingCommunicationBarring(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a OutgoingCommunicationBarring instance.
+     *
+     * @param syncInstance not use
+     * @return OutgoingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public OutgoingCommunicationBarring getOutgoingCommunicationBarring(boolean syncInstance) throws
+            Exception {
+        OutgoingCommunicationBarring ocb = new OutgoingCommunicationBarring(mXcapUri, null,
+                mIntendedId);
+
+        if (mContext != null) {
+            ocb.setContext(mContext);
+        }
+
+        ocb.loadConfiguration();
+        return ocb;
+    }
+
+    /**
+     * Get a OutgoingCommunicationBarring instance.
+     *
+     * @param syncInstance not use
+     * @param network dedicated network
+     * @return OutgoingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public OutgoingCommunicationBarring getOutgoingCommunicationBarring(
+            boolean syncInstance, Network network) throws Exception {
+        OutgoingCommunicationBarring ocb = new OutgoingCommunicationBarring(mXcapUri, null,
+                mIntendedId);
+        if (network != null) {
+            ocb.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            ocb.setContext(mContext);
+        }
+
+        ocb.loadConfiguration();
+        return ocb;
+    }
+
+    /**
+     * Get a DiversionServiceCapability instance.
+     *
+     * @param syncInstance not use
+     * @return DiversionServiceCapability instance
+     * @throws Exception if error
+     */
+    public DiversionServiceCapability getDiversionServiceCapability(boolean syncInstance) throws
+            Exception {
+        return new DiversionServiceCapability(mXcapUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a DiversionServiceCapability instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return DiversionServiceCapability instance
+     * @throws Exception if error
+     */
+    public DiversionServiceCapability getDiversionServiceCapability(
+            XcapUri documentUri) throws Exception {
+        return new DiversionServiceCapability(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a DiversionServiceCapability instance.
+     *
+     * @param syncInstance not use
+     * @return BarringServiceCapability instance
+     * @throws Exception if error
+     */
+    public BarringServiceCapability getBarringServiceCapability(boolean syncInstance) throws
+            Exception {
+        return new BarringServiceCapability(mXcapUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a BarringServiceCapability instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return BarringServiceCapability instance
+     * @throws Exception if error
+     */
+    public BarringServiceCapability getBarringServiceCapability(
+            XcapUri documentUri) throws Exception {
+        return new BarringServiceCapability(documentUri, null, mIntendedId);
+    }
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/SimservType.java b/packages/simservs/src/com/mediatek/simservs/client/SimservType.java
new file mode 100644
index 00000000000..2f86dcafcda
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/SimservType.java
@@ -0,0 +1,212 @@
+package com.mediatek.simservs.client;
+
+import android.util.Log;
+
+import com.mediatek.simservs.xcap.InquireType;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.XcapDebugParam;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+import java.io.StringReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * SimservType (SS type) abstract class.
+ */
+public abstract class SimservType extends InquireType {
+    //[MMTelSS] Add by mtk01411 for testing/debuging
+    public static final String TAG = "SimservType";
+    static final String ATT_ACTIVE = "active";
+
+    public boolean mActived = false;
+    String mSsTc;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public SimservType(XcapUri xcapUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(xcapUri, parentUri, intendedId);
+        Log.d(TAG, "Xcap debug params: \n" + mDebugParams.toString());
+    }
+
+    /**
+     * Sync latest version with NAF server.
+     *
+     * @throws Exception if error
+     */
+    public void refresh() throws Exception {
+        this.loadConfiguration();
+    }
+
+    /**
+     * Is E-Tag supported.
+     *
+     * @return true/false
+     */
+    public boolean isSupportEtag() {
+        return mIsSupportEtag;
+    }
+
+    /**
+     * Retrieve configuration.
+     *
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    //[Revise this API for UT by mtk01411]
+    protected void loadConfiguration() throws XcapException,
+            ParserConfigurationException {
+        String xmlContent = "";
+        String nodeName = getNodeName();
+        Log.d(TAG, "loadConfiguration():nodeName=" + nodeName);
+
+        if (XcapDebugParam.getInstance().getEnablePredefinedSimservQueryResult()) {
+            //Use different XML strings for UT purpose
+            xmlContent = readXmlFromFile("/data/ss.xml");
+
+            //Compare if the nodeName is same with tested xml node name
+            if (xmlContent.contains(nodeName) == false) {
+                //Can't query anything - not same query target
+                Log.d(TAG, "loadConfiguration():fail to get tested xml for nodeName=" + nodeName);
+                return;
+            } else {
+                Log.d(TAG, "loadConfiguration():get tested xml for nodeName=" + nodeName);
+            }
+
+        } else {
+            //Get string from remote XCAP server
+            xmlContent = getContent();
+        }
+        if (SimServs.sDebug) {
+            Log.v(TAG, "xmlContent=" + xmlContent);
+        }
+
+        if (xmlContent != null) {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            factory.setNamespaceAware(true);
+            DocumentBuilder db = factory.newDocumentBuilder();
+            InputSource is = new InputSource();
+            is.setCharacterStream(new StringReader(xmlContent));
+            Document doc;
+            try {
+                doc = db.parse(is);
+            } catch (SAXException e) {
+                factory.setNamespaceAware(false);
+                db = factory.newDocumentBuilder();
+                is = new InputSource();
+                is.setCharacterStream(new StringReader(xmlContent));
+                try {
+                    doc = db.parse(is);
+                } catch (SAXException err) {
+                    err.printStackTrace();
+                    // Throws a server error
+                    throw new XcapException(500);
+                } catch (IOException err) {
+                    err.printStackTrace();
+                    // Throws a server error
+                    throw new XcapException(500);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+                // Throws a server error
+                throw new XcapException(500);
+            }
+            NodeList currentNode = doc.getElementsByTagName(getNodeName());
+            if (SimServs.sDebug) {
+                Log.v(TAG, "getNodeName()=" + getNodeName());
+            }
+
+            if (currentNode.getLength() > 0) {
+                Element activeElement = (Element) currentNode.item(0);
+                NamedNodeMap map = activeElement.getAttributes();
+                if (map.getLength() > 0) {
+                    for (int i = 0; i < map.getLength(); i++) {
+                        Node node = map.item(i);
+                        if (node.getNodeName().equals(ATT_ACTIVE)) {
+                            mActived = node.getNodeValue().endsWith(TRUE);
+                            break;
+                        }
+                    }
+                }
+            } else {
+                currentNode = doc.getElementsByTagNameNS(XCAP_NAMESPACE, getNodeName());
+                if (currentNode.getLength() > 0) {
+                    Element activeElement = (Element) currentNode.item(0);
+                    NamedNodeMap map = activeElement.getAttributes();
+                    if (map.getLength() > 0) {
+                        for (int i = 0; i < map.getLength(); i++) {
+                            Node node = map.item(i);
+                            if (node.getNodeName().equals(ATT_ACTIVE)) {
+                                mActived = node.getNodeValue().endsWith(TRUE);
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (SimServs.sDebug) {
+                Log.v(TAG, "xmldoc=" + doc.toString());
+            }
+
+            initServiceInstance(doc);
+        }
+    }
+
+    public boolean isActive() {
+        return mActived;
+    }
+
+    /**
+     * Set active value.
+     *
+     * @param active            active value
+     * @throws XcapException    if XCAP error
+     */
+    public void setActive(boolean active) throws XcapException {
+        mActived = active;
+        String xml = null;
+        String useXcapNs = System.getProperty("xcap.ns.ss", "false");
+
+        if ("true".equals(useXcapNs)) {
+            if (mActived) {
+                xml = "<ss:" + this.getNodeName() + " active=\"true\"/>";
+            } else {
+                xml = "<ss:" + this.getNodeName() + " active=\"false\"/>";
+            }
+            this.setContent(xml);
+        } else {
+            if (mActived) {
+                setByAttrName(ATT_ACTIVE, TRUE);
+            } else {
+                setByAttrName(ATT_ACTIVE, FALSE);
+            }
+        }
+    }
+
+    /**
+     * Instantiate from XML text.
+     *
+     * @param domDoc XML document
+     */
+    public abstract void initServiceInstance(Document domDoc);
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentation.java b/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentation.java
new file mode 100644
index 00000000000..1d0652b16e1
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentation.java
@@ -0,0 +1,41 @@
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Spheret class.
+ */
+public class TerminatingIdentityPresentation extends SimservType {
+
+    public static final String NODE_NAME = "terminating-identity-presentation";
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public TerminatingIdentityPresentation(XcapUri documentUri, String parentUri,
+            String intendedId) throws XcapException,
+            ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        // No content need to be parsed for this service
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentationRestriction.java b/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentationRestriction.java
new file mode 100644
index 00000000000..e4b11382d25
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentationRestriction.java
@@ -0,0 +1,129 @@
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+
+/**
+ * Terminating Identity Presentation Restriction class.
+ */
+public class TerminatingIdentityPresentationRestriction extends SimservType {
+
+    public static final String NODE_NAME = "terminating-identity-presentation-restriction";
+    public DefaultBehaviour mDefaultBehaviour;
+    public boolean mContainDefaultBehaviour = false;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param xui           X-3GPP-Intended-Id
+     * @throws Exception    if error
+     */
+    public TerminatingIdentityPresentationRestriction(XcapUri documentUri, String parentUri,
+            String xui) throws Exception {
+        super(documentUri, parentUri, xui);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList defaultBehaviour = domDoc.getElementsByTagName(DefaultBehaviour.NODE_NAME);
+        if (defaultBehaviour.getLength() > 0) {
+            mContainDefaultBehaviour = true;
+            Element defaultBehaviourElement = (Element) defaultBehaviour.item(0);
+            mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId,
+                    defaultBehaviourElement);
+        } else {
+            defaultBehaviour = domDoc.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    DefaultBehaviour.NODE_NAME);
+            if (defaultBehaviour.getLength() > 0) {
+                mContainDefaultBehaviour = true;
+                Element defaultBehaviourElement = (Element) defaultBehaviour.item(0);
+                mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId,
+                        defaultBehaviourElement);
+            } else {
+                mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId);
+            }
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Save configuration on server.
+     *
+     * @throws XcapException    if XCAP error
+     */
+    public void saveConfiguration() throws XcapException {
+        String serviceXml = toXmlString();
+        setContent(serviceXml);
+        mContainDefaultBehaviour = true;
+    }
+
+    /**
+     * Convert to XML string.
+     *
+     * @return XML string
+     */
+    public String toXmlString() {
+        Element root = null;
+        String xmlString = null;
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document document = builder.newDocument();
+            root = (Element) document.createElement(NODE_NAME);
+            document.appendChild(root);
+            Element defaultElement = mDefaultBehaviour.toXmlElement(document);
+            root.appendChild(defaultElement);
+            xmlString = domToXmlText(root);
+        } catch (ParserConfigurationException pce) {
+            // Parser with specified options can't be built
+            pce.printStackTrace();
+        } catch (TransformerConfigurationException e) {
+            e.printStackTrace();
+        } catch (TransformerException e) {
+            e.printStackTrace();
+        }
+        return xmlString;
+    }
+
+    public boolean isContainDefaultBehaviour() {
+        return mContainDefaultBehaviour;
+    }
+
+    public boolean isDefaultPresentationRestricted() {
+        return mDefaultBehaviour.isPresentationRestricted();
+    }
+
+    /**
+     * set Default Presentation Restricted value.
+     *
+     * @param presentationRestricted retriction value
+     * @throws XcapException if XCAP error
+     */
+    public void setDefaultPresentationRestricted(boolean presentationRestricted) throws
+            XcapException {
+        mDefaultBehaviour.setPresentationRestricted(presentationRestricted);
+
+        if (isDefaultPresentationRestricted()) {
+            String defaultBehaviourXml = mDefaultBehaviour.toXmlString();
+            mDefaultBehaviour.setContent(defaultBehaviourXml);
+        } else {
+            saveConfiguration();
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Actions.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Actions.java
new file mode 100644
index 00000000000..420e838a677
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Actions.java
@@ -0,0 +1,155 @@
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * Actions class.
+ *
+ */
+public class Actions extends XcapElement implements ConfigureType {
+
+    public static final String NODE_NAME = "cp:actions";
+
+    static final String TAG_ALLOW = "allow";
+    static final String TAG_FORWARD_TO = "forward-to";
+
+    public boolean mAllow;
+    public ForwardTo mForwardTo;
+
+    /**
+     * Constructor without XML element.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Actions(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor with XML element.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM XML element
+     */
+    public Actions(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        NodeList actionNode = domElement.getElementsByTagName(TAG_ALLOW);
+        if (actionNode.getLength() > 0) {
+            Element allowElement = (Element) actionNode.item(0);
+            String allowed = allowElement.getTextContent();
+            mAllow = allowed.equals("true");
+        } else {
+            actionNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_ALLOW);
+            if (actionNode.getLength() > 0) {
+                Element allowElement = (Element) actionNode.item(0);
+                String allowed = allowElement.getTextContent();
+                mAllow = allowed.equals("true");
+            } else {
+                actionNode = domElement.getElementsByTagName(XCAP_ALIAS + ":" + TAG_ALLOW);
+                if (actionNode.getLength() > 0) {
+                    Element allowElement = (Element) actionNode.item(0);
+                    String allowed = allowElement.getTextContent();
+                    mAllow = allowed.equals("true");
+                }
+            }
+        }
+
+        actionNode = domElement.getElementsByTagName(TAG_FORWARD_TO);
+        if (actionNode.getLength() > 0) {
+            mForwardTo = new ForwardTo(mXcapUri, NODE_NAME, mIntendedId,
+                    domElement);
+        } else {
+            actionNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_FORWARD_TO);
+            if (actionNode.getLength() > 0) {
+                mForwardTo = new ForwardTo(mXcapUri, NODE_NAME, mIntendedId,
+                        domElement);
+            } else {
+                actionNode = domElement.getElementsByTagName(XCAP_ALIAS + ":" + TAG_FORWARD_TO);
+                if (actionNode.getLength() > 0) {
+                    mForwardTo = new ForwardTo(mXcapUri, NODE_NAME, mIntendedId,
+                            domElement);
+                } else {
+                    mForwardTo = new ForwardTo(mXcapUri, NODE_NAME, mIntendedId);
+                }
+            }
+        }
+    }
+
+    /**
+     * Convert to XML element.
+     *
+     * @param document  dom document
+     * @return XML format element
+     */
+    public Element toXmlElement(Document document) {
+        Element actionsElement = (Element) document.createElement(NODE_NAME);
+
+        if (mForwardTo != null) {
+            Element forwardToElement = mForwardTo.toXmlElement(document);
+            actionsElement.appendChild(forwardToElement);
+        } else {
+            String useXcapNs = System.getProperty("xcap.ns.ss", "false");
+
+            if ("true".equals(useXcapNs)) {
+                Element allowElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_ALLOW);
+                allowElement.setTextContent(mAllow ? "true" : "false");
+                actionsElement.appendChild(allowElement);
+            } else {
+                Element allowElement = (Element) document.createElement(TAG_ALLOW);
+                allowElement.setTextContent(mAllow ? "true" : "false");
+                actionsElement.appendChild(allowElement);
+            }
+        }
+        return actionsElement;
+    }
+
+    public void setAllow(boolean allow) {
+        mAllow = allow;
+    }
+
+    public boolean isAllow() {
+        return mAllow;
+    }
+
+    /**
+     * Set ForwardTo value.
+     *
+     * @param target        forward number
+     * @param notifyCaller  whether to notify caller
+     */
+    public void setFowardTo(String target, boolean notifyCaller) {
+        if (mForwardTo == null) {
+            mForwardTo = new ForwardTo(mXcapUri, mParentUri, mIntendedId);
+        }
+        mForwardTo.setTarget(target);
+        mForwardTo.setNotifyCaller(notifyCaller);
+    }
+
+    public ForwardTo getFowardTo() {
+        return mForwardTo;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Conditions.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Conditions.java
new file mode 100644
index 00000000000..242bb27819f
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Conditions.java
@@ -0,0 +1,733 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Condition class.
+ *
+ */
+public class Conditions extends XcapElement implements ConfigureType {
+    public static final String NODE_NAME = "cp:conditions";
+
+    static final String TAG_BUSY = "busy";
+    static final String TAG_NO_ANSWER = "no-answer";
+    static final String TAG_NOT_REACHABLE = "not-reachable";
+    static final String TAG_NOT_REGISTERED = "not-registered";
+    static final String TAG_ROAMING = "roaming";
+    static final String TAG_RULE_DEACTIVATED = "rule-deactivated";
+    static final String TAG_INTERNATIONAL = "international";
+    static final String TAG_INTERNATIONAL_EXHC = "international-exHC";
+    static final String TAG_COMMUNICATION_DIVERTED = "communication-diverted";
+    static final String TAG_PRESENCE_STATUS = "presence-status";
+    static final String TAG_MEDIA = "media";
+    static final String TAG_ANONYMOUS = "anonymous";
+    static final String TAG_TIME = "time";
+
+    public boolean mComprehendBusy = false;
+    public boolean mComprehendNoAnswer = false;
+    public boolean mComprehendNotReachable = false;
+    public boolean mComprehendNotRegistered = false;
+    public boolean mComprehendRoaming = false;
+    public boolean mComprehendRuleDeactivated = false;
+    public boolean mComprehendInternational = false;
+    public boolean mComprehendInternationalexHc = false;
+    public boolean mComprehendCommunicationDiverted = false;
+    public boolean mComprehendPresenceStatus = false;
+    public boolean mComprehendAnonymous = false;
+    public String  mComprehendTime;
+
+    public List<String> mMedias;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Conditions(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructor with XML element.
+     *
+     * @param xcapUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM element
+     */
+    public Conditions(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        String conditionsPrefix = XCAP_ALIAS + ":";
+        // TODO Auto-generated method stub
+        NodeList conditionsNode = domElement.getElementsByTagName(TAG_BUSY);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendBusy = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_BUSY);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendBusy = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_BUSY);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendBusy = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_NO_ANSWER);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendNoAnswer = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_NO_ANSWER);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendNoAnswer = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_NO_ANSWER);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendNoAnswer = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_NOT_REACHABLE);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendNotReachable = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_NOT_REACHABLE);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendNotReachable = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_NOT_REACHABLE);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendNotReachable = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_NOT_REGISTERED);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendNotRegistered = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_NOT_REGISTERED);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendNotRegistered = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_NOT_REGISTERED);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendNotRegistered = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_ROAMING);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendRoaming = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_ROAMING);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendRoaming = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_ROAMING);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendRoaming = true;
+                }
+            }
+        }
+
+
+        conditionsNode = domElement.getElementsByTagName(TAG_RULE_DEACTIVATED);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendRuleDeactivated = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_RULE_DEACTIVATED);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendRuleDeactivated = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_RULE_DEACTIVATED);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendRuleDeactivated = true;
+                }
+            }
+        }
+
+
+        conditionsNode = domElement.getElementsByTagName(TAG_INTERNATIONAL);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendInternational = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_INTERNATIONAL);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendInternational = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_INTERNATIONAL);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendInternational = true;
+                }
+            }
+        }
+
+
+        conditionsNode = domElement.getElementsByTagName(TAG_INTERNATIONAL_EXHC);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendInternationalexHc = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_INTERNATIONAL_EXHC);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendInternationalexHc = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_INTERNATIONAL_EXHC);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendInternationalexHc = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_COMMUNICATION_DIVERTED);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendCommunicationDiverted = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_COMMUNICATION_DIVERTED);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendCommunicationDiverted = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_COMMUNICATION_DIVERTED);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendCommunicationDiverted = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_PRESENCE_STATUS);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendPresenceStatus = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_PRESENCE_STATUS);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendPresenceStatus = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_PRESENCE_STATUS);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendPresenceStatus = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_MEDIA);
+        mMedias = new LinkedList<String>();
+        if (conditionsNode.getLength() > 0) {
+            for (int i = 0; i < conditionsNode.getLength(); i++) {
+                Element mediaElement = (Element) conditionsNode.item(i);
+                mMedias.add(mediaElement.getTextContent());
+            }
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_MEDIA);
+            if (conditionsNode.getLength() > 0) {
+                for (int i = 0; i < conditionsNode.getLength(); i++) {
+                    Element mediaElement = (Element) conditionsNode.item(i);
+                    mMedias.add(mediaElement.getTextContent());
+                }
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_MEDIA);
+                if (conditionsNode.getLength() > 0) {
+                    for (int i = 0; i < conditionsNode.getLength(); i++) {
+                        Element mediaElement = (Element) conditionsNode.item(i);
+                        mMedias.add(mediaElement.getTextContent());
+                    }
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_ANONYMOUS);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendAnonymous = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_ANONYMOUS);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendAnonymous = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_ANONYMOUS);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendAnonymous = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_TIME);
+        if (conditionsNode.getLength() > 0) {
+            Element timeElement = (Element) conditionsNode.item(0);
+            mComprehendTime = timeElement.getTextContent();
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_TIME);
+            if (conditionsNode.getLength() > 0) {
+                Element timeElement = (Element) conditionsNode.item(0);
+                mComprehendTime = timeElement.getTextContent();
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_TIME);
+                if (conditionsNode.getLength() > 0) {
+                    Element timeElement = (Element) conditionsNode.item(0);
+                    mComprehendTime = timeElement.getTextContent();
+                }
+            }
+        }
+
+    }
+
+    /**
+     * Convert to XML.
+     *
+     * @param   document DOM document
+     * @return  XML element
+     */
+    public Element toXmlElement(Document document) {
+        String useXcapNs = System.getProperty("xcap.ns.ss", "false");
+
+        if ("true".equals(useXcapNs)) {
+            Element conditionsElement = (Element) document.createElement(NODE_NAME);
+
+            if (comprehendBusy()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_BUSY);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNoAnswer()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NO_ANSWER);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNotReachable()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOT_REACHABLE);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNotRegistered()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOT_REGISTERED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendRoaming()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_ROAMING);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendRuleDeactivated()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_RULE_DEACTIVATED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendInternational()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_INTERNATIONAL);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendInternationalExHc()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_INTERNATIONAL_EXHC);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendCommunicationDiverted()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_COMMUNICATION_DIVERTED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendPresenceStatus()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_PRESENCE_STATUS);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (mMedias != null) {
+                if (mMedias.size() > 0) {
+                    Iterator<String> it = mMedias.iterator();
+                    while (it.hasNext()) {
+                        Element ruleElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                                "ss:" + TAG_MEDIA);
+                        ruleElement.setTextContent(it.next());
+                        conditionsElement.appendChild(ruleElement);
+                    }
+                }
+            }
+
+            if (comprehendAnonymous()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_ANONYMOUS);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendTime() != null && !comprehendTime().isEmpty()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_TIME);
+                conditionElement.setTextContent(mComprehendTime);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            return conditionsElement;
+        } else {
+            Element conditionsElement = (Element) document.createElement(NODE_NAME);
+
+            if (comprehendBusy()) {
+                Element conditionElement = (Element) document.createElement(TAG_BUSY);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNoAnswer()) {
+                Element conditionElement = (Element) document.createElement(TAG_NO_ANSWER);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNotReachable()) {
+                Element conditionElement = (Element) document.createElement(TAG_NOT_REACHABLE);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNotRegistered()) {
+                Element conditionElement = (Element) document.createElement(TAG_NOT_REGISTERED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendRoaming()) {
+                Element conditionElement = (Element) document.createElement(TAG_ROAMING);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendRuleDeactivated()) {
+                Element conditionElement = (Element) document.createElement(TAG_RULE_DEACTIVATED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendInternational()) {
+                Element conditionElement = (Element) document.createElement(TAG_INTERNATIONAL);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendInternationalExHc()) {
+                Element conditionElement = (Element) document.createElement(TAG_INTERNATIONAL_EXHC);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendCommunicationDiverted()) {
+                Element conditionElement =
+                        (Element) document.createElement(TAG_COMMUNICATION_DIVERTED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendPresenceStatus()) {
+                Element conditionElement = (Element) document.createElement(TAG_PRESENCE_STATUS);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (mMedias != null) {
+                if (mMedias.size() > 0) {
+                    Iterator<String> it = mMedias.iterator();
+                    while (it.hasNext()) {
+                        Element ruleElement = (Element) document.createElement(TAG_MEDIA);
+                        ruleElement.setTextContent(it.next());
+                        conditionsElement.appendChild(ruleElement);
+                    }
+                }
+            }
+
+            if (comprehendAnonymous()) {
+                Element conditionElement = (Element) document.createElement(TAG_ANONYMOUS);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendTime() != null && !comprehendTime().isEmpty()) {
+                Element conditionElement = (Element) document.createElement(TAG_TIME);
+                conditionElement.setTextContent(mComprehendTime);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            return conditionsElement;
+        }
+    }
+
+    /**
+     * Turn on Busy.
+     *
+     */
+    public void addBusy() {
+        mComprehendBusy = true;
+    }
+
+    /**
+     * Turn on NoAnswer.
+     *
+     */
+    public void addNoAnswer() {
+        mComprehendNoAnswer = true;
+    }
+
+    /**
+     * Turn on NotReachable.
+     *
+     */
+    public void addNotReachable() {
+        mComprehendNotReachable = true;
+    }
+
+    /**
+     * Turn on NotRegistered.
+     *
+     */
+    public void addNotRegistered() {
+        mComprehendNotRegistered = true;
+    }
+
+    /**
+     * Turn on Roaming.
+     *
+     */
+    public void addRoaming() {
+        mComprehendRoaming = true;
+    }
+
+    /**
+     * Turn on RuleDeactivated.
+     *
+     */
+    public void addRuleDeactivated() {
+        mComprehendRuleDeactivated = true;
+    }
+
+    /**
+     * Turn on International.
+     *
+     */
+    public void addInternational() {
+        mComprehendInternational = true;
+    }
+
+    /**
+     * Turn on InternationalExHc.
+     *
+     */
+    public void addInternationalExHc() {
+        mComprehendInternationalexHc = true;
+    }
+
+    /**
+     * Turn on CommunicationDiverted.
+     *
+     */
+    public void addCommunicationDiverted() {
+        mComprehendCommunicationDiverted = true;
+    }
+
+    /**
+     * Turn on PresenceStatus.
+     *
+     */
+    public void addPresenceStatus() {
+        mComprehendPresenceStatus = true;
+    }
+
+    /**
+     * Turn on Anonymous.
+     *
+     */
+    public void addAnonymous() {
+        mComprehendAnonymous = true;
+    }
+
+    /**
+     * Get Busy value.
+     *
+     * @return value
+     */
+    public boolean comprehendBusy() {
+        return mComprehendBusy;
+    }
+
+    /**
+     * Get NoAnswer value.
+     *
+     * @return value
+     */
+    public boolean comprehendNoAnswer() {
+        return mComprehendNoAnswer;
+    }
+
+    /**
+     * Get NotReachable value.
+     *
+     * @return value
+     */
+    public boolean comprehendNotReachable() {
+        return mComprehendNotReachable;
+    }
+
+    /**
+     * Get NotRegistered value.
+     *
+     * @return value
+     */
+    public boolean comprehendNotRegistered() {
+        return mComprehendNotRegistered;
+    }
+
+    /**
+     * Get Romaing value.
+     *
+     * @return value
+     */
+    public boolean comprehendRoaming() {
+        return mComprehendRoaming;
+    }
+
+    /**
+     * Get RuleDeactivated value.
+     *
+     * @return value
+     */
+    public boolean comprehendRuleDeactivated() {
+        return mComprehendRuleDeactivated;
+    }
+
+    /**
+     * Get International value.
+     *
+     * @return value
+     */
+    public boolean comprehendInternational() {
+        return mComprehendInternational;
+    }
+
+    /**
+     * Get InternationalExHc value.
+     *
+     * @return value
+     */
+    public boolean comprehendInternationalExHc() {
+        return mComprehendInternationalexHc;
+    }
+
+    /**
+     * Get Communication Diverted value.
+     *
+     * @return value
+     */
+    public boolean comprehendCommunicationDiverted() {
+        return mComprehendCommunicationDiverted;
+    }
+
+    /**
+     * Get PresenceStatus value.
+     *
+     * @return value
+     */
+    public boolean comprehendPresenceStatus() {
+        return mComprehendPresenceStatus;
+    }
+
+    /**
+     * Get Anonymous value.
+     *
+     * @return value
+     */
+    public boolean comprehendAnonymous() {
+        return mComprehendAnonymous;
+    }
+
+    /**
+     * Add Time value.
+     *
+     * @param   time   time value
+     */
+    public void addTime(String time) {
+        mComprehendTime = time;
+    }
+
+    /**
+     * Get Time value.
+     *
+     * @return value
+     */
+    public String comprehendTime() {
+        return mComprehendTime;
+    }
+
+    /**
+     * Add Media value.
+     *
+     * @param   media   media value
+     */
+    public void addMedia(String media) {
+        if (mMedias == null) {
+            mMedias = new LinkedList<String>();
+        }
+        mMedias.add(media);
+    }
+
+    public List<String> getMedias() {
+        return mMedias;
+    }
+
+    /**
+     * Reset condition value.
+     *
+     */
+    public void clearConditions() {
+        mComprehendBusy = false;
+        mComprehendNoAnswer = false;
+        mComprehendNotReachable = false;
+        mComprehendNotRegistered = false;
+        mComprehendRoaming = false;
+        mComprehendRuleDeactivated = false;
+        mComprehendInternational = false;
+        mComprehendCommunicationDiverted = false;
+        mComprehendPresenceStatus = false;
+        if (mMedias == null) {
+            mMedias = new LinkedList<String>();
+        }
+
+        mMedias.clear();
+        mComprehendAnonymous = false;
+        mComprehendTime = null;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/ForwardTo.java b/packages/simservs/src/com/mediatek/simservs/client/policy/ForwardTo.java
new file mode 100644
index 00000000000..297fbd77a2e
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/ForwardTo.java
@@ -0,0 +1,401 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * ForwardTo class.
+ *
+ */
+public class ForwardTo extends XcapElement implements ConfigureType {
+    public static final String NODE_NAME = "forward-to";
+
+    static final String TAG_TARGET = "target";
+    static final String TAG_NOTIFY_CALLER = "notify-caller";
+    static final String TAG_REVEAL_IDENTITY_TO_CALLER = "reveal-identity-to-caller";
+    static final String TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER =
+            "reveal-served-user-identity-to-caller";
+    static final String TAG_NOTIFY_SERVED_USER = "notify-served-user";
+    static final String TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL =
+            "notify-served-user-on-outbound-call";
+    static final String TAG_REVEAL_IDENTITY_TO_TARGET = "reveal-identity-to-target";
+
+    public String mTarget; //minOccurs=1 maxOccurs=1
+    public boolean mNotifyCaller = true; //minOccurs=0
+    public boolean mRevealIdentityToCaller = true; //minOccurs=0
+    public boolean mRevealServedUserIdentityToCaller = true; //minOccurs=0
+    public boolean mNotifyServedUser = false; //minOccurs=0
+    public boolean mNotifyServedUserOnOutboundCall = false; //minOccurs=0
+    public boolean mRevealIdentityToTarget = true; //minOccurs=0
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public ForwardTo(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM element
+     */
+    public ForwardTo(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        // TODO Auto-generated constructor stub
+
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        NodeList forwardToNode = domElement.getElementsByTagName(TAG_TARGET);
+        if (forwardToNode.getLength() > 0) {
+            Element targetElement = (Element) forwardToNode.item(0);
+            mTarget = targetElement.getTextContent();
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_TARGET);
+            if (forwardToNode.getLength() > 0) {
+                Element targetElement = (Element) forwardToNode.item(0);
+                mTarget = targetElement.getTextContent();
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_TARGET);
+                if (forwardToNode.getLength() > 0) {
+                    Element targetElement = (Element) forwardToNode.item(0);
+                    mTarget = targetElement.getTextContent();
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_NOTIFY_CALLER);
+        if (forwardToNode.getLength() > 0) {
+            Element notifyCallerElement = (Element) forwardToNode.item(0);
+            String notifyCaller = notifyCallerElement.getTextContent();
+            mNotifyCaller = notifyCaller.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_NOTIFY_CALLER);
+            if (forwardToNode.getLength() > 0) {
+                Element notifyCallerElement = (Element) forwardToNode.item(0);
+                String notifyCaller = notifyCallerElement.getTextContent();
+                mNotifyCaller = notifyCaller.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_NOTIFY_CALLER);
+                if (forwardToNode.getLength() > 0) {
+                    Element notifyCallerElement = (Element) forwardToNode.item(0);
+                    String notifyCaller = notifyCallerElement.getTextContent();
+                    mNotifyCaller = notifyCaller.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_REVEAL_IDENTITY_TO_CALLER);
+        if (forwardToNode.getLength() > 0) {
+            Element revealCallerElement = (Element) forwardToNode.item(0);
+            String revealCaller = revealCallerElement.getTextContent();
+            mRevealIdentityToCaller = revealCaller.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_REVEAL_IDENTITY_TO_CALLER);
+            if (forwardToNode.getLength() > 0) {
+                Element revealCallerElement = (Element) forwardToNode.item(0);
+                String revealCaller = revealCallerElement.getTextContent();
+                mRevealIdentityToCaller = revealCaller.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_REVEAL_IDENTITY_TO_CALLER);
+                if (forwardToNode.getLength() > 0) {
+                    Element revealCallerElement = (Element) forwardToNode.item(0);
+                    String revealCaller = revealCallerElement.getTextContent();
+                    mRevealIdentityToCaller = revealCaller.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_REVEAL_IDENTITY_TO_TARGET);
+        if (forwardToNode.getLength() > 0) {
+            Element revealTargetElement = (Element) forwardToNode.item(0);
+            String revealTarget = revealTargetElement.getTextContent();
+            mRevealIdentityToTarget = revealTarget.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_REVEAL_IDENTITY_TO_TARGET);
+            if (forwardToNode.getLength() > 0) {
+                Element revealTargetElement = (Element) forwardToNode.item(0);
+                String revealTarget = revealTargetElement.getTextContent();
+                mRevealIdentityToTarget = revealTarget.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_REVEAL_IDENTITY_TO_TARGET);
+                if (forwardToNode.getLength() > 0) {
+                    Element revealTargetElement = (Element) forwardToNode.item(0);
+                    String revealTarget = revealTargetElement.getTextContent();
+                    mRevealIdentityToTarget = revealTarget.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+        if (forwardToNode.getLength() > 0) {
+            Element element = (Element) forwardToNode.item(0);
+            String str = element.getTextContent();
+            mRevealServedUserIdentityToCaller = str.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+            if (forwardToNode.getLength() > 0) {
+                Element element = (Element) forwardToNode.item(0);
+                String str = element.getTextContent();
+                mRevealServedUserIdentityToCaller = str.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+                if (forwardToNode.getLength() > 0) {
+                    Element element = (Element) forwardToNode.item(0);
+                    String str = element.getTextContent();
+                    mRevealServedUserIdentityToCaller = str.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_NOTIFY_SERVED_USER);
+        if (forwardToNode.getLength() > 0) {
+            Element element = (Element) forwardToNode.item(0);
+            String str = element.getTextContent();
+            mNotifyServedUser = str.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_NOTIFY_SERVED_USER);
+            if (forwardToNode.getLength() > 0) {
+                Element element = (Element) forwardToNode.item(0);
+                String str = element.getTextContent();
+                mNotifyServedUser = str.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_NOTIFY_SERVED_USER);
+                if (forwardToNode.getLength() > 0) {
+                    Element element = (Element) forwardToNode.item(0);
+                    String str = element.getTextContent();
+                    mNotifyServedUser = str.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+        if (forwardToNode.getLength() > 0) {
+            Element element = (Element) forwardToNode.item(0);
+            String str = element.getTextContent();
+            mNotifyServedUserOnOutboundCall = str.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+            if (forwardToNode.getLength() > 0) {
+                Element element = (Element) forwardToNode.item(0);
+                String str = element.getTextContent();
+                mNotifyServedUserOnOutboundCall = str.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+                if (forwardToNode.getLength() > 0) {
+                    Element element = (Element) forwardToNode.item(0);
+                    String str = element.getTextContent();
+                    mNotifyServedUserOnOutboundCall = str.equals("true");
+                }
+            }
+        }
+    }
+
+    /**
+     * Convert to XML element.
+     *
+     * @param document DOM document
+     * @return XML element
+     */
+    public Element toXmlElement(Document document) {
+
+        String useXcapNs = System.getProperty("xcap.ns.ss", "false");
+
+        if ("true".equals(useXcapNs)) {
+            Element forwardElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                    "ss:" + NODE_NAME);
+
+            Element allowElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                    "ss:" + TAG_TARGET);
+            allowElement.setTextContent(mTarget);
+            forwardElement.appendChild(allowElement);
+
+            String completeForwardTo = System.getProperty("xcap.completeforwardto",
+                    "false");
+
+            if ("true".equals(completeForwardTo)) {
+                Element notifyCallerElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOTIFY_CALLER);
+                notifyCallerElement.setTextContent(mNotifyCaller ? "true" : "false");
+                forwardElement.appendChild(notifyCallerElement);
+
+                Element revealIdentityToCallerElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_REVEAL_IDENTITY_TO_CALLER);
+                revealIdentityToCallerElement.setTextContent(
+                            mRevealIdentityToCaller ? "true" : "false");
+                forwardElement.appendChild(revealIdentityToCallerElement);
+
+                Element revealServedUserIdentityToCallerElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+                revealServedUserIdentityToCallerElement.setTextContent(
+                            mRevealServedUserIdentityToCaller ? "true" : "false");
+                forwardElement.appendChild(revealServedUserIdentityToCallerElement);
+
+                Element notifyServedUserElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOTIFY_SERVED_USER);
+                notifyServedUserElement.setTextContent(mNotifyServedUser ? "true" : "false");
+                forwardElement.appendChild(notifyServedUserElement);
+
+                Element notifyServedUserOnOutboundCallElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+                notifyServedUserOnOutboundCallElement.setTextContent(
+                        mNotifyServedUserOnOutboundCall ? "true" : "false");
+                forwardElement.appendChild(notifyServedUserOnOutboundCallElement);
+
+                Element revealIdentityToTargetElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_REVEAL_IDENTITY_TO_TARGET);
+                revealIdentityToTargetElement.setTextContent(
+                        mRevealIdentityToTarget ? "true" : "false");
+                forwardElement.appendChild(revealIdentityToTargetElement);
+            }
+
+            return forwardElement;
+        } else {
+            Element forwardElement = (Element) document.createElement(NODE_NAME);
+
+            Element allowElement = (Element) document.createElement(TAG_TARGET);
+            allowElement.setTextContent(mTarget);
+            forwardElement.appendChild(allowElement);
+
+            String completeForwardTo = System.getProperty("xcap.completeforwardto",
+                    "false");
+
+            if ("true".equals(completeForwardTo)) {
+                Element notifyCallerElement = (Element) document.createElement(TAG_NOTIFY_CALLER);
+                notifyCallerElement.setTextContent(mNotifyCaller ? "true" : "false");
+                forwardElement.appendChild(notifyCallerElement);
+
+                Element revealIdentityToCallerElement =
+                        (Element) document.createElement(TAG_REVEAL_IDENTITY_TO_CALLER);
+                revealIdentityToCallerElement.setTextContent(
+                        mRevealIdentityToCaller ? "true" : "false");
+                forwardElement.appendChild(revealIdentityToCallerElement);
+
+                Element revealServedUserIdentityToCallerElement =
+                        (Element) document.createElement(TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+                revealServedUserIdentityToCallerElement.setTextContent(
+                        mRevealServedUserIdentityToCaller ? "true" : "false");
+                forwardElement.appendChild(revealServedUserIdentityToCallerElement);
+
+                Element notifyServedUserElement =
+                        (Element) document.createElement(TAG_NOTIFY_SERVED_USER);
+                notifyServedUserElement.setTextContent(mNotifyServedUser ? "true" : "false");
+                forwardElement.appendChild(notifyServedUserElement);
+
+                Element notifyServedUserOnOutboundCallElement =
+                        (Element) document.createElement(TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+                notifyServedUserOnOutboundCallElement.setTextContent(
+                        mNotifyServedUserOnOutboundCall ? "true" : "false");
+                forwardElement.appendChild(notifyServedUserOnOutboundCallElement);
+
+                Element revealIdentityToTargetElement =
+                        (Element) document.createElement(TAG_REVEAL_IDENTITY_TO_TARGET);
+                revealIdentityToTargetElement.setTextContent(
+                        mRevealIdentityToTarget ? "true" : "false");
+                forwardElement.appendChild(revealIdentityToTargetElement);
+            }
+
+            return forwardElement;
+        }
+
+
+    }
+
+    public void setTarget(String target) {
+        mTarget = target;
+    }
+
+    public void setNotifyCaller(boolean notifyCaller) {
+        mNotifyCaller = notifyCaller;
+    }
+
+    public void setRevealIdentityToCaller(boolean revealIdToCaller) {
+        mRevealIdentityToCaller = revealIdToCaller;
+    }
+
+    public void setRevealServedUserIdentityToCaller(boolean revealIdToCaller) {
+        mRevealServedUserIdentityToCaller = revealIdToCaller;
+    }
+
+    public void setNotifyServedUser(boolean notifyToServedUser) {
+        mNotifyServedUser = notifyToServedUser;
+    }
+
+    public void setNotifyServedUserOnOutboundCall(boolean notifyToServedUser) {
+        mNotifyServedUserOnOutboundCall = notifyToServedUser;
+    }
+
+    public void setRevealIdentityToTarget(boolean revealIdToTarget) {
+        mRevealIdentityToTarget = revealIdToTarget;
+    }
+
+    public String getTarget() {
+        return mTarget;
+    }
+
+    public boolean isNotifyCaller() {
+        return mNotifyCaller;
+    }
+
+    public boolean isRevealIdentityToCaller() {
+        return mRevealIdentityToCaller;
+    }
+
+    public boolean isRevealServedUserIdentityToCaller() {
+        return mRevealServedUserIdentityToCaller;
+    }
+
+    public boolean isNotifyServedUse() {
+        return mNotifyServedUser;
+    }
+
+    public boolean isNotifyServedUserOnOutboundCall() {
+        return mNotifyServedUserOnOutboundCall;
+    }
+
+    public boolean isRevealIdentityToTarget() {
+        return mRevealIdentityToTarget;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Rule.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Rule.java
new file mode 100644
index 00000000000..3a53b34b9b7
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Rule.java
@@ -0,0 +1,221 @@
+
+package com.mediatek.simservs.client.policy;
+
+import android.util.Log;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.simservs.xcap.XcapException;
+
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.net.URISyntaxException;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+
+/**
+ * Rule class.
+ */
+public class Rule extends XcapElement implements ConfigureType {
+    public static final String NODE_NAME = "cp:rule";
+    public static final String NODE_XML_NAMESPACE =
+            "?xmlns(" + COMMON_POLICY_ALIAS + "=" + COMMON_POLICY_NAMESPACE + ")";
+
+    public String mId = "none";
+    public Conditions mConditions;
+    public Actions mActions;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     */
+    public Rule(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor with XML element.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM element
+     */
+    public Rule(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        mId = domElement.getAttribute("id");
+        NodeList conditionsNode = domElement.getElementsByTagName("conditions");
+        if (conditionsNode.getLength() > 0) {
+            mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId,
+                    (Element) conditionsNode.item(0));
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE,
+                    "conditions");
+            if (conditionsNode.getLength() > 0) {
+                mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId,
+                        (Element) conditionsNode.item(0));
+            } else {
+                conditionsNode = domElement.getElementsByTagName("cp:conditions");
+                if (conditionsNode.getLength() > 0) {
+                    mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId,
+                            (Element) conditionsNode.item(0));
+                } else {
+                    mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId);
+                }
+            }
+        }
+
+        NodeList actionsNode = domElement.getElementsByTagName("actions");
+        if (actionsNode.getLength() > 0) {
+            mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId,
+                    (Element) actionsNode.item(0));
+        } else {
+            actionsNode = domElement.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "actions");
+            if (actionsNode.getLength() > 0) {
+                mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId,
+                        (Element) actionsNode.item(0));
+            } else {
+                actionsNode = domElement.getElementsByTagName("cp:actions");
+                if (actionsNode.getLength() > 0) {
+                    mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId,
+                            (Element) actionsNode.item(0));
+                } else {
+                    mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId);
+                }
+            }
+        }
+    }
+
+    /**
+     * Convert to XML element.
+     *
+     * @param  document DOM document
+     * @return DOM element
+     * @throws TransformerException if conversion error
+     */
+    public Element toXmlElement(Document document) throws TransformerException {
+        Element ruleElement = (Element) document.createElement(NODE_NAME);
+        ruleElement.setAttribute("id", mId);
+
+        if (mConditions != null) {
+            Element conditionsElement = mConditions.toXmlElement(document);
+            ruleElement.appendChild(conditionsElement);
+        }
+
+        if (mActions != null) {
+            Element actionsElement = mActions.toXmlElement(document);
+            ruleElement.appendChild(actionsElement);
+        }
+        return ruleElement;
+    }
+
+    /**
+     * Create actions.
+     *
+     * @return actions
+     */
+    public Actions createActions() {
+        if (mActions == null) {
+            mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId);
+        }
+        return mActions;
+    }
+
+    /**
+     * Create conditions.
+     *
+     * @return conditions
+     */
+    public Conditions createConditions() {
+        if (mConditions == null) {
+            mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId);
+        }
+        return mConditions;
+    }
+
+    public void setId(String id) {
+        mId = id;
+    }
+
+    public Conditions getConditions() {
+        return mConditions;
+    }
+
+    public Actions getActions() {
+        return mActions;
+    }
+
+    /**
+     * Sets the content of the current node.
+     *
+     * @param  xml XML string
+     * @throws XcapException if XCAP error
+     */
+    @Override
+    public void setContent(String xml) throws XcapException {
+        try {
+            mNodeUri = getNodeUri().toString();
+
+            if (getNodeName().equals(Rule.NODE_NAME)) {
+                //add rule id selector
+                mNodeUri += "%5b@id=%22" + mId.replaceAll(" ", "%20") +
+                        "%22%5d" + NODE_XML_NAMESPACE;
+            }
+            Log.d("Rule", "setContent etag=" + mEtag);
+            saveContent(xml);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Convert rule to XML string.
+     *
+     * @return  XML string
+     */
+    public String toXmlString() {
+        Element root = null;
+        String xmlString = null;
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document document = builder.newDocument();
+            root = (Element) this.toXmlElement(document);
+            document.appendChild(root);
+            xmlString = domToXmlText(root);
+        } catch (ParserConfigurationException pce) {
+            // Parser with specified options can't be built
+            pce.printStackTrace();
+        } catch (TransformerConfigurationException e) {
+            e.printStackTrace();
+        } catch (TransformerException e) {
+            e.printStackTrace();
+        }
+        return xmlString;
+    }
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/RuleSet.java b/packages/simservs/src/com/mediatek/simservs/client/policy/RuleSet.java
new file mode 100644
index 00000000000..1b4dc19f095
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/RuleSet.java
@@ -0,0 +1,392 @@
+
+package com.mediatek.simservs.client.policy;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.SimServs;
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+
+/**
+ * Rule class.
+ */
+public class RuleSet extends XcapElement implements ConfigureType {
+
+    public static final String NODE_NAME = COMMON_POLICY_ALIAS + ":ruleset";
+    public static final String NODE_NAME_WITH_NAMESPACE = NODE_NAME +
+            "?xmlns(" + COMMON_POLICY_ALIAS + "=" + COMMON_POLICY_NAMESPACE + ")";
+    public List<Rule> mRules;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public RuleSet(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+        mRules = new LinkedList<Rule>();
+    }
+
+    /**
+     * Constructor with XML element.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM element
+     */
+    public RuleSet(XcapUri xcapUri, String parentUri, String intendedId, Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME_WITH_NAMESPACE;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        if (SimServs.LIB_CONFIG_MULTIPLE_RULE_CONDITIONS) {
+            Element domElement = (Element) domNode;
+            NodeList domNodes = domElement.getElementsByTagName("rule");
+            mRules = new LinkedList<Rule>();
+            if (domNodes.getLength() > 0) {
+                Log.d("RuleSet", "Got rule");
+                for (int i = 0; i < domNodes.getLength(); i++) {
+                    Element element = (Element) domNodes.item(i);
+                    Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                            element);
+                    if (mNetwork != null) {
+                        aRule.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        aRule.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        aRule.setEtag(mEtag);
+                    }
+
+                    mRules.add(aRule);
+                }
+            }
+
+            domNodes = domElement.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "rule");
+            if (domNodes.getLength() > 0) {
+                Log.d("RuleSet", "Got rule");
+                for (int i = 0; i < domNodes.getLength(); i++) {
+                    Element element = (Element) domNodes.item(i);
+                    Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                            element);
+                    if (mNetwork != null) {
+                        aRule.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        aRule.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        aRule.setEtag(mEtag);
+                    }
+
+                    mRules.add(aRule);
+                }
+            } else {
+                domNodes = domElement.getElementsByTagName("cp:rule");
+                if (domNodes.getLength() > 0) {
+                    Log.d("RuleSet", "Got cp:rule");
+                    for (int i = 0; i < domNodes.getLength(); i++) {
+                        Element element = (Element) domNodes.item(i);
+                        Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME,
+                                mIntendedId, element);
+                        if (mNetwork != null) {
+                            aRule.setNetwork(mNetwork);
+                        }
+
+                        if (mContext != null) {
+                            aRule.setContext(mContext);
+                        }
+
+                        if (mEtag != null) {
+                            aRule.setEtag(mEtag);
+                        }
+
+                        mRules.add(aRule);
+                    }
+                }
+            }
+
+            Log.d("RuleSet", "rules size:" + mRules.size());
+        } else {
+            // Unfold the conditions to more rules if multiple conditions exists
+            Element domElement = (Element) domNode;
+            NodeList domNodes = domElement.getElementsByTagName("rule");
+            mRules = new LinkedList<Rule>();
+            if (domNodes.getLength() > 0) {
+                Log.d("RuleSet", "Got rule");
+                for (int i = 0; i < domNodes.getLength(); i++) {
+                    Element element = (Element) domNodes.item(i);
+                    Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                            element);
+                    if (mNetwork != null) {
+                        aRule.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        aRule.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        aRule.setEtag(mEtag);
+                    }
+
+                    Conditions conditions = aRule.getConditions();
+                    if (conditions != null) {
+                        List<String> medias = aRule.getConditions().getMedias();
+                        // Unfolding multiple medias
+                        if (medias != null && medias.size() > 0) {
+                            Iterator<String> it = medias.iterator();
+                            while (it.hasNext()) {
+                                unfoldRules(aRule, element, it.next());
+                            }
+                        } else {
+                            unfoldRules(aRule, element, null);
+                        }
+                    } else {
+                        mRules.add(aRule);
+                    }
+                }
+            } else {
+                domNodes = domElement.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "rule");
+                if (domNodes.getLength() > 0) {
+                    Log.d("RuleSet", "Got rule");
+                    for (int i = 0; i < domNodes.getLength(); i++) {
+                        Element element = (Element) domNodes.item(i);
+                        Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                                element);
+                        if (mNetwork != null) {
+                            aRule.setNetwork(mNetwork);
+                        }
+
+                        if (mContext != null) {
+                            aRule.setContext(mContext);
+                        }
+                        if (mEtag != null) {
+                            aRule.setEtag(mEtag);
+                        }
+                        Conditions conditions = aRule.getConditions();
+                        if (conditions != null) {
+                            List<String> medias = aRule.getConditions().getMedias();
+                            // Unfolding multiple medias
+                            if (medias != null && medias.size() > 0) {
+                                Iterator<String> it = medias.iterator();
+                                while (it.hasNext()) {
+                                    unfoldRules(aRule, element, it.next());
+                                }
+                            } else {
+                                unfoldRules(aRule, element, null);
+                            }
+                        } else {
+                            mRules.add(aRule);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void unfoldRules(Rule aRule, Element element, String media) {
+        if (aRule.getConditions().comprehendBusy()) {
+            Rule ruleBusy = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleBusy.setNetwork(mNetwork);
+            }
+            ruleBusy.getConditions().clearConditions();
+            ruleBusy.getConditions().addBusy();
+            if (media != null) {
+                ruleBusy.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleBusy);
+        }
+        if (aRule.getConditions().comprehendNotReachable()) {
+            Rule ruleNotReachable = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleNotReachable.setNetwork(mNetwork);
+            }
+            ruleNotReachable.getConditions().clearConditions();
+            ruleNotReachable.getConditions().addNotReachable();
+            if (media != null) {
+                ruleNotReachable.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleNotReachable);
+        }
+        if (aRule.getConditions().comprehendInternational()) {
+            Rule ruleInternational = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleInternational.setNetwork(mNetwork);
+            }
+            ruleInternational.getConditions().clearConditions();
+            ruleInternational.getConditions().addInternational();
+            if (media != null) {
+                ruleInternational.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleInternational);
+        }
+        if (aRule.getConditions().comprehendInternationalExHc()) {
+            Rule ruleInternationalExHc = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME,
+                    mIntendedId, element);
+            if (mNetwork != null) {
+                ruleInternationalExHc.setNetwork(mNetwork);
+            }
+            ruleInternationalExHc.getConditions().clearConditions();
+            ruleInternationalExHc.getConditions().addInternational();
+            if (media != null) {
+                ruleInternationalExHc.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleInternationalExHc);
+        }
+
+        if (aRule.getConditions().comprehendNoAnswer()) {
+            Rule ruleNoAnswer = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleNoAnswer.setNetwork(mNetwork);
+            }
+            ruleNoAnswer.getConditions().clearConditions();
+            ruleNoAnswer.getConditions().addNoAnswer();
+            if (media != null) {
+                ruleNoAnswer.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleNoAnswer);
+        }
+        if (aRule.getConditions().comprehendRoaming()) {
+            Rule ruleRoaming = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleRoaming.setNetwork(mNetwork);
+            }
+            ruleRoaming.getConditions().clearConditions();
+            ruleRoaming.getConditions().addRoaming();
+            if (media != null) {
+                ruleRoaming.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleRoaming);
+        }
+    }
+
+    public List<Rule> getRules() {
+        return mRules;
+    }
+
+    /**
+     * Create rule.
+     *
+     * @param   id rule ID
+     * @return  new rule
+     */
+    public Rule createNewRule(String id) {
+        if (mRules == null) {
+            mRules = new LinkedList<Rule>();
+        }
+        Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId);
+        if (mNetwork != null) {
+            aRule.setNetwork(mNetwork);
+        }
+        if (mEtag != null) {
+            aRule.setEtag(mEtag);
+        }
+        aRule.setId(id);
+        mRules.add(aRule);
+        return aRule;
+    }
+
+    /**
+     * Empty rules.
+     */
+    public void clearRules() {
+        if (mRules == null) {
+            mRules = new LinkedList<Rule>();
+        }
+        mRules.clear();
+    }
+
+    /**
+     * Convert ruleset to XML string.
+     *
+     * @return  XML string
+     */
+    public String toXmlString() {
+        Element root = null;
+        String xmlString = null;
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document document = builder.newDocument();
+            root = (Element) document.createElement(NODE_NAME);
+            document.appendChild(root);
+            //Add by mtk01411: 2014-0128 to avoid Null Pointer Exception
+            if (mRules != null) {
+                Iterator<Rule> it = mRules.iterator();
+                while (it.hasNext()) {
+                    Rule rule = (Rule) it.next();
+                    Element ruleElement = rule.toXmlElement(document);
+                    root.appendChild(ruleElement);
+                }
+            }
+            xmlString = domToXmlText(root);
+        } catch (ParserConfigurationException pce) {
+            // Parser with specified options can't be built
+            pce.printStackTrace();
+        } catch (TransformerConfigurationException e) {
+            e.printStackTrace();
+        } catch (TransformerException e) {
+            e.printStackTrace();
+        }
+        return xmlString;
+    }
+
+    /**
+     * Set ETag value.
+     *
+     * @param etag value
+     */
+    @Override
+    public void setEtag(String etag) {
+        mEtag = etag;
+
+        for (Rule rule : mRules) {
+            Log.d("RuleSet", "rule:" + rule.mId + ", set etag:" + etag);
+            rule.setEtag(etag);
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Sphere.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Sphere.java
new file mode 100644
index 00000000000..ce4146e403c
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Sphere.java
@@ -0,0 +1,29 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Spheret class.
+ */
+public class Sphere extends XcapElement {
+
+    public static final String NODE_NAME = "sphere";
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Sphere(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Transformations.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Transformations.java
new file mode 100644
index 00000000000..3135baf5c72
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Transformations.java
@@ -0,0 +1,29 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Transformations class.
+ */
+public class Transformations extends XcapElement {
+
+    public static final String NODE_NAME = "transformations";
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Transformations(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Until.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Until.java
new file mode 100644
index 00000000000..674878a9e0b
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Until.java
@@ -0,0 +1,29 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Until class.
+ */
+public class Until extends XcapElement {
+
+    public static final String NODE_NAME = "until";
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Until(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Validity.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Validity.java
new file mode 100644
index 00000000000..2afd5e13641
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Validity.java
@@ -0,0 +1,29 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Validity class.
+ */
+public class Validity extends XcapElement {
+
+    public static final String NODE_NAME = "validity";
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Validity(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/Attributable.java b/packages/simservs/src/com/mediatek/simservs/xcap/Attributable.java
new file mode 100644
index 00000000000..1deddd1fd20
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/Attributable.java
@@ -0,0 +1,33 @@
+package com.mediatek.simservs.xcap;
+
+/**
+ * Attributable interface.
+ *
+ */
+public interface Attributable {
+    /**
+     * Get specific attribute by name.
+     *
+     * @param attribute attribute name
+     * @return  attribute value
+     * @throws  XcapException   if XCAP error
+     */
+    public String getByAttrName(String attribute) throws XcapException;
+
+    /**
+     * Set specific attribute by name.
+     *
+     * @param attrName     attribute name
+     * @param attrValue     attribute value
+     * @throws  XcapException   if XCAP error
+     */
+    public void setByAttrName(String attrName, String attrValue) throws XcapException;
+
+    /**
+     * Delete specific attribute by name.
+     *
+     * @param attribute     attribute name
+     * @throws  XcapException   if XCAP error
+     */
+    public void deleteByAttrName(String attribute) throws XcapException;
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/ConfigureType.java b/packages/simservs/src/com/mediatek/simservs/xcap/ConfigureType.java
new file mode 100644
index 00000000000..2946251f9f4
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/ConfigureType.java
@@ -0,0 +1,17 @@
+package com.mediatek.simservs.xcap;
+
+import org.w3c.dom.Node;
+
+/**
+ * Configure Type interface.
+ *
+ */
+public interface ConfigureType {
+
+    /**
+     * Instanciate from XML.
+     *
+     * @param domNode   DOM node
+     */
+    public void instantiateFromXmlNode(Node domNode);
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/InquireType.java b/packages/simservs/src/com/mediatek/simservs/xcap/InquireType.java
new file mode 100644
index 00000000000..bef68f2b2e2
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/InquireType.java
@@ -0,0 +1,144 @@
+package com.mediatek.simservs.xcap;
+
+import android.util.Log;
+
+import com.mediatek.xcap.client.XcapClient;
+import com.mediatek.xcap.client.XcapDebugParam;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import com.android.okhttp.Headers;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * InquireType abstract class.
+ *
+ */
+public abstract class InquireType extends XcapElement {
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri           XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public InquireType(XcapUri xcapUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Gets the content of the current node through XCAP protocol.
+     *
+     * @return configuration XML
+     * @throws XcapException if XCAP error
+     */
+    public String getContent() throws XcapException {
+        XcapClient xcapClient = null;
+        HttpURLConnection conn = null;
+        String ret = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            String nodeUri = getNodeUri().toString();
+            XcapDebugParam debugParam = XcapDebugParam.getInstance();
+
+            if (debugParam.getEnableSimservQueryWhole()) {
+                nodeUri = nodeUri.substring(0, nodeUri.lastIndexOf("simservs") +
+                        "simservs".length());
+            }
+
+            URI uri = new URI(nodeUri);
+
+            if (mNetwork != null) {
+                xcapClient = new XcapClient(mNetwork);
+
+                if (xcapClient == null) {
+                    throw new XcapException(500);
+                }
+            } else {
+                xcapClient = new XcapClient();
+            }
+
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-None-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            if (mContext != null) {
+                xcapClient.setContext(mContext);
+            }
+            conn = xcapClient.get(uri, headers.build());
+
+            if (conn != null) {
+                if (conn.getResponseCode() == 200 ||
+                        conn.getResponseCode() == 304) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mIsSupportEtag = true;
+                        this.mEtag = etagValue;
+                    } else {
+                        this.mIsSupportEtag = false;
+                        this.mEtag = null;
+                    }
+
+                    InputStream is = null;
+                    try {
+                        is = conn.getInputStream();
+                        // convert stream to string
+                        ret = convertStreamToString(is);
+                    } finally {
+                        if (is != null) {
+                            is.close();
+                        }
+                    }
+                } else if (conn.getResponseCode() == 409) {
+                    InputStream is = conn.getInputStream();
+
+                    if (is != null) {
+                        if ("true".equals(
+                                System.getProperty("xcap.handl409"))) {
+                            ret = null;
+                            throw new XcapException(409,
+                                parse409ErrorMessage("phrase", is));
+                        } else {
+                            ret = null;
+                            throw new XcapException(409);
+                        }
+                    } else {
+                        ret = null;
+                        throw new XcapException(409);
+                    }
+                } else {
+                    ret = null;
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+
+        Log.d(TAG, "Response XML:");
+        Log.d(TAG, ret);
+        return ret;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/RuleType.java b/packages/simservs/src/com/mediatek/simservs/xcap/RuleType.java
new file mode 100644
index 00000000000..a10b24557e8
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/RuleType.java
@@ -0,0 +1,40 @@
+package com.mediatek.simservs.xcap;
+
+import com.mediatek.simservs.client.policy.RuleSet;
+
+
+/**
+ * Rule Type interface.
+ *
+ */
+public interface RuleType {
+
+    /**
+    * Get rule set.
+    *
+    * @return Ruleset
+    */
+    public RuleSet getRuleSet();
+
+    /**
+     * Save ruleset to server.
+     *
+     * @throws  XcapException if XCAP error
+     */
+    public void saveRuleSet() throws XcapException;
+
+    /**
+     * Create ruleset.
+     *
+     * @return  ruleset
+     */
+    public RuleSet createNewRuleSet();
+
+    /**
+     * Save rule to server.
+     *
+     * @param ruleId rule to be saved by the id
+     * @throws  XcapException if XCAP error
+     */
+    public void saveRule(String ruleId) throws XcapException;
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/XcapElement.java b/packages/simservs/src/com/mediatek/simservs/xcap/XcapElement.java
new file mode 100644
index 00000000000..83b7f8b98f7
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/XcapElement.java
@@ -0,0 +1,575 @@
+package com.mediatek.simservs.xcap;
+
+import android.content.Context;
+import android.net.Network;
+import android.os.SystemProperties;
+import android.util.Log;
+
+import com.android.okhttp.Headers;
+
+import com.mediatek.simservs.client.CommunicationDiversion.NoReplyTimer;
+import com.mediatek.xcap.client.XcapClient;
+import com.mediatek.xcap.client.XcapConstants;
+import com.mediatek.xcap.client.XcapDebugParam;
+import com.mediatek.xcap.client.uri.XcapUri;
+import com.mediatek.xcap.client.uri.XcapUri.XcapNodeSelector;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.DataInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.net.HttpURLConnection;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+
+/**
+ * Validity abstract class.
+ */
+public abstract class XcapElement implements Attributable {
+    public static final String TAG = "XcapElement";
+    public static final String TRUE = "true";
+    public static final String FALSE = "false";
+
+    protected static final String AUTH_XCAP_3GPP_INTENDED = "X-3GPP-Intended-Identity";
+    protected static final String XCAP_NAMESPACE =
+            "http://uri.etsi.org/ngn/params/xml/simservs/xcap";
+    protected static final String XCAP_ALIAS = "ss";
+    protected static final String COMMON_POLICY_NAMESPACE = "urn:ietf:params:xml:ns:common-policy";
+    protected static final String COMMON_POLICY_ALIAS = "cp";
+    protected String mNodeUri = null;
+    public XcapUri mXcapUri = null;
+    public String mParentUri = null;
+    public String mIntendedId = null;
+    protected String mEtag = null;
+    protected boolean mIsSupportEtag = false;
+    public XcapDebugParam mDebugParams = XcapDebugParam.getInstance();
+    protected Network mNetwork;
+    protected Context mContext;
+
+    /**
+     * Constructs an instance without XML source.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public XcapElement(XcapUri xcapUri, String parentUri, String intendedId) {
+        mXcapUri = xcapUri;
+        mParentUri = parentUri;
+        mIntendedId = intendedId;
+    }
+
+    /**
+     * Set dedicated network.
+     *
+     * @param network dedicated network
+     */
+    public void setNetwork(Network network) {
+        if (network != null) {
+            Log.i(TAG, "XCAP dedicated network netid:" + network);
+            mNetwork = network;
+        }
+    }
+
+    /**
+     * Set context.
+     *
+     * @param ctxt context to set
+     */
+    public void setContext(Context ctxt) {
+        if (ctxt != null) {
+            mContext = ctxt;
+        }
+    }
+
+    /**
+     * Set ETag value.
+     *
+     * @param etag value
+     */
+    public void setEtag(String etag) {
+        mEtag = etag;
+    }
+
+    /**
+     * Get ETag value.
+     *
+     * @return ETag value
+     */
+    public String getEtag() {
+        return mEtag;
+    }
+
+    /**
+     * Get node URI.
+     *
+     * @return URI
+     * @throws IllegalArgumentException if illegal argument
+     * @throws URISyntaxException if URI syntax error
+     */
+    public URI getNodeUri() throws IllegalArgumentException,
+            URISyntaxException {
+        URI elementURI;
+        XcapNodeSelector elementSelector = new XcapNodeSelector(XcapConstants.ROOT_SIMSERVS)
+                .queryByNodeName(mParentUri)
+                .queryByNodeName(getNodeName());
+
+        elementURI = mXcapUri.setNodeSelector(elementSelector).toURI();
+        return elementURI;
+    }
+
+    /**
+     * Get attribute URI .
+     *
+     * @return URI
+     * @throws IllegalArgumentException if illegal argument
+     */
+    private URI getAttributeUri(String attribute) throws IllegalArgumentException,
+            URISyntaxException {
+        URI elementURI;
+        XcapNodeSelector elementSelector = new XcapNodeSelector(XcapConstants.ROOT_SIMSERVS)
+                .queryByNodeName(mParentUri)
+                .queryByNodeName(getNodeName(), attribute);
+
+        elementURI = mXcapUri.setNodeSelector(elementSelector).toURI();
+        return elementURI;
+    }
+
+    /**
+     * Gets attribute value by attribute name.
+     *
+     * @param  attribute attribute name
+     * @return attribute value
+     * @throws XcapException if XCAP error
+     */
+    @Override
+    public String getByAttrName(String attribute) throws XcapException {
+        XcapClient xcapClient;
+
+        if (mNetwork != null) {
+            xcapClient = new XcapClient(mNetwork);
+        } else {
+            xcapClient = new XcapClient();
+        }
+
+        HttpURLConnection conn = null;
+        String ret = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-None-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            conn = xcapClient.get(getAttributeUri(attribute), headers.build());
+            if (conn != null) {
+                if (conn.getResponseCode() == 200) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mEtag = etagValue;
+                    }
+
+                    InputStream is = conn.getInputStream();
+                    // convert stream to string
+                    ret = convertStreamToString(is);
+                } else {
+                    ret = null;
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+        return ret;
+    }
+
+    /**
+     * Sets attribute value by attribute name.
+     *
+     * @param  attrName attribute name
+     * @param  attrValue attribute value
+     * @throws XcapException if XCAP error
+     */
+    @Override
+    public void setByAttrName(String attrName, String attrValue) throws XcapException {
+        XcapClient xcapClient;
+
+        if (mNetwork != null) {
+            xcapClient = new XcapClient(mNetwork);
+        } else {
+            xcapClient = new XcapClient();
+        }
+
+        HttpURLConnection conn = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            conn = xcapClient.put(getAttributeUri(attrName), "application/xcap-att+xml",
+                    attrValue, headers.build());
+            // check put response
+            if (conn != null) {
+                if (conn.getResponseCode() == 200
+                        || conn.getResponseCode() == 201) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mEtag = etagValue;
+                    }
+
+                    Log.d("info", "document created in xcap server...");
+                } else {
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+    }
+
+    /**
+     * Deletes attribute by attribute name.
+     *
+     * @param  attribute attribute name
+     * @throws XcapException if XCAP error
+     */
+    @Override
+    public void deleteByAttrName(String attribute) throws XcapException {
+        XcapClient xcapClient;
+
+        if (mNetwork != null) {
+            xcapClient = new XcapClient(mNetwork);
+        } else {
+            xcapClient = new XcapClient();
+        }
+
+        HttpURLConnection conn = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            conn = xcapClient.delete(getAttributeUri(attribute), headers.build());
+            // check put response
+            if (conn != null) {
+                if (conn.getResponseCode() == 200) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mEtag = etagValue;
+                    }
+
+                    Log.d("info", "document deleted in xcap server...");
+                } else {
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+    }
+
+    /**
+     * Sets the content of the current node.
+     *
+     * @param  xml XML string
+     * @throws XcapException if XCAP error
+     */
+    public void setContent(String xml) throws XcapException {
+        try {
+            mNodeUri = getNodeUri().toString();
+            saveContent(xml);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Update current node through XCAP protocol.
+     *
+     * @param  xml XML string
+     * @throws XcapException if XCAP error
+     */
+    protected void saveContent(String xml) throws XcapException {
+        XcapClient xcapClient = null;
+        HttpURLConnection conn = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            URI uri = new URI(mNodeUri);
+
+            if (mNetwork != null) {
+                xcapClient = new XcapClient(mNetwork);
+
+                if (xcapClient == null) {
+                    throw new XcapException(500);
+                }
+            } else {
+                xcapClient = new XcapClient();
+            }
+
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            if (mDebugParams.getEnablePredefinedSimservSetting() &&
+                    !getNodeName().equals(NoReplyTimer.NODE_NAME)) {
+                String xMl = readXmlFromFile("/data/simservs.xml");
+
+                if (xMl != null) {
+                    xml = xMl;
+                }
+            }
+
+            String putElementMime = null;
+
+            if (mDebugParams.getXcapPutElementMime() != null &&
+                    !mDebugParams.getXcapPutElementMime().isEmpty()) {
+                putElementMime = mDebugParams.getXcapPutElementMime();
+            } else {
+                putElementMime = System.getProperty("xcap.putelcontenttype",
+                        "application/xcap-el+xml");
+            }
+
+            conn = xcapClient.put(uri, putElementMime, xml, headers.build());
+            // check put response
+            if (conn != null) {
+                if (conn.getResponseCode() == 200
+                        || conn.getResponseCode() == 201) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mEtag = etagValue;
+                    }
+
+                    Log.d("info", "document created in xcap server...");
+                } else if (conn.getResponseCode() == 409) {
+                    InputStream is = conn.getInputStream();
+
+                    if (is != null) {
+                        if ("true".equals(System.getProperty("xcap.handl409"))) {
+                            throw new XcapException(409, parse409ErrorMessage("phrase", is));
+                        } else {
+                            throw new XcapException(409);
+                        }
+                    } else {
+                        throw new XcapException(409);
+                    }
+                } else {
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+    }
+
+    /**
+     * Not supported.
+     *
+     * @return content type
+     */
+    public String getContentType() {
+        return null;
+    }
+
+    /**
+     * Gets the URI of the current node.
+     *
+     * @return URI
+     */
+    public String getUri() {
+        StringBuilder pathUri = new StringBuilder();
+
+        if (mParentUri != null) {
+            pathUri.append(mParentUri)
+                    .append("\\")
+                    .append(getNodeName());
+            return pathUri.toString();
+        } else {
+            return getNodeName();
+        }
+    }
+
+    /**
+     * Not supported.
+     *
+     * @return null
+     */
+    public XcapElement getParent() {
+        return null;
+    }
+
+    /**
+     * Not supported.
+     *
+     * @return null
+     */
+    public String getNodeSelector() {
+        return null;
+    }
+
+
+    /**
+     * Transfer the DOM object to XML string.
+     *
+     * @param  element DOM element
+     * @return XML string
+     * @throws TransformerException if tranformation error
+     */
+    public String domToXmlText(Element element) throws TransformerException {
+        TransformerFactory transFactory = TransformerFactory.newInstance();
+        Transformer transformer = transFactory.newTransformer();
+        StringWriter buffer = new StringWriter();
+        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
+        transformer.transform(new DOMSource(element),
+                new StreamResult(buffer));
+        return buffer.toString();
+    }
+
+    /**
+     * Transfer input stream to string.
+     *
+     * @param  inputStream input stream
+     * @return string
+     * @throws IOException if I/O error
+     */
+    public String convertStreamToString(InputStream inputStream) throws IOException {
+        BufferedReader r = new BufferedReader(new InputStreamReader(inputStream));
+        StringBuilder total = new StringBuilder();
+        String line;
+        while ((line = r.readLine()) != null) {
+            total.append(line);
+        }
+        return total.toString();
+    }
+
+    protected abstract String getNodeName();
+
+    protected String readXmlFromFile(String file) {
+        String text = "";
+
+        try {
+            FileInputStream fis = new FileInputStream(file);
+            BufferedInputStream bis = new BufferedInputStream(fis);
+            DataInputStream dis = new DataInputStream(fis);
+
+            String buf;
+            while ((buf = dis.readLine()) != null) {
+                Log.d(TAG, "Read:" + buf);
+                text += buf;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return text;
+    }
+
+    /**
+     * Parse HTTP 409 error message.
+     *
+     * @param  xmlErrorTag HTTP 409 specific error message XML tag
+     * @param  inputStream HTTP 409 content
+     * @return string
+     */
+    protected String parse409ErrorMessage(String xmlErrorTag, InputStream content)
+            throws XcapException {
+        try {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            factory.setNamespaceAware(false);
+            DocumentBuilder db = factory.newDocumentBuilder();
+            InputSource is = new InputSource();
+            is.setCharacterStream(new StringReader(convertStreamToString(content)));
+            Document doc;
+            doc = db.parse(is);
+
+            NodeList currentNode = doc.getElementsByTagName(xmlErrorTag);
+
+            if (currentNode.getLength() > 0) {
+                Element activeElement = (Element) currentNode.item(0);
+                String textContent = activeElement.getTextContent();
+                Log.d(TAG, "parse409ErrorMessage:[" + textContent + "]");
+                return textContent;
+            }
+        } catch (ParserConfigurationException e) {
+            e.printStackTrace();
+            throw new XcapException(500);
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(500);
+        } catch (SAXException e) {
+            e.printStackTrace();
+            throw new XcapException(500);
+        }
+
+        return null;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/XcapException.java b/packages/simservs/src/com/mediatek/simservs/xcap/XcapException.java
new file mode 100644
index 00000000000..02246fefe49
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/XcapException.java
@@ -0,0 +1,79 @@
+
+package com.mediatek.simservs.xcap;
+
+import java.io.IOException;
+
+/**
+ * XCAP Exception class.
+ */
+public class XcapException extends Exception {
+
+    private static final long serialVersionUID = 1L;
+
+    public static final int NO_EXCEPTION = 0;
+    public static final int CONNECTION_POOL_TIMEOUT_EXCEPTION = 1;
+    public static final int CONNECT_TIMEOUT_EXCEPTION = 2;
+    public static final int NO_HTTP_RESPONSE_EXCEPTION = 3;
+    public static final int HTTP_RECOVERABL_EEXCEPTION = 4;
+    public static final int MALFORMED_CHALLENGE_EXCEPTION = 5;
+    public static final int AUTH_CHALLENGE_EXCEPTION = 6;
+    public static final int CREDENTIALS_NOT_AVAILABLE_EXCEPTION = 7;
+    public static final int INVALID_CREDENTIALS_EXCEPTION = 8;
+    public static final int AUTHENTICATION_EXCEPTION = 9;
+    public static final int MALFORMED_COOKIE_EXCEPTION = 10;
+    public static final int REDIRECT_EXCEPTION = 11;
+    public static final int URI_EXCEPTION = 12;
+    public static final int PROTOCOL_EXCEPTION = 13;
+    public static final int HTTP_EXCEPTION = 14;
+
+    private int mHttpErrorCode = 0;
+    private int mExceptionCode = NO_EXCEPTION;
+    private boolean mIsConnectionError = false;
+    private String mXcapErrorMessage;
+
+    /**
+     * Constructs an instance with error code.
+     *
+     * @param httpErrorCode XCAP error code
+     */
+    public XcapException(int httpErrorCode) {
+        mHttpErrorCode = httpErrorCode;
+    }
+
+    /**
+     * Constructs an instance with error code and message.
+     *
+     * @param httpErrorCode XCAP error code
+     * @param xcapErrorMessage XCAP error message
+     */
+    public XcapException(int httpErrorCode, String xcapErrorMessage) {
+        mHttpErrorCode = httpErrorCode;
+        mXcapErrorMessage = xcapErrorMessage;
+    }
+
+    /**
+     * Constructs an instance with IO exception.
+     *
+     * @param httpException I/O error exception
+     */
+    public XcapException(IOException httpException) {
+        if ("GBA Authentication hit HTTP 403 Forbidden".equals(httpException.getMessage())) {
+            mHttpErrorCode = 403;
+            return;
+        }
+
+        mIsConnectionError = true;
+    }
+
+    public boolean isConnectionError() {
+        return mIsConnectionError;
+    }
+
+    public int getHttpErrorCode() {
+        return mHttpErrorCode;
+    }
+
+    public int getExceptionCodeCode() {
+        return mExceptionCode;
+    }
+}
diff --git a/packages/simservs/test/SimservsTest.java b/packages/simservs/test/SimservsTest.java
new file mode 100644
index 00000000000..fdedad4137d
--- /dev/null
+++ b/packages/simservs/test/SimservsTest.java
@@ -0,0 +1,565 @@
+
+package com.mediatek.simservs.test;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.CommunicationDiversion;
+import com.mediatek.simservs.client.CommunicationWaiting;
+import com.mediatek.simservs.client.IncomingCommunicationBarring;
+import com.mediatek.simservs.client.OriginatingIdentityPresentation;
+import com.mediatek.simservs.client.OriginatingIdentityPresentationRestriction;
+import com.mediatek.simservs.client.OutgoingCommunicationBarring;
+import com.mediatek.simservs.client.SimServs;
+import com.mediatek.simservs.client.policy.Actions;
+import com.mediatek.simservs.client.policy.Conditions;
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.XcapClient;
+import com.mediatek.xcap.client.XcapConstants;
+import com.mediatek.xcap.client.uri.XcapUri;
+import com.mediatek.xcap.client.uri.XcapUri.XcapDocumentSelector;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.List;
+
+/**
+ * Simservs test class.
+ */
+public class SimservsTest {
+
+    static final private String TAG = "SimservsTest";
+
+    static final private String INITIAL_DOC =
+            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
+            "    <resource-lists xmlns=\"urn:ietf:params:xml:ns:resource-lists\">\r\n" +
+            "        <communication-waiting active=\"true\"/>\r\n" +
+            "        <originating-identity-presentation active=\"true\"/>\r\n" +
+            "        <originating-identity-presentation-restriction active=\"true\"/>\r\n" +
+            "        <outgoing-communication-barring active=\"true\">\r\n" +
+            "             <ruleset>\r\n" +
+            "                  <rule id=\"AO\">\r\n" +
+            "                       <actions>\r\n" +
+            "                            <allow>false</allow>\r\n" +
+            "                       </actions>\r\n" +
+            "                  </rule>\r\n" +
+            "             </ruleset>\r\n" +
+            "        </outgoing-communication-barring>\r\n" +
+            "        <incoming-communication-barring active=\"true\">\r\n" +
+            "             <ruleset>\r\n" +
+            "                  <rule id=\"IR\">\r\n" +
+            "                       <conditions>\r\n" +
+            "                            <roaming/>\r\n" +
+            "                            <media>audio</media>\r\n" +
+            "                       </conditions>\r\n" +
+            "                       <actions>\r\n" +
+            "                            <allow>false</allow>\r\n" +
+            "                       </actions>\r\n" +
+            "                  </rule>\r\n" +
+            "             </ruleset>\r\n" +
+            "        </incoming-communication-barring>\r\n" +
+            "        <communication-diversion active=\"true\">\r\n" +
+            "            <NoReplyTimer>1000</NoReplyTimer>\r\n" +
+            "            <ruleset>\r\n" +
+            "                <rule id=\"CFB\">\r\n" +
+            "                    <conditions>\r\n" +
+            "                        <busy/>\r\n" +
+            "                        <media>audio</media>\r\n" +
+            "                    </conditions>\r\n" +
+            "                    <actions>\r\n" +
+            "                        <forward-to>\r\n" +
+            "                            <target>\"+886988555222\"</target>\r\n" +
+            "                            <notify-caller>true</notify-caller>\r\n" +
+            "                        </forward-to>\r\n" +
+            "                    </actions>\r\n" +
+            "                </rule>\r\n" +
+            "                <rule id=\"CFNRc\">\r\n" +
+            "                    <conditions>\r\n" +
+            "                        <not-reachable/>\r\n" +
+            "                        <media>audio</media>\r\n" +
+            "                    </conditions>\r\n" +
+            "                    <actions>\r\n" +
+            "                        <forward-to>\r\n" +
+            "                            <target>\"+886988555222\"</target>\r\n" +
+            "                            <notify-caller>true</notify-caller>\r\n" +
+            "                        </forward-to>\r\n" +
+            "                    </actions>\r\n" +
+            "                </rule>\r\n" +
+            "            </ruleset>\r\n" +
+            "        </communication-diversion>\r\n" +
+            "        <communication-diversion-serv-cap active=\"true\">\r\n" +
+            "          <serv-cap-conditions>\r\n" +
+            "             <serv-cap-external-list provisioned=\"false\">\r\n" +
+            "               </serv-cap-external-list>\r\n" +
+            "             <serv-cap-identity provisioned=\"true\"></serv-cap-identity>\r\n" +
+            "             <serv-cap-media>\r\n" +
+            "                <media>audio</media>\r\n" +
+            "                <media>video</media>\r\n" +
+            "              </serv-cap-media>\r\n" +
+            "             <serv-cap-presence-status provisioned=\"false\">\r\n" +
+            "               </serv-cap-presence-status>\r\n" +
+            "             <serv-cap-validity provisioned=\"false\"></serv-cap-validity>\r\n" +
+            "          </serv-cap-conditions>\r\n" +
+            "          <serv-cap-actions>\r\n" +
+            "               <serv-cap-target>\r\n" +
+            "                  <telephony-type/>\r\n" +
+            "               </serv-cap-target>\r\n" +
+            "               <serv-cap-notify-served-user-on-outbound-call provisioned=\"false\">" +
+            "                 </serv-cap-notify-served-user-on-outbound-call>\r\n" +
+            "              <serv-cap-reveal-identity-to-caller provisioned=\"false\">\r\n" +
+            "                </serv-cap-reveal-identity-to-caller>\r\n" +
+            "              <serv-cap-reveal-served-user-identity-to-caller provisioned=\"false\">" +
+            "                </serv-cap-reveal-served-user-identity-to-caller>\r\n" +
+            "              <serv-cap-reveal-identity-to-target provisioned=\"false\">\r\n" +
+            "                </serv-cap-reveal-identity-to-target>\r\n" +
+            "          </serv-cap-actions>\r\n" +
+            "        </communication-diversion-serv-cap>\r\n" +
+            "        <communication-barring-serv-cap active=\"true\">\r\n" +
+            "            <serv-cap-conditions>\r\n" +
+            "                <serv-cap-communication-diverted provisioned=\"false\">\r\n" +
+            "                   </serv-cap-communication-diverted>\r\n" +
+            "                <serv-cap-external-list provisioned=\"false\">" +
+            "                   </serv-cap-external-list>\r\n" +
+            "                <serv-cap-identity provisioned=\"false\"></serv-cap-identity>\r\n" +
+            "                <serv-cap-media>\r\n" +
+            "                    <media>audio</media>\r\n" +
+            "                    <media>video</media>\r\n" +
+            "                </serv-cap-media>\r\n" +
+            "                <serv-cap-other-identity provisioned=\"false\">" +
+            "                   </serv-cap-other-identity>\r\n" +
+            "                <serv-cap-presence-status provisioned=\"false\">" +
+            "                   </serv-cap-presence-status>\r\n" +
+            "                <serv-cap-roaming provisioned=\"true\"></serv-cap-roaming>\r\n" +
+            "                <serv-cap-rule-deactivated provisioned=\"false\">" +
+            "                   </serv-cap-rule-deactivated>\r\n" +
+            "                <serv-cap-request-name provisioned=\"false\">" +
+            "                   </serv-cap-request-name>\r\n" +
+            "                <serv-cap-validity provisioned=\"false\"></serv-cap-validity>\r\n" +
+            "            </serv-cap-conditions>\r\n" +
+            "        </communication-barring-serv-cap>\r\n" +
+            "    </resource-lists>\r\n";
+
+    static final private String XCAP_ROOT = "http://192.168.1.2:8080/";
+    static final private String TEST_USER = "sip:user@anritsu-cscf.com";
+    static final private String TEST_DOC = "simservs";
+
+    /**
+     * Fetch document of supplementary service configuration.
+     *
+     * @param ra XcapClient instance
+     * @param documentURI document location URI
+     */
+    private static void getDoc(XcapClient ra,
+            URI documentURI) throws IOException {
+
+        HttpResponse response;
+        response = ra.get(documentURI, null);
+
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "response 200, response = " + response.toString());
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+    }
+
+    /**
+     * Configure supplementary service.
+     *
+     * @param ra XcapClient instance
+     * @param documentURI document location URI
+     */
+    private static void putDoc(XcapClient ra,
+            URI uri) throws IOException {
+        URI documentURI = uri;
+        HttpResponse response;
+
+        // put the document and get sync response
+        response = ra.put(documentURI, "application/resource-lists+xml", INITIAL_DOC);
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200
+                    || response.getStatusLine().getStatusCode() == 201) {
+                Log.d("info", "document created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create document in xcap server...");
+        }
+
+    }
+
+    /**
+     * Remove configuration of supplementary service.
+     *
+     * @param ra XcapClient instance
+     * @param documentURI document location URI
+     */
+    private static void deleteDoc(XcapClient ra,
+            URI uri) throws IOException {
+        URI documentURI = uri;
+        HttpResponse response;
+
+        response = ra.delete(documentURI);
+
+        // check get response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "document retreived in xcap server and content is the expected...");
+                Log.d("info", "sync test suceed :)");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+    }
+
+    /**
+     * Test suite.
+     *
+     * @throws URISyntaxException if URI syntax error
+     * @throws IOException        if I/O error
+     */
+    static public void syncTest() throws URISyntaxException, IOException {
+        String documentUri = null;
+        SimServs simservs = SimServs.getInstance();
+
+        simservs.setXui("user@chinaTel.com");
+        simservs.setIntendedId("user@chinaTel.com");
+
+        simservs.setXuiByImsiMccMnc("234150999999999", "234", "15");
+        String xui = simservs.getXui();
+        if (xui == null) {
+            Exception e = new Exception("XUI test fail");
+            e.printStackTrace();
+            throw e;
+        }
+
+        simservs.setXcapRootByImpi("user@chinaTel.com");
+        documentUri = simservs.getDocumentUri();
+
+        simservs.setXcapRootByImpi("2341509999999999@ims.mnc466.mcc97.3gppnetwork.org");
+        documentUri = simservs.getDocumentUri();
+
+        simservs.setXcapRootByMccMnc("466", "97");
+        documentUri = simservs.getDocumentUri();
+
+        XcapClient ra = new XcapClient();
+
+        XcapDocumentSelector documentSelector = new XcapDocumentSelector(
+                XcapConstants.AUID_RESOURCE_LISTS, TEST_USER, TEST_DOC);
+        Log.d(TAG, "document selector is " + documentSelector.toString());
+        XcapUri xcapUri = new XcapUri();
+        xcapUri.setXcapRoot(XCAP_ROOT).setDocumentSelector(documentSelector);
+
+        // ====================================
+
+        try {
+            CommunicationWaiting cw = simservs.getCommunicationWaiting(xcapUri, TEST_USER,
+                    "password");
+            CommunicationDiversion cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            IncomingCommunicationBarring icb = simservs.getIncomingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            OutgoingCommunicationBarring ocb = simservs.getOutgoingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            OriginatingIdentityPresentation oip = simservs.getOriginatingIdentityPresentation(
+                    xcapUri, TEST_USER, "password");
+            OriginatingIdentityPresentationRestriction oir = simservs
+                    .getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                            "password");
+
+            // ====================================
+            // De-active test
+            cw.setActive(false);
+            cw = simservs.getCommunicationWaiting(xcapUri, TEST_USER,
+                    "password");
+            if (cw.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            cd.setActive(false);
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            if (cd.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            icb.setActive(false);
+            icb = simservs.getIncomingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            if (icb.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            ocb.setActive(false);
+            ocb = simservs.getOutgoingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            if (ocb.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            oip.setActive(false);
+            oip = simservs.getOriginatingIdentityPresentation(
+                    xcapUri, TEST_USER, "password");
+            if (oip.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            oir.setActive(false);
+            oir = simservs.getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                    "password");
+            if (oir.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            // ====================================
+            // Active test
+            cw.setActive(true);
+            cw = simservs.getCommunicationWaiting(xcapUri, TEST_USER,
+                    "password");
+            if (!cw.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            cd.setActive(true);
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            if (!cd.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            icb.setActive(true);
+            icb = simservs.getIncomingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            if (!icb.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            ocb.setActive(true);
+            ocb = simservs.getOutgoingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            if (!ocb.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            oip.setActive(true);
+            oip = simservs.getOriginatingIdentityPresentation(
+                    xcapUri, TEST_USER, "password");
+            if (!oip.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            oir.setActive(true);
+            oir = simservs.getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                    "password");
+            if (!oir.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            // ====================================
+            // OIR default-behaviour test
+            oir.setDefaultPresentationRestricted(false);
+            oir = simservs
+                    .getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                            "password");
+            if (oir.isDefaultPresentationRestricted()) {
+                throw new Exception("UT default-behaviour test fail");
+            }
+
+            oir.setDefaultPresentationRestricted(true);
+            oir = simservs
+                    .getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                            "password");
+            if (!oir.isDefaultPresentationRestricted()) {
+                throw new Exception("UT default-behaviour test fail");
+            }
+
+            // ====================================
+            // CD NoReplyTimer test
+            int cdNoReplayTimer = cd.getNoReplyTimer();
+            cd.setNoReplyTimer(555);
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            if (cd.getNoReplyTimer() != 555) {
+                throw new Exception("UT CD NoReplyTimer test fail");
+
+            }
+
+            cd.setNoReplyTimer(cdNoReplayTimer);
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            if (cd.getNoReplyTimer() != cdNoReplayTimer) {
+                throw new Exception("UT CD NoReplyTimer test fail");
+            }
+
+            // ====================================
+            // Clear ruleset test
+            RuleSet ruleSet = cd.getRuleSet();
+            ruleSet.clearRules();
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() > 0) {
+                throw new Exception("UT CD Clear ruleset test fail");
+            }
+
+            // ====================================
+            // Add a rule test
+            Rule rule = ruleSet.createNewRule("Add a rule test");
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT CD create rule test fail");
+            }
+
+            // ====================================
+            // Add a condition within a rule test
+            rule = ruleSet.getRules().get(0);
+            Conditions conditions = rule.createConditions();
+            conditions.addRoaming();
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT Add a condition on a rule test fail");
+            } else {
+                rule = ruleSet.getRules().get(0);
+                if (!rule.getConditions().comprehendRoaming()) {
+                    throw new Exception("UT Add a condition on a rule test fail");
+                }
+            }
+
+            // ====================================
+            // Add a media within a condition test
+            rule = ruleSet.getRules().get(0);
+            conditions = rule.getConditions();
+            conditions.addMedia("audio");
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT Add a condition media within a rule test fail");
+            } else {
+                rule = ruleSet.getRules().get(0);
+                List<String> medias = rule.getConditions().getMedias();
+                if (!medias.get(0).equals("audio")) {
+                    throw new Exception("UT Add a condition media within a rule test fail");
+                }
+            }
+
+            // ====================================
+            // Unfold multiple conditions test
+            if (!simservs.LIB_CONFIG_MULTIPLE_RULE_CONDITIONS) {
+                rule = ruleSet.getRules().get(0);
+                conditions = rule.getConditions();
+                conditions.addBusy();
+                conditions.addMedia("video");
+                cd.saveRuleSet();
+
+                cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                        "password");
+                ruleSet = cd.getRuleSet();
+                if (ruleSet.getRules().size() < 4) {
+                    throw new Exception("UT Unfold multiple conditions test fail");
+                }
+                // Save to server and check again
+                cd.saveRuleSet();
+
+                cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                        "password");
+                ruleSet = cd.getRuleSet();
+                if (ruleSet.getRules().size() < 4) {
+                    throw new Exception("UT Unfold multiple conditions test fail");
+                }
+            }
+            // ====================================
+            // CD Target modify test
+            ruleSet = cd.getRuleSet();
+            ruleSet.clearRules();
+            rule = ruleSet.createNewRule("CD Target modify test");
+            rule.createConditions().addBusy();
+            Actions actions = rule.createActions();
+            actions.setFowardTo("0912364587", true);
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT CD Target modify test fail");
+            } else {
+                rule = ruleSet.getRules().get(0);
+                if (!rule.getConditions().comprehendBusy()) {
+                    throw new Exception("UT CD Target modify test fail");
+                } else {
+                    if (!rule.getActions().getFowardTo().getTarget().endsWith("0912364587")) {
+                        throw new Exception("UT CD Target modify test fail");
+                    }
+                    if (!rule.getActions().getFowardTo().isNotifyCaller()) {
+                        throw new Exception("UT CD Target modify test fail");
+                    }
+                }
+            }
+            // ====================================
+            // CB Action allow test
+            ruleSet = icb.getRuleSet();
+            ruleSet.clearRules();
+
+            rule = ruleSet.createNewRule("CB Action allow test");
+            rule.createConditions().addInternational();
+            actions = rule.createActions();
+            actions.setAllow(true);
+            icb.saveRuleSet();
+
+            icb = simservs.getIncomingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            ruleSet = icb.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT CB Action allow test fail");
+            } else {
+                rule = ruleSet.getRules().get(0);
+                if (!rule.getConditions().comprehendInternational()) {
+                    throw new Exception("UT CB Action allow test fail");
+                } else {
+                    if (!rule.getActions().isAllow()) {
+                        throw new Exception("UT CB Action allow test fail");
+                    }
+                }
+            }
+            // ====================================
+        } catch (XcapException e) {
+            int httpErrorCode = -1;
+            int exceptionCodeCode = -1;
+            if (e.isConnectionError()) {
+                exceptionCodeCode = e.getExceptionCodeCode();
+                Log.e("Simservs", "httpErrorCode=" + httpErrorCode);
+            } else {
+                httpErrorCode = e.getHttpErrorCode();
+                Log.e("Simservs", "exceptionCodeCode=" + exceptionCodeCode);
+            }
+            e.printStackTrace();
+        }
+
+        /** Delete a XML document **/
+        // deleteDoc(ra, xcapUri.toURI(), credentials);
+        // ====================================
+        ra.shutdown();
+    }
+}
diff --git a/packages/xcap/Android.mk b/packages/xcap/Android.mk
new file mode 100644
index 00000000000..91f314ceee5
--- /dev/null
+++ b/packages/xcap/Android.mk
@@ -0,0 +1,16 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_JAVA_LIBRARIES := okhttp
+
+# Include all the java files.
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_MODULE_TAGS := optional
+
+# The name of the jar file to create.
+LOCAL_MODULE := xcap
+
+# Build a static jar file.
+include $(BUILD_STATIC_JAVA_LIBRARY)
+
diff --git a/packages/xcap/NOTICE b/packages/xcap/NOTICE
new file mode 100644
index 00000000000..fa27076404a
--- /dev/null
+++ b/packages/xcap/NOTICE
@@ -0,0 +1,15 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
\ No newline at end of file
diff --git a/packages/xcap/README b/packages/xcap/README
new file mode 100644
index 00000000000..bee265bb14f
--- /dev/null
+++ b/packages/xcap/README
@@ -0,0 +1,19 @@
+MTK XCAP library, for any feature that uses XCAP protocol.
+
+This library is pre-built by MediaTek internal.
+
+
+WHAT IT DOES?
+=============
+Simservs module will depend on xcap to communicate with XCAP server.
+
+HOW IT WAS BUILT?
+==================
+All source/dependency modules of this module are already put in
+'vendor/mediatek/proprietary/protect/external/xcap' folder.
+
+HOW TO USE IT?
+==============
+Provide api for any feature module that runs on XCAP protocol.
+
+All the source code of this library were written by MediaTek co..
diff --git a/packages/xcap/src/com/mediatek/xcap/XcapClient.java b/packages/xcap/src/com/mediatek/xcap/XcapClient.java
new file mode 100644
index 00000000000..d2a43e35db9
--- /dev/null
+++ b/packages/xcap/src/com/mediatek/xcap/XcapClient.java
@@ -0,0 +1,492 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.client;
+
+import android.content.Context;
+import android.net.Network;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import com.android.okhttp.Headers;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.ProtocolException;
+import java.net.Socket;
+import java.net.URI;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.CertificateException;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+/**
+ * XcapClient class.
+ */
+public class XcapClient {
+    private static final String TAG = "XcapClient";
+
+    private HttpURLConnection mConnection = null;
+
+    private String mUserAgent;
+
+    // Default connection and socket timeout of 60 seconds. Tweak to taste.
+    private static final int SOCKET_OPERATION_TIMEOUT = 30 * 1000;
+    private static final int MAX_SOCKET_CONNECTION = 30;
+
+    private XcapDebugParam mDebugParam = XcapDebugParam.getInstance();
+    private Network mNetwork;
+    private Context mContext;
+
+    private TrustManager[] mTrustAllCerts = new TrustManager[] {new X509TrustManager() {
+        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+                return null;
+        }
+
+        public void checkClientTrusted(java.security.cert.X509Certificate[] certs,
+                String authType) {
+        }
+
+        public void checkServerTrusted(java.security.cert.X509Certificate[] certs,
+                String authType) {
+        }
+    } };
+
+    public static final String METHOD_PUT = "PUT";
+    public static final String METHOD_GET = "GET";
+    public static final String METHOD_DELETE = "DELETE";
+
+    /**
+     * Constructor.
+     *
+     */
+    public XcapClient() {
+        composeUserAgent();
+        initialize();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param userAgent XCAP client User Agent
+     */
+    public XcapClient(String userAgent) {
+        mUserAgent = userAgent;
+        initialize();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param network dedicated network
+     */
+    public XcapClient(Network network) {
+        composeUserAgent();
+
+        if (network != null) {
+            mNetwork = network;
+        }
+
+        initialize();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param userAgent XCAP client User Agent
+     * @param network dedicated network
+     */
+    public XcapClient(String userAgent, Network network) {
+        mUserAgent = userAgent;
+
+        if (network != null) {
+            mNetwork = network;
+        }
+
+        initialize();
+    }
+
+    /**
+     * Set context.
+     *
+     * @param ctxt context to set
+     */
+    public void setContext(Context ctxt) {
+        mContext = ctxt;
+    }
+
+    private void composeUserAgent() {
+        boolean isGbaEnabled = false;
+        IBinder b = ServiceManager.getService("GbaService");
+        if (b != null) {
+            Log.i(TAG , "GbaService Enabled");
+            isGbaEnabled = true;
+        }
+
+        if (mDebugParam.getXcapUserAgent() != null && !mDebugParam.getXcapUserAgent().isEmpty()) {
+            mUserAgent = mDebugParam.getXcapUserAgent();
+        } else {
+            mUserAgent = "XCAP Client" + (isGbaEnabled ? " 3gpp-gba" : "");
+        }
+    }
+
+    private void initialize() {
+
+    }
+
+    /**
+     * Shutdown connection.
+     */
+    public void shutdown() {
+        if (mConnection != null) {
+            mConnection.disconnect();
+        }
+    }
+
+    private void addExtraHeaders(HttpURLConnection connection, Headers rawHeaders) {
+        Set<String> names = rawHeaders.names();
+        for (String name : names) {
+            List<String> values = rawHeaders.values(name);
+            for (String value : values) {
+                if (!name.isEmpty() && !value.isEmpty()) {
+                    // Add the header if the param is valid
+                    connection.setRequestProperty(name, value);
+                    break;
+                }
+            }
+        }
+    }
+
+    private void logRequestHeaders(HttpURLConnection connection) {
+        Map<String, List<String>> headerFields = connection.getRequestProperties();
+
+        Log.d(TAG, "Request Headers:");
+
+        for (Map.Entry<String, List<String>> entry : headerFields.entrySet()) {
+            final String key = entry.getKey();
+            final List<String> values = entry.getValue();
+            if (values != null) {
+                for (String value : values) {
+                    Log.d(TAG, key + ": " + value);
+                }
+            }
+        }
+    }
+
+    private void logResponseHeaders(HttpURLConnection connection) {
+        Map<String, List<String>> headerFields = connection.getHeaderFields();
+
+        Log.d(TAG, "Response Headers:");
+
+        for (Map.Entry<String, List<String>> entry : headerFields.entrySet()) {
+            final String key = entry.getKey();
+            final List<String> values = entry.getValue();
+            if (values != null) {
+                for (String value : values) {
+                    Log.d(TAG, key + ": " + value);
+                }
+            }
+        }
+    }
+
+    private HttpURLConnection execute(URL url, String method, byte[] xml,
+            Headers additionalRequestHeaders) throws IOException {
+        int tryCount = 3;
+        boolean success = false;
+        //OkHttp usage
+        mConnection = null;
+
+        boolean isTrustAll = mDebugParam.getEnableXcapTrustAll();
+
+        if (isTrustAll) {
+            // Install the all-trusting trust manager
+            try {
+                SSLContext sc = SSLContext.getInstance("SSL");
+                sc.init(null, mTrustAllCerts, new java.security.SecureRandom());
+                HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
+            } catch (GeneralSecurityException se) {
+                se.printStackTrace();
+            }
+
+            // Create all-trusting host name verifier
+            HostnameVerifier allHostsValid = new HostnameVerifier() {
+                public boolean verify(String hostname, SSLSession session) {
+                    return true;
+                }
+            };
+
+            // Install the all-trusting host verifier
+            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
+        }
+
+        while (tryCount > 0 && !success) {
+            try {
+                Log.d(TAG, method + " :" + url.toString());
+
+                if (mNetwork != null) {
+                    mConnection = (HttpURLConnection) mNetwork.openConnection(url);
+                } else {
+                    mConnection = (HttpURLConnection) url.openConnection();
+                }
+                mConnection.setDoInput(true);
+                mConnection.setConnectTimeout(SOCKET_OPERATION_TIMEOUT);
+                mConnection.setReadTimeout(SOCKET_OPERATION_TIMEOUT);
+                // xen0n: AOSP doesn't have setWriteTimeout
+                // mConnection.setWriteTimeout(SOCKET_OPERATION_TIMEOUT);
+                // Header: User-Agent
+                mConnection.setRequestProperty("User-Agent", mUserAgent);
+                addExtraHeaders(mConnection, additionalRequestHeaders);
+                // Different stuff for GET and POST
+                if (METHOD_PUT.equals(method)) {
+                    mConnection.setDoOutput(true);
+                    mConnection.setRequestMethod(METHOD_PUT);
+                    if (Log.isLoggable(TAG, Log.DEBUG)) {
+                        logRequestHeaders(mConnection);
+                    }
+                    // Sending request body
+                    final OutputStream out =
+                            new BufferedOutputStream(mConnection.getOutputStream());
+                    out.write(xml);
+                    out.flush();
+                    out.close();
+                } else if (METHOD_GET.equals(method)) {
+                    mConnection.setRequestMethod(METHOD_GET);
+                    if (Log.isLoggable(TAG, Log.DEBUG)) {
+                        logRequestHeaders(mConnection);
+                    }
+                }
+
+
+                // Get response
+                final int responseCode = mConnection.getResponseCode();
+                final String responseMessage = mConnection.getResponseMessage();
+                Log.d(TAG, "HTTP: " + responseCode + " " + responseMessage);
+                if (Log.isLoggable(TAG, Log.DEBUG)) {
+                    logResponseHeaders(mConnection);
+                }
+
+                if (responseCode == 200 || responseCode == 403  || responseCode == 304 ||
+                        responseCode == 412) {
+                    success = true;
+                    break;
+                } else if (responseCode == 409) {
+                    if ("true".equals(System.getProperty("xcap.handl409"))) {
+                        success = true;
+                        break;
+                    } else {
+                        Log.d(TAG, "HTTP status code is not 200 or 403");
+                    }
+                } else {
+                    Log.d(TAG, "HTTP status code is not 200 or 403 or 409");
+                }
+            } catch (MalformedURLException e) {
+                e.printStackTrace();
+                throw e;
+            } catch (ProtocolException e) {
+                e.printStackTrace();
+                throw e;
+            } catch (IOException e) {
+                e.printStackTrace();
+                Log.d(TAG, "gba.auth:" + System.getProperty("gba.auth"));
+                if ("403".equals(System.getProperty("gba.auth"))) {
+                    success = true;
+                    System.setProperty("gba.auth", "");
+                    throw new IOException("GBA Authentication hit HTTP 403 Forbidden");
+                } else {
+                    throw e;
+                }
+            } finally {
+                if (!success) {
+                    try {
+                        tryCount--;
+                        if (tryCount > 0) {
+                            Thread.sleep(5 * 1000);
+                            Log.d(TAG, "retry once");
+                        }
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+
+        return mConnection;
+        //OkHttp usage end
+    }
+
+    /**
+     * HTTP GET.
+     *
+     * @param  uri document URI
+     * @param  additionalRequestHeaders HTTP headers
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection get(URI uri, Headers additionalRequestHeaders) throws IOException {
+        return execute(uri.toURL(), METHOD_GET, null, additionalRequestHeaders);
+    }
+
+    /**
+     * HTTP PUT.
+     *
+     * @param  uri document URI
+     * @param  mimetype MIME TYPE
+     * @param  content content to upload
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection put(URI uri, String mimetype, String content) throws IOException {
+        Log.d(TAG, "PUT: " + content);
+        return put(uri, mimetype, content.getBytes("UTF-8"), null, null, null);
+
+    }
+
+    /**
+     * HTTP PUT.
+     *
+     * @param  uri document URI
+     * @param  mimetype MIME TYPE
+     * @param  content content to upload
+     * @param  additionalRequestHeaders HTTP headers
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection put(URI uri, String mimetype, String content,
+            Headers additionalRequestHeaders) throws IOException {
+        Log.d(TAG, "PUT: " + content);
+        return put(uri, mimetype, content.getBytes("UTF-8"), additionalRequestHeaders, null, null);
+
+    }
+
+    /**
+     * HTTP PUT.
+     *
+     * @param  uri document URI
+     * @param  mimetype MIME TYPE
+     * @param  content content to upload in string format
+     * @param  additionalRequestHeaders HTTP headers
+     * @param  eTag E-TAG
+     * @param  condition use with E-TAG
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection put(URI uri, String mimetype, String content,
+            Headers additionalRequestHeaders, String eTag, String condition) throws IOException {
+        Log.d(TAG, "PUT: " + content);
+        return put(uri, mimetype, content.getBytes("UTF-8"), additionalRequestHeaders, eTag,
+                condition);
+
+    }
+
+    /**
+     * HTTP PUT.
+     *
+     * @param  uri document URI
+     * @param  mimetype MIME TYPE
+     * @param  content content to upload in byte array format
+     * @param  additionalRequestHeaders HTTP headers
+     * @param  eTag E-TAG
+     * @param  condition use with E-TAG
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection put(URI uri, String mimetype, byte[] content,
+            Headers additionalRequestHeaders, String eTag, String condition) throws IOException {
+        Headers.Builder headers = additionalRequestHeaders.newBuilder();
+        headers.add(XcapConstants.HDR_KEY_CONTENT_TYPE, mimetype);
+        return execute(uri.toURL(), METHOD_PUT, content, headers.build());
+    }
+
+    /**
+     * HTTP DELETE.
+     *
+     * @param  uri document URI
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection delete(URI uri) throws IOException {
+        return delete(uri, null, null, null);
+    }
+
+    /**
+     * HTTP DELETE.
+     *
+     * @param  uri document URI
+     * @param  additionalRequestHeaders HTTP headers
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection delete(URI uri, Headers additionalRequestHeaders) throws IOException {
+        return delete(uri, additionalRequestHeaders, null, null);
+    }
+
+    /**
+     * HTTP DELETE.
+     *
+     * @param  uri document URI
+     * @param  additionalRequestHeaders HTTP headers
+     * @param  eTag E-TAG
+     * @param  condition use with E-TAG
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection delete(URI uri, Headers additionalRequestHeaders, String eTag,
+            String condition) throws IOException {
+        return execute(uri.toURL(), METHOD_DELETE, null, additionalRequestHeaders);
+    }
+}
diff --git a/packages/xcap/src/com/mediatek/xcap/XcapConstants.java b/packages/xcap/src/com/mediatek/xcap/XcapConstants.java
new file mode 100644
index 00000000000..a17053e7340
--- /dev/null
+++ b/packages/xcap/src/com/mediatek/xcap/XcapConstants.java
@@ -0,0 +1,82 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.client;
+
+/**
+ * XcapConstants class.
+ */
+public class XcapConstants {
+
+    /**
+     * Method enumeration.
+     */
+    public enum Method {
+        GET,
+        PUT,
+        DELETE
+    }
+
+    // KEY: HTTP Header ==> HDR_KEY
+    public static final String HDR_KEY_ALLOW = "Allow";
+    public static final String HDR_KEY_CONTENT_TYPE = "Content-Type";
+    public static final String HDR_KEY_CONTENT_LENGTH = "Content-Length";
+    public static final String HDR_KEY_ETAG = "ETag";
+    public static final String HDR_KEY_IF_MATCH = "If-Match";
+    public static final String HDR_KEY_IF_NONE_MATCH = "If-None-Match";
+    public static final String HDR_KEY_HOST = "Host";
+    public static final String HDR_KEY_AUTHORIZATION = "Authorization";
+    public static final String HDR_KEY_WWW_AUTHENTICATE = "WWW-Authenticate";
+    public static final String HDR_KEY_X_3GPP_ASSERTED_IDENTITY = "X-3GPP-Asserted-Identity";
+    public static final String HDR_KEY_X_XCAP_ASSERTED_IDENTITY = "X-XCAP-Asserted-Identity";
+
+    public static final String AUID_GROUP_USAGE_LIST = "org.openmobilealliance.group-usage-list";
+    public static final String AUID_GROUPS = "org.openmobilealliance.groups";
+    public static final String AUID_OMA_SEARCH = "org.openmobilealliance.search";
+    public static final String AUID_PRES_RULES = "org.openmobilealliance.pres-rules";
+    public static final String AUID_RESOURCE_LISTS = "resource-lists";
+    public static final String AUID_XCAP_CAPS = "xcap-caps";
+    public static final String AUID_XCAP_DIRECTORY = "org.openmobilealliance.xcap-directory";
+    public static final String AUID_USER_PROFILE = "org.openmobilealliance.user-profile";
+
+    public static final String ROOT_SIMSERVS = "simservs";
+
+    // Value: HTTP Header value ==> HDR_VALUE
+
+}
diff --git a/packages/xcap/src/com/mediatek/xcap/XcapDebugParam.java b/packages/xcap/src/com/mediatek/xcap/XcapDebugParam.java
new file mode 100644
index 00000000000..f355230a17a
--- /dev/null
+++ b/packages/xcap/src/com/mediatek/xcap/XcapDebugParam.java
@@ -0,0 +1,371 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.client;
+
+import android.os.SystemProperties;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.StringReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * XCAP debug configuration class.
+ */
+public class XcapDebugParam {
+    private static final String TAG_ROOT = "DebugParam";
+    private static final String TAG_XCAP_ROOT = "XcapRoot";
+    private static final String TAG_XCAP_USER_AGENT = "XcapUserAgent";
+    private static final String TAG_XCAP_XUI = "XcapXui";
+    private static final String TAG_XCAP_HTTP_DIGEST_USERNAME = "HttpDigestUsername";
+    private static final String TAG_XCAP_HTTP_DIGEST_PASSWORD = "HttpDigestPassword";
+    private static final String TAG_XCAP_ENABLE_PREDEFINED_SIMSERV_QUERY_RESULT =
+            "EnablePredefinedSimservQueryResult";
+    private static final String TAG_XCAP_ENABLE_PREDEFINED_SIMSERV_SETTING =
+            "EnablePredefinedSimservSetting";
+    private static final String TAG_XCAP_ENABLE_SIMSERV_QUERY_WHOLE = "EnableSimservQueryWhole";
+    private static final String TAG_XCAP_ENABLE_HTTP_LOG = "EnableHttpLog";
+    private static final String TAG_XCAP_ENABLE_TRUST_ALL = "EnableXcapTrustAll";
+    private static final String TAG_XCAP_DOCUMENT_NAME = "XcapDocumentName";
+    private static final String TAG_XCAP_PUT_ELEMENT_MIME = "XcapPutElementMime";
+    private static final String TAG_GBA_BSF_SERVER_URL = "BsfServerUrl";
+    private static final String TAG_ENABLE_GBA_TRUST_ALL = "EnableGbaTrustAll";
+    private static final String TAG_ENABLE_GBA_FORCE_RUN = "EnableGbaForceRun";
+
+    private static XcapDebugParam sInstance;
+
+    //XCAP
+    private String mXcapRoot;
+    private String mXcapUserAgent;
+    private String mXcapXui;
+    private String mHttpDigestUsername;
+    private String mHttpDigestPassword;
+    //if enable, push xml file to /data/ss.xml
+    private boolean mEnablePredefinedSimservQueryResult = false;
+    //if enable, push xml file /data/simservs.xml
+    private boolean mEnablePredefinedSimservSetting = false;
+    private boolean mEnableSimservQueryWhole = false;
+    private boolean mEnableHttpLog = false;
+    private boolean mEnableXcapTrustAll = false;
+    private String mXcapDocumentName;
+    private String mXcapPutElementMime;
+
+    /**
+     * Singleton.
+     *
+     * @return XcapDebugParam instance
+     */
+    public static XcapDebugParam getInstance() {
+        if (sInstance == null) {
+            sInstance = new XcapDebugParam();
+        }
+        return sInstance;
+    }
+
+
+    /**
+     * Load debug configuration.
+     */
+    public void load() {
+        String xmlContent = readXmlFromFile("/data/misc/xcapconfig.xml");
+        if (xmlContent == null) {
+            return;
+        }
+
+        try {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilder db = factory.newDocumentBuilder();
+            InputSource is = new InputSource();
+            is.setCharacterStream(new StringReader(xmlContent));
+            Document doc;
+            doc = db.parse(is);
+
+            NodeList debugParamNode = doc.getElementsByTagName(TAG_ROOT);
+            if (debugParamNode.getLength() > 0) {
+                instantiateFromXmlNode(debugParamNode.item(0));
+            }
+        } catch (SAXException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (ParserConfigurationException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Read XML file.
+     *
+     * @param file XML file path
+     * @return String content of XML
+     */
+    public String readXmlFromFile(String file) {
+        String text = "";
+
+        try {
+            FileInputStream fis = new FileInputStream(file);
+            DataInputStream dis = new DataInputStream(fis);
+
+            String buf;
+            while ((buf = dis.readLine()) != null) {
+                text += buf;
+            }
+            fis.close();
+        } catch (IOException e) {
+            reset();
+            return null;
+        }
+
+        return text;
+    }
+
+    private void reset() {
+        mXcapRoot = null;
+        mXcapUserAgent = null;
+        mXcapXui = null;
+        mHttpDigestUsername = null;
+        mHttpDigestPassword = null;
+        mEnablePredefinedSimservQueryResult = false;
+        mEnablePredefinedSimservSetting = false;
+        mEnableSimservQueryWhole = false;
+        mEnableHttpLog = false;
+        mEnableXcapTrustAll = false;
+        mXcapDocumentName = "simservs.xml";
+        mXcapPutElementMime = null;
+    }
+
+    private void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+
+        NodeList node = domElement.getElementsByTagName(TAG_XCAP_ROOT);
+        if (node.getLength() > 0) {
+            mXcapRoot = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_USER_AGENT);
+        if (node.getLength() > 0) {
+            mXcapUserAgent = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_XUI);
+        if (node.getLength() > 0) {
+            mXcapXui = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_HTTP_DIGEST_USERNAME);
+        if (node.getLength() > 0) {
+            mHttpDigestUsername = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_HTTP_DIGEST_PASSWORD);
+        if (node.getLength() > 0) {
+            mHttpDigestPassword = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_PREDEFINED_SIMSERV_QUERY_RESULT);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnablePredefinedSimservQueryResult = true;
+            } else {
+                mEnablePredefinedSimservQueryResult = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_PREDEFINED_SIMSERV_SETTING);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnablePredefinedSimservSetting = true;
+            } else {
+                mEnablePredefinedSimservSetting = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_SIMSERV_QUERY_WHOLE);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnableSimservQueryWhole = true;
+            } else {
+                mEnableSimservQueryWhole = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_HTTP_LOG);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnableHttpLog = true;
+            } else {
+                mEnableHttpLog = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_TRUST_ALL);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnableXcapTrustAll = true;
+            } else {
+                mEnableXcapTrustAll = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_DOCUMENT_NAME);
+        if (node.getLength() > 0) {
+            mXcapDocumentName = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_PUT_ELEMENT_MIME);
+        if (node.getLength() > 0) {
+            mXcapPutElementMime = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_GBA_BSF_SERVER_URL);
+        if (node.getLength() > 0) {
+            String gbaBsfServerUrl = ((Element) node.item(0)).getTextContent();
+            SystemProperties.set("persist.gba.bsf.url", gbaBsfServerUrl);
+        }
+
+        node = domElement.getElementsByTagName(TAG_ENABLE_GBA_TRUST_ALL);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                SystemProperties.set("persist.gba.trustall", str);
+            } else if ("false".equalsIgnoreCase(str)) {
+                SystemProperties.set("persist.gba.trustall", str);
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_ENABLE_GBA_FORCE_RUN);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                SystemProperties.set("gba.run", str);
+            } else if ("false".equalsIgnoreCase(str)) {
+                SystemProperties.set("gba.run", str);
+            }
+        }
+    }
+
+    public String getXcapRoot() {
+        return mXcapRoot;
+    }
+
+    public String getXcapUserAgent() {
+        return mXcapUserAgent;
+    }
+
+    public String getXcapXui() {
+        return mXcapXui;
+    }
+
+    public String getHttpDigestUsername() {
+        return mHttpDigestUsername;
+    }
+
+    public String getHttpDigestPassword() {
+        return mHttpDigestPassword;
+    }
+
+    public boolean getEnablePredefinedSimservQueryResult() {
+        return mEnablePredefinedSimservQueryResult;
+    }
+
+    public boolean getEnablePredefinedSimservSetting() {
+        return mEnablePredefinedSimservSetting;
+    }
+
+    public boolean getEnableSimservQueryWhole() {
+        return mEnableSimservQueryWhole;
+    }
+
+    public boolean getEnableHttpLog() {
+        return mEnableHttpLog;
+    }
+
+    public boolean getEnableXcapTrustAll() {
+        return mEnableXcapTrustAll;
+    }
+
+    public String getXcapDocumentName() {
+        return mXcapDocumentName;
+    }
+
+    public String getXcapPutElementMime() {
+        return mXcapPutElementMime;
+    }
+
+    /**
+     * Print info.
+     *
+     * @return String type of info
+     */
+    public String toString() {
+        return "mXcapRoot: " + mXcapRoot + "\n" +
+                "mXcapUserAgent: " + mXcapUserAgent + "\n" +
+                "mXcapXui: " + mXcapXui + "\n" +
+                "mHttpDigestUsername: " + mHttpDigestUsername + "\n" +
+                "mHttpDigestPassword: " + mHttpDigestPassword + "\n" +
+                "mEnablePredefinedSimservQueryResult: " +
+                mEnablePredefinedSimservQueryResult + "\n" +
+                "mEnablePredefinedSimservSetting: " +
+                mEnablePredefinedSimservSetting + "\n" +
+                "mEnableSimservQueryWhole: " + mEnableSimservQueryWhole + "\n" +
+                "mEnableHttpLog: " + mEnableHttpLog + "\n" +
+                "mEnableXcapTrustAll: " + mEnableXcapTrustAll + "\n" +
+                "mXcapDocumentName: " + mXcapDocumentName + "\n" +
+                "mXcapPutElementMime: " + mXcapPutElementMime + "\n";
+    }
+}
+
diff --git a/packages/xcap/src/com/mediatek/xcap/uri/XcapUri.java b/packages/xcap/src/com/mediatek/xcap/uri/XcapUri.java
new file mode 100644
index 00000000000..32b7ef6dfcb
--- /dev/null
+++ b/packages/xcap/src/com/mediatek/xcap/uri/XcapUri.java
@@ -0,0 +1,418 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.client.uri;
+
+import android.os.SystemProperties;
+
+import java.net.URLEncoder;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.charset.Charset;
+
+/**
+ * XcapUri class.
+ */
+public class XcapUri {
+
+    private static final String RESOURCE_SELECTOR_SEPARATOR = "/~~/";
+    private static final char PATH_SEPARATOR = '/';
+
+    private String mXcapRoot = null;
+    private String mDocumentSelector = null;
+    private String mNodeSelector = null;
+
+    // Based on the Concept of XPath
+    // Example: XCAP root / Document Selector / Node Selector
+    // Node Selector
+    // ~~/resource-lists/list%5b@name=%22l1%22%5d
+
+    /**
+     * Constructor.
+     *
+     */
+    public XcapUri() {
+
+    }
+
+    public String getXcapRoot() {
+        return mXcapRoot;
+    }
+
+    /**
+     * set Xcap Root.
+     *
+     * @param xcapRoot XCAP root URI
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setXcapRoot(String xcapRoot) throws IllegalArgumentException {
+        if (xcapRoot.charAt(xcapRoot.length() - 1) != '/') {
+            throw new IllegalArgumentException("xcap root must end with /");
+        }
+        mXcapRoot = xcapRoot;
+        return this;
+    }
+
+    public String getDocumentSelector() {
+        return mDocumentSelector;
+    }
+
+    /**
+     * set document selector.
+     *
+     * @param documentSelector XCAP document selector
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setDocumentSelector(XcapDocumentSelector documentSelector)
+            throws IllegalArgumentException {
+        setDocumentSelector(documentSelector.toString());
+        return this;
+    }
+
+    /**
+     * set document selector.
+     *
+     * @param documentSelector string document selector
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setDocumentSelector(String documentSelector)
+            throws IllegalArgumentException {
+        if (documentSelector.charAt(0) == '/') {
+            throw new IllegalArgumentException("document selector must not start with /");
+        }
+        mDocumentSelector = documentSelector;
+        return this;
+    }
+
+    public String getNodeSelector() {
+        return mNodeSelector;
+    }
+
+    /**
+     * set node selector.
+     *
+     * @param nodeSelector XCAP node selector
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setNodeSelector(XcapNodeSelector nodeSelector)
+            throws IllegalArgumentException {
+        setNodeSelector(nodeSelector.toString());
+        return this;
+    }
+
+    /**
+     * set node selector.
+     *
+     * @param nodeSelector string node selector
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setNodeSelector(String nodeSelector)
+            throws IllegalArgumentException {
+        if (mDocumentSelector.charAt(0) == '/') {
+            throw new IllegalArgumentException("document selector must not start with /");
+        }
+        mNodeSelector = nodeSelector;
+        return this;
+    }
+
+    /**
+     * Convert to URI.
+     *
+     * @return URI
+     * @throws URISyntaxException if URI syntax error
+     */
+    public URI toURI() throws URISyntaxException {
+        final StringBuilder sb = new StringBuilder(mXcapRoot);
+        if ("true".equals(SystemProperties.get("persist.mtk.xcap.rawurl"))) {
+            sb.append(mDocumentSelector);
+            if (mNodeSelector != null) {
+                sb.append(RESOURCE_SELECTOR_SEPARATOR).append(mNodeSelector);
+            }
+        } else {
+            sb.append(mDocumentSelector.replaceAll("\\+", "%2B"));
+            if (mNodeSelector != null) {
+                sb.append(RESOURCE_SELECTOR_SEPARATOR).append(
+                        mNodeSelector.replaceAll("\\+", "%2B"));
+            }
+        }
+
+        return new URI(sb.toString());
+    }
+
+    /**
+     * XcapDocumentSelector class.
+     *
+     */
+    static public class XcapDocumentSelector {
+
+        private static final String XCAP_USER_PATH = "users";
+        private static final String XCAP_GLOBAL_PATH = "global";
+
+        private StringBuilder mDocumentSelector = new StringBuilder();
+        private String mAuid = null;
+        private String mXui = null;
+        private String mDocumentName = null;
+
+        /**
+         * Make XCAP document path.
+         *
+         * @param newSegment segment
+         * @return XcapDocumentSelector
+         */
+        public XcapDocumentSelector queryPath(String newSegment) {
+            if (mDocumentSelector.length() != 0) {
+                mDocumentSelector.append(PATH_SEPARATOR);
+            }
+            mDocumentSelector.append(newSegment);
+            return this;
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param auid application ID
+         * @param xui  XUI
+         * @param documentName document name
+         */
+        public XcapDocumentSelector(String auid, String xui, String documentName) {
+            mAuid = auid;
+            mXui = xui;
+            mDocumentName = documentName;
+
+            this.queryPath(auid).queryPath(XCAP_USER_PATH).queryPath(xui).queryPath(documentName);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param auid application ID
+         * @param documentName document name
+         */
+        public XcapDocumentSelector(String auid, String documentName) {
+            StringBuilder documentSelector = new StringBuilder();
+
+            mAuid = auid;
+            mDocumentName = documentName;
+
+            this.queryPath(auid).queryPath(XCAP_GLOBAL_PATH).queryPath(documentName);
+        }
+
+        /**
+         * Convert to string.
+         *
+         * @return string
+         */
+        public String toString() {
+            return mDocumentSelector.toString();
+        }
+    }
+
+    /**
+     * XcapNodeSelector class.
+     *
+     */
+    static public class XcapNodeSelector {
+        private final StringBuilder mNodeSelector = new StringBuilder();
+
+        /**
+         * Make node path.
+         *
+         * @param elementName XML element name
+         * @return XcapNodeSelector instance
+         */
+        // Select by Element Name
+        public XcapNodeSelector queryByNodeName(String elementName) {
+            if (elementName == null) {
+                return this;
+            }
+
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName);
+            return this;
+        }
+
+        /**
+         * Make attribute path.
+         *
+         * @param attrName XML attribute name
+         * @return XcapNodeSelector instance
+         */
+        // Select by Attribute Name
+        public XcapNodeSelector queryByAttrName(String attrName) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append("@").append(attrName);
+            return this;
+        }
+
+        /**
+         * Make element path with attribute.
+         *
+         * @param elementName XML element name
+         * @param attrName    XML attribute name
+         * @return XcapNodeSelector instance
+         */
+        // Select by Element Name with Attribute
+        public XcapNodeSelector queryByNodeName(String elementName, String attrName) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName);
+            queryByAttrName(attrName);
+            return this;
+        }
+
+        /**
+         * Make element path with attribute name and value.
+         *
+         * @param elementName XML element name
+         * @param attrName    XML attribute name
+         * @param attrValue   XML attribute value
+         * @return XcapNodeSelector instance
+         */
+        // Select by Attribute Name/Value
+        public XcapNodeSelector queryByNodeName(String elementName, String attrName,
+                String attrValue) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName).append("[@").append(attrName).append("=\"")
+                    .append(attrValue).append("\"]");
+            return this;
+        }
+
+        /**
+         * Make path by node name.
+         *
+         * @param elementName XML element name
+         * @param pos         position offset
+         * @return XcapNodeSelector instance
+         */
+        // Positional Selectors
+        public XcapNodeSelector queryByNodeName(String elementName, int pos) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName).append("[").append(pos).append("]");
+            return this;
+        }
+
+        /**
+         * Make path by node name.
+         *
+         * @param elementName XML element name
+         * @param pos         position offset
+         * @param attrName    XML attribute name
+         * @param attrValue   XML attribute value
+         * @return XcapNodeSelector instance
+         */
+        // Positional Selectors
+        public XcapNodeSelector queryByNodeNameWithPos(String elementName, int pos,
+                String attrName, String attrValue) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName).append("[").append(pos).append("]").append("[@")
+                    .append(attrName).append("=\"").append(attrValue).append("\"]");
+            return this;
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param elementName XML element name
+         */
+        public XcapNodeSelector(String elementName) {
+            queryByNodeName(elementName);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param elementName XML element name
+         * @param attrName    XML attribute name
+         */
+        public XcapNodeSelector(String elementName, String attrName) {
+            queryByNodeName(elementName, attrName);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param elementName XML element name
+         * @param attrName    XML attribute name
+         * @param attrValue   XML attribute value
+         */
+        public XcapNodeSelector(String elementName, String attrName, String attrValue) {
+            queryByNodeName(elementName, attrName, attrValue);
+        }
+
+        /**
+         * Convert to string.
+         *
+         * @return string
+         */
+        public String toString() {
+            return mNodeSelector.toString();
+        }
+    }
+
+    /**
+     * Encode path in UTF-8.
+     *
+     * @param path path input
+     * @return path in UTF-8
+     * @throws NullPointerException if null error
+     */
+    public static String encodePath(String path) throws NullPointerException {
+        if (path == null) {
+            throw new NullPointerException("string to encode is null");
+        }
+        return new String(URLEncoder.encode(path));
+    }
+}
diff --git a/packages/xcap/test/XcapTester.java b/packages/xcap/test/XcapTester.java
new file mode 100644
index 00000000000..37e954a1d65
--- /dev/null
+++ b/packages/xcap/test/XcapTester.java
@@ -0,0 +1,290 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.test;
+
+import android.util.Log;
+
+import com.mediatek.xcap.client.XcapClient;
+import com.mediatek.xcap.client.XcapConstants;
+import com.mediatek.xcap.client.uri.XcapUri;
+import com.mediatek.xcap.client.uri.XcapUri.XcapDocumentSelector;
+import com.mediatek.xcap.client.uri.XcapUri.XcapNodeSelector;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.auth.UsernamePasswordCredentials;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * XcapTester class.
+ */
+public class XcapTester {
+    static final private String INITIAL_DOCUMENT =
+            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n" +
+                    "    <resource-lists xmlns=\"urn:ietf:params:xml:ns:resource-lists\">\r\n" +
+                    "        <list name=\"friends\">\r\n" +
+                    "        </list>\r\n" +
+                    "    </resource-lists>\r\n";
+
+    static final private String XCAP_ROOT = "http://172.23.4.42:80/xcap-root/";
+    static final private String TEST_USER = "xcapTest@example.com";
+    static final private String TEST_DOC = "testDoc";
+
+    static final private String TAG = "XcapTester";
+
+    private static void getDoc(XcapClient ra,
+            URI documentURI,
+            UsernamePasswordCredentials credentials) throws IOException {
+
+        HttpResponse response;
+        response = ra.get(documentURI, null);
+
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "response 200, response = " + response.toString());
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+    }
+
+    /**
+     * Test suite.
+     *
+     * @throws IOException if I/O error
+     * @throws URISyntaxException if URI syntax error
+     */
+    static public void syncTest() throws IOException, URISyntaxException {
+
+        /** Put a XML document **/
+        XcapClient ra = new XcapClient();
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials("userName",
+                "password");
+
+        XcapDocumentSelector documentSelector = new XcapDocumentSelector(
+                XcapConstants.AUID_RESOURCE_LISTS, TEST_USER, TEST_DOC);
+        Log.d(TAG, "document selector is " + documentSelector.toString());
+        XcapUri xcapUri = new XcapUri();
+        xcapUri.setXcapRoot(XCAP_ROOT).setDocumentSelector(documentSelector);
+
+        URI documentURI = xcapUri.toURI();
+        HttpResponse response;
+
+        // put the document and get sync response
+        response = ra.put(documentURI, "application/resource-lists+xml", INITIAL_DOCUMENT);
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200
+                    || response.getStatusLine().getStatusCode() == 201) {
+                Log.d("info", "document created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create document in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Get an element node **/
+        XcapNodeSelector elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends");
+        URI elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+
+        // get the document and check content is ok
+        response = ra.get(elementURI, null);
+
+        // check get response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "document retreived in xcap server and content is the expected...");
+                Log.d("info", "sync test suceed :)");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+        // ====================================
+        /** Append an element **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeName("entry");
+
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+        String newFriend = "            <entry uri=\"sip:Seraph@example.com\">\r\n" +
+                "                <display-name>Seraph Huang</display-name>\r\n" +
+                "            </entry>\r\n";
+        response = ra.put(elementURI, "application/xcap-el+xml", newFriend);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 201) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Insert an element by position indiction **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeNameWithPos("entry", 1, "uri", "sip:Johnny@example.com");
+
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+        String newFriend1 = "            <entry uri=\"sip:Johnny@example.com\">\r\n" +
+                "                <display-name>Johnny Shih</display-name>\r\n" +
+                "            </entry>\r\n";
+        response = ra.put(elementURI, "application/xcap-el+xml", newFriend1);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 201) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Modify a node attribute **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeName("entry", 1);
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+        String newFriend2 = "            <entry uri=\"sip:Johnny1@example.com\">\r\n" +
+                "                <display-name>Johnny Shih</display-name>\r\n" +
+                "            </entry>\r\n";
+        response = ra.put(elementURI, "application/xcap-el+xml", newFriend2);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Fetch an attribute **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeName("entry", 1)
+                .queryByAttrName("uri");
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+
+        response = ra.get(elementURI, null);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Delete an element **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeNameWithPos("entry", 1, "uri", "sip:Johnny1@example.com");
+
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+        response = ra.delete(elementURI);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Delete document **/
+        response = ra.delete(documentURI);
+
+        // check get response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "document retreived in xcap server and content is the expected...");
+                Log.d("info", "sync test suceed :)");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        ra.shutdown();
+    }
+}
