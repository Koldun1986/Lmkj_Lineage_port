From 7a970d0accc907a6d7532ec04fa3d5753730aa10 Mon Sep 17 00:00:00 2001
From: vgdn1942 <vgdn1942@gmail.com>
Date: Sun, 10 Dec 2017 16:38:52 +0300
Subject: [PATCH] Add support for disabled SELinux

Change-Id: Ib324c998e2f90148d7f4e00d08098ff4e377115e
---
 adb/daemon/main.cpp       |  2 +-
 debuggerd/debuggerd.cpp   |  6 ++++
 init/Android.mk           |  4 +--
 init/devices.cpp          | 21 ++++++++------
 init/init.cpp             | 39 ++++++++++++++++++--------
 init/property_service.cpp |  6 ++--
 init/service.cpp          | 70 ++++++++++++++++++++++++-----------------------
 7 files changed, 90 insertions(+), 58 deletions(-)

diff --git a/adb/daemon/main.cpp b/adb/daemon/main.cpp
index 726d375..000d21c 100644
--- a/adb/daemon/main.cpp
+++ b/adb/daemon/main.cpp
@@ -143,7 +143,7 @@ static void drop_privileges(int server_port) {
         // minijail_enter() will abort if any priv-dropping step fails.
         minijail_enter(jail.get());
 
-        if (root_seclabel != nullptr) {
+        if ((root_seclabel != nullptr) && (is_selinux_enabled() > 0)) {
             if (selinux_android_setcon(root_seclabel) < 0) {
                 LOG(FATAL) << "Could not set SELinux context";
             }
diff --git a/debuggerd/debuggerd.cpp b/debuggerd/debuggerd.cpp
index 6189a76..d685ff9 100644
--- a/debuggerd/debuggerd.cpp
+++ b/debuggerd/debuggerd.cpp
@@ -128,6 +128,8 @@ static int get_process_info(pid_t tid, pid_t* out_pid, uid_t* out_uid, uid_t* ou
   return fields == 7 ? 0 : -1;
 }
 
+static int selinux_enabled;
+
 /*
  * Corresponds with debugger_action_t enum type in
  * include/cutils/debugger.h.
@@ -158,6 +160,9 @@ static bool selinux_action_allowed(int s, debugger_request_t* request)
   const char *perm;
   bool allowed = false;
 
+  if (selinux_enabled <= 0)
+    return true;
+
   if (request->action <= 0 || request->action >= (sizeof(debuggerd_perms)/sizeof(debuggerd_perms[0]))) {
     ALOGE("SELinux:  No permission defined for debugger action %d", request->action);
     return false;
@@ -922,6 +927,7 @@ static void usage() {
 int main(int argc, char** argv) {
   union selinux_callback cb;
   if (argc == 1) {
+    selinux_enabled = is_selinux_enabled();
     cb.func_audit = audit_callback;
     selinux_set_callback(SELINUX_CB_AUDIT, cb);
     cb.func_log = selinux_log_callback;
diff --git a/init/Android.mk b/init/Android.mk
index 0f5fe1c..94f71e4 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -5,9 +5,9 @@ LOCAL_PATH:= $(call my-dir)
 # --
 
 ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
-init_options += -DALLOW_LOCAL_PROP_OVERRIDE=1 -DALLOW_PERMISSIVE_SELINUX=1
+init_options += -DALLOW_LOCAL_PROP_OVERRIDE=1 -DALLOW_DISABLE_SELINUX=1
 else
-init_options += -DALLOW_LOCAL_PROP_OVERRIDE=0 -DALLOW_PERMISSIVE_SELINUX=0
+init_options += -DALLOW_LOCAL_PROP_OVERRIDE=0 -DALLOW_DISABLE_SELINUX=0
 endif
 
 init_options += -DLOG_UEVENTS=0
diff --git a/init/devices.cpp b/init/devices.cpp
index 29397b1..7b3de76 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -245,12 +245,14 @@ static void make_device(const char *path,
 
     mode = get_device_perm(path, links, &uid, &gid) | (block ? S_IFBLK : S_IFCHR);
 
-    if (selabel_lookup_best_match(sehandle, &secontext, path, links, mode)) {
-        ERROR("Device '%s' not created; cannot find SELinux label (%s)\n",
-                path, strerror(errno));
-        return;
+    if (sehandle) {
+        if (selabel_lookup_best_match(sehandle, &secontext, path, links, mode)) {
+            ERROR("Device '%s' not created; cannot find SELinux label (%s)\n",
+                    path, strerror(errno));
+            return;
+        }
+        setfscreatecon(secontext);
     }
-    setfscreatecon(secontext);
 
     dev = makedev(major, minor);
     /* Temporarily change egid to avoid race condition setting the gid of the
@@ -1028,7 +1030,7 @@ void handle_device_fd()
         struct uevent uevent;
         parse_event(msg, &uevent);
 
-        if (selinux_status_updated() > 0) {
+        if (sehandle && selinux_status_updated() > 0) {
             struct selabel_handle *sehandle2;
             sehandle2 = selinux_android_file_context_handle();
             if (sehandle2) {
@@ -1095,8 +1097,11 @@ static void coldboot(const char *path)
 }
 
 void device_init() {
-    sehandle = selinux_android_file_context_handle();
-    selinux_status_open(true);
+    sehandle = NULL;
+    if (is_selinux_enabled() > 0) {
+        sehandle = selinux_android_file_context_handle();
+        selinux_status_open(true);
+    }
 
     /* is 256K enough? udev uses 16MB! */
     device_fd = uevent_open_socket(256*1024, true);
diff --git a/init/init.cpp b/init/init.cpp
index 7a37059..9318c3e 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -440,13 +440,15 @@ static void selinux_init_all_handles(void)
     sehandle_prop = selinux_android_prop_context_handle();
 }
 
-enum selinux_enforcing_status { SELINUX_PERMISSIVE, SELINUX_ENFORCING };
+enum selinux_enforcing_status { SELINUX_DISABLED, SELINUX_PERMISSIVE, SELINUX_ENFORCING };
 
 static selinux_enforcing_status selinux_status_from_cmdline() {
     selinux_enforcing_status status = SELINUX_ENFORCING;
 
     import_kernel_cmdline(false, [&](const std::string& key, const std::string& value, bool in_qemu) {
-        if (key == "androidboot.selinux" && value == "permissive") {
+        if (key == "androidboot.selinux" && value == "disabled") {
+            status = SELINUX_DISABLED;
+        } else if (key == "androidboot.selinux" && value == "permissive") {
             status = SELINUX_PERMISSIVE;
         }
     });
@@ -454,9 +456,23 @@ static selinux_enforcing_status selinux_status_from_cmdline() {
     return status;
 }
 
+static bool selinux_is_disabled(void)
+{
+    if (ALLOW_DISABLE_SELINUX) {
+        if (access("/sys/fs/selinux", F_OK) != 0) {
+            // SELinux is not compiled into the kernel, or has been disabled
+            // via the kernel command line "selinux=0".
+            return true;
+        }
+        return selinux_status_from_cmdline() == SELINUX_DISABLED;
+    }
+
+    return false;
+}
+
 static bool selinux_is_enforcing(void)
 {
-    if (ALLOW_PERMISSIVE_SELINUX) {
+    if (ALLOW_DISABLE_SELINUX) {
         return selinux_status_from_cmdline() == SELINUX_ENFORCING;
     }
     return true;
@@ -464,6 +480,10 @@ static bool selinux_is_enforcing(void)
 
 int selinux_reload_policy(void)
 {
+    if (selinux_is_disabled()) {
+        return -1;
+    }
+
     INFO("SELinux: Attempting to reload policy files\n");
 
     if (selinux_android_reload_policy() == -1) {
@@ -509,6 +529,10 @@ static void selinux_initialize(bool in_kernel_domain) {
     cb.func_audit = audit_callback;
     selinux_set_callback(SELINUX_CB_AUDIT, cb);
 
+    if (selinux_is_disabled()) {
+        return;
+    }
+
     if (in_kernel_domain) {
         INFO("Loading SELinux policy...\n");
         if (selinux_android_load_policy() < 0) {
@@ -516,15 +540,8 @@ static void selinux_initialize(bool in_kernel_domain) {
             security_failure();
         }
 
-        bool kernel_enforcing = (security_getenforce() == 1);
         bool is_enforcing = selinux_is_enforcing();
-        if (kernel_enforcing != is_enforcing) {
-            if (security_setenforce(is_enforcing)) {
-                ERROR("security_setenforce(%s) failed: %s\n",
-                      is_enforcing ? "true" : "false", strerror(errno));
-                security_failure();
-            }
-        }
+        security_setenforce(is_enforcing);
 
         if (write_file("/sys/fs/selinux/checkreqprot", "0") == -1) {
             security_failure();
diff --git a/init/property_service.cpp b/init/property_service.cpp
index fc14796..f2250b3 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -67,13 +67,15 @@ static int property_set_fd = -1;
 
 void property_init() {
     if (__system_property_area_init()) {
-        ERROR("Failed to initialize property area\n");
-        exit(1);
+        return;
     }
 }
 
 static int check_mac_perms(const char *name, char *sctx, struct ucred *cr)
 {
+    if (is_selinux_enabled() <= 0)
+        return 1;
+
     char *tctx = NULL;
     int result = 0;
     property_audit_data audit_data;
diff --git a/init/service.cpp b/init/service.cpp
index 8127e70..83be986 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -344,44 +344,46 @@ bool Service::Start() {
     }
 
     std::string scon;
-    if (!seclabel_.empty()) {
-        scon = seclabel_;
-    } else {
-        char* mycon = nullptr;
-        char* fcon = nullptr;
+    if (is_selinux_enabled() > 0) {
+        if (!seclabel_.empty()) {
+            scon = seclabel_;
+        } else {
+            char* mycon = nullptr;
+            char* fcon = nullptr;
 
-        INFO("computing context for service '%s'\n", args_[0].c_str());
-        int rc = getcon(&mycon);
-        if (rc < 0) {
-            ERROR("could not get context while starting '%s'\n", name_.c_str());
-            return false;
-        }
+            INFO("computing context for service '%s'\n", args_[0].c_str());
+            int rc = getcon(&mycon);
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", name_.c_str());
+                return false;
+            }
 
-        rc = getfilecon(args_[0].c_str(), &fcon);
-        if (rc < 0) {
-            ERROR("could not get context while starting '%s'\n", name_.c_str());
-            free(mycon);
-            return false;
-        }
+            rc = getfilecon(args_[0].c_str(), &fcon);
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", name_.c_str());
+                free(mycon);
+                return false;
+            }
 
-        char* ret_scon = nullptr;
-        rc = security_compute_create(mycon, fcon, string_to_security_class("process"),
-                                     &ret_scon);
-        if (rc == 0) {
-            scon = ret_scon;
-            free(ret_scon);
-        }
-        if (rc == 0 && scon == mycon) {
-            ERROR("Service %s does not have a SELinux domain defined.\n", name_.c_str());
+            char* ret_scon = nullptr;
+            rc = security_compute_create(mycon, fcon, string_to_security_class("process"),
+                                         &ret_scon);
+            if (rc == 0) {
+                scon = ret_scon;
+                free(ret_scon);
+            }
+            if (rc == 0 && scon == mycon) {
+                ERROR("Service %s does not have a SELinux domain defined.\n", name_.c_str());
+                free(mycon);
+                free(fcon);
+                return false;
+            }
             free(mycon);
             free(fcon);
-            return false;
-        }
-        free(mycon);
-        free(fcon);
-        if (rc < 0) {
-            ERROR("could not get context while starting '%s'\n", name_.c_str());
-            return false;
+            if (rc < 0) {
+                ERROR("could not get context while starting '%s'\n", name_.c_str());
+                return false;
+            }
         }
     }
 
@@ -453,7 +455,7 @@ bool Service::Start() {
             }
         }
         if (!seclabel_.empty()) {
-            if (setexeccon(seclabel_.c_str()) < 0) {
+            if (is_selinux_enabled() > 0 && setexeccon(seclabel_.c_str()) < 0) {
                 ERROR("cannot setexeccon('%s'): %s\n",
                       seclabel_.c_str(), strerror(errno));
                 _exit(127);
-- 
2.7.4

