From 0761c7720d141cad53b78d21e4bc73ce9880af6f Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Sat, 26 Mar 2016 16:11:03 +0800
Subject: [PATCH] mtk: port minimal buildable world phone support for bringup

Change-Id: I34cbae61c60764608dbc5f1ea34f7ca5c0602444
---
 .../internal/telephony/ModemSwitchHandler.java     | 311 +++++++++++++++
 .../internal/telephony/ltedc/svlte/SvlteUtils.java | 233 +++++++++++
 .../internal/telephony/worldphone/IWorldPhone.java | 122 ++++++
 .../internal/telephony/worldphone/WorldMode.java   | 325 ++++++++++++++++
 .../telephony/worldphone/WorldPhoneUtil.java       | 431 +++++++++++++++++++++
 5 files changed, 1422 insertions(+)
 create mode 100755 src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
 create mode 100644 src/java/com/mediatek/internal/telephony/ltedc/svlte/SvlteUtils.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
 create mode 100644 src/java/com/mediatek/internal/telephony/worldphone/WorldMode.java
 create mode 100755 src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java

diff --git a/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java b/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
new file mode 100755
index 0000000000..c5ceca5c5b
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/ModemSwitchHandler.java
@@ -0,0 +1,311 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.SystemProperties;
+import android.telephony.Rlog;
+
+import com.android.internal.telephony.CommandsInterface;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvltePhoneProxy;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+
+
+public class ModemSwitchHandler {
+    private static final String LOG_TAG = "PHONE";
+
+    /** @internal */
+    public static final int MD_TYPE_UNKNOWN = 0;
+    /** @internal */
+    public static final int MD_TYPE_WG      = 3;
+    /** @internal */
+    public static final int MD_TYPE_TG      = 4;
+    /** @internal */
+    public static final int MD_TYPE_LWG     = 5;
+    /** @internal */
+    public static final int MD_TYPE_LTG     = 6;
+    /** @internal */
+    public static final int MD_TYPE_FDD     = 100;
+    /** @internal */
+    public static final int MD_TYPE_TDD     = 101;
+    private static final int PROJECT_SIM_NUM = WorldPhoneUtil.getProjectSimNum();
+
+    private static int sCurrentModemType = getActiveModemType();
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+    private static Context sContext = null;
+    private static CommandsInterface[] sCi = new CommandsInterface[PROJECT_SIM_NUM];
+
+    //C2K world phone
+    private static Phone[] sSvlteLtePhone = new Phone[PROJECT_SIM_NUM];
+    private static CommandsInterface[] sSvlteLteCi = new CommandsInterface[PROJECT_SIM_NUM];
+
+    public ModemSwitchHandler() {
+        logd("Constructor invoked");
+        logd("Init modem type: " + sCurrentModemType);
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            //C2K world phone - start
+            sSvlteLtePhone[i] = null;
+            sSvlteLteCi[i] = null;
+            /*
+            if (WorldPhoneUtil.isCdmaLteDcSupport() &&
+                    sProxyPhones[i] instanceof SvltePhoneProxy) {
+                logd("Phone " + i + " is SVLTE case so get lte phone directly");
+                sSvlteLtePhone[i] = ((SvltePhoneProxy) sProxyPhones[i]).getLtePhone();
+                sSvlteLteCi[i] = ((PhoneBase) sSvlteLtePhone[i]).mCi;
+            }
+            */
+            //C2K world phone - end
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+            sCi[i] = ((PhoneBase) sActivePhones[i]).mCi;
+        }
+        if (PhoneFactory.getDefaultPhone() != null) {
+            sContext = PhoneFactory.getDefaultPhone().getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+    }
+
+    /**
+     * Trigger TRM to switch modem type
+     * @param modemType 3 : switch to WG(MD_TYPE_WG)
+     *                  4 : switch to TG(MD_TYPE_TG)
+     *                  5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *                  6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void switchModem(int modemType) {
+        int protocolSim = WorldPhoneUtil.getMajorSim();
+        CommandsInterface ci = null;
+        logd("protocolSim: " + protocolSim);
+        if (protocolSim >= PhoneConstants.SIM_ID_1 && protocolSim <= PhoneConstants.SIM_ID_4) {
+            //C2K world phone - start
+            ci = getActiveCi(protocolSim);
+            if (ci != null) {
+                switchModem(ci, modemType);
+                //switchModem(sCi[protocolSim], modemType);
+            }
+            //C2K world phone - end
+        } else {
+            //C2K world phone - start
+            ci = getActiveCi(PhoneConstants.SIM_ID_1);
+            if (ci != null) {
+                switchModem(ci, modemType);
+                //switchModem(sCi[PhoneConstants.SIM_ID_1], modemType);
+            }
+            //C2K world phone - end
+        }
+    }
+
+    /**
+     * Trigger TRM to switch modem type with desinated RIL instance
+     * @param modemType 3 : switch to WG(MD_TYPE_WG)
+     *                  4 : switch to TG(MD_TYPE_TG)
+     *                  5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *                  6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void switchModem(CommandsInterface ci, int modemType) {
+        logd("[switchModem]");
+        if (modemType == sCurrentModemType) {
+            if (modemType == MD_TYPE_WG) {
+                logd("Already in WG modem");
+            } else if (modemType == MD_TYPE_TG) {
+                logd("Already in TG modem");
+            } else if (modemType == MD_TYPE_LWG) {
+                logd("Already in FDD CSFB modem");
+            } else if (modemType == MD_TYPE_LTG) {
+                logd("Already in TDD CSFB modem");
+            }
+            return;
+        }
+        if (ci.getRadioState() == CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+            logd("Radio unavailable, can not switch modem");
+            return;
+        }
+        if (modemType == MD_TYPE_WG) {
+            ci.setTrm(9, null);
+        } else if (modemType == MD_TYPE_TG) {
+            ci.setTrm(10, null);
+        } else if (modemType == MD_TYPE_LWG) {
+            ci.setTrm(11, null);
+        } else if (modemType == MD_TYPE_LTG) {
+            ci.setTrm(12, null);
+        } else {
+            logd("Invalid modem type:" + modemType);
+            return;
+        }
+        // Update sCurrentModemType variable & set ril.active.md system property
+        setActiveModemType(modemType);
+
+        // Broadcast modem switch notification
+        logd("Broadcast intent ACTION_MD_TYPE_CHANGE");
+        Intent intent = new Intent(TelephonyIntents.ACTION_MD_TYPE_CHANGE);
+        intent.putExtra(TelephonyIntents.EXTRA_MD_TYPE, modemType);
+        sContext.sendBroadcast(intent);
+    }
+
+    /**
+     * Trigger CCCI to reload modem bin
+     * @param modemType 3 : reload WG(MD_TYPE_WG)
+     *                  4 : reload TG(MD_TYPE_TG)
+     *                  5 : reload FDD CSFB(MD_TYPE_LWG)
+     *                  6 : reload TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void reloadModem(int modemType) {
+        int majorSim = WorldPhoneUtil.getMajorSim();
+        CommandsInterface ci = null;
+        if (majorSim >= PhoneConstants.SIM_ID_1 && majorSim <= PhoneConstants.SIM_ID_4) {
+            //C2K world phone - start
+            ci = getActiveCi(majorSim);
+            if (ci != null) {
+                reloadModem(ci, modemType);
+                //reloadModem(sCi[majorSim], modemType);
+            }
+            //C2K world phone - end
+        } else {
+            //C2K world phone - start
+            ci = getActiveCi(PhoneConstants.SIM_ID_1);
+            if (ci != null) {
+                reloadModem(ci, modemType);
+                //reloadModem(sCi[PhoneConstants.SIM_ID_1], modemType);
+            }
+            //C2K world phone - end
+        }
+    }
+
+    /**
+     * Trigger CCCI to reload modem bin with desinated RIL instance
+     * @param modemType 3 : reload WG(MD_TYPE_WG)
+     *                  4 : reload TG(MD_TYPE_TG)
+     *                  5 : reload FDD CSFB(MD_TYPE_LWG)
+     *                  6 : reload TDD CSFB(MD_TYPE_LTG)
+     */
+    public static void reloadModem(CommandsInterface ci, int modemType) {
+        logd("[reloadModem]");
+        if (ci.getRadioState() == CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+            logd("Radio unavailable, can not reload modem");
+            return;
+        }
+        if (modemType == MD_TYPE_WG) {
+            ci.setTrm(14, null);
+        } else if (modemType == MD_TYPE_TG) {
+            ci.setTrm(15, null);
+        } else if (modemType == MD_TYPE_LWG) {
+            ci.setTrm(16, null);
+        } else if (modemType == MD_TYPE_LTG) {
+            ci.setTrm(17, null);
+        } else {
+            logd("Invalid modem type:" + modemType);
+        }
+    }
+
+    /**
+     * Returns current modem type
+     * @internal
+     * @return 0 : modem type is unknown
+     *         3 : switch to WG(MD_TYPE_WG)
+     *         4 : switch to TG(MD_TYPE_TG)
+     *         5 : switch to FDD CSFB(MD_TYPE_LWG)
+     *         6 : switch to TDD CSFB(MD_TYPE_LTG)
+     */
+    public static int getActiveModemType() {
+        sCurrentModemType = Integer.valueOf(
+                SystemProperties.get(TelephonyProperties.PROPERTY_ACTIVE_MD, Integer.toString(MD_TYPE_UNKNOWN)));
+
+        return sCurrentModemType;
+    }
+
+    public static void setActiveModemType(int modemType) {
+        SystemProperties.set(TelephonyProperties.PROPERTY_ACTIVE_MD, Integer.toString(modemType));
+        sCurrentModemType = modemType;
+        logd("[setActiveModemType] " + modemToString(sCurrentModemType));
+    }
+
+    public static String modemToString(int modemType) {
+        String modemString;
+        if (modemType == MD_TYPE_WG) {
+            modemString = "WG";
+        } else if (modemType == MD_TYPE_TG) {
+            modemString = "TG";
+        } else if (modemType == MD_TYPE_LWG) {
+            modemString = "FDD CSFB";
+        } else if (modemType == MD_TYPE_LTG) {
+            modemString = "TDD CSFB";
+        } else if (modemType == MD_TYPE_UNKNOWN) {
+            modemString = "UNKNOWN";
+        } else {
+            modemString = "Invalid modem type";
+        }
+
+        return modemString;
+    }
+
+    private static CommandsInterface getActiveCi(int slotId) {
+        int radioTechModeForWp = WorldPhoneUtil.getRadioTechModeForWp();
+        logd("[getActiveCi]: slotId" + slotId +
+                " radioTechModeForWp=" + radioTechModeForWp);
+
+        if (WorldPhoneUtil.isCdmaLteDcSupport()) {
+            // MTK TODO
+            /*
+            if (sProxyPhones[slotId] instanceof SvltePhoneProxy) {
+                logd("[getActiveCi]: return sSvlteLteCi");
+                return sSvlteLteCi[slotId];
+            } else {
+                logd("[getActiveCi]: return sCi");
+                return sCi[slotId];
+            }
+            */
+            logd("[getActiveCi]: xen0n: CDMA support TODO!");
+            return sCi[slotId];
+        } else {
+            logd("[getActiveCi]: return sCi");
+            return sCi[slotId];
+        }
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[MSH]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/ltedc/svlte/SvlteUtils.java b/src/java/com/mediatek/internal/telephony/ltedc/svlte/SvlteUtils.java
new file mode 100644
index 0000000000..5a7a58dbd5
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/ltedc/svlte/SvlteUtils.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony.ltedc.svlte;
+
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+
+/**
+ * Provide SVLTE sub id, phone id get, check, convert and so on.
+ */
+
+public class SvlteUtils {
+    public static final String LOG_TAG = "SvlteUtils";
+
+     /**
+         * Check if subId is lte dc sub id.
+         * @param subId sub id
+         * @return true subId is lte dc sub id
+         */
+    public static boolean isLteDcSubId(int subId) {
+        return (subId == SubscriptionManager.LTE_DC_SUB_ID_1)
+            || (subId == SubscriptionManager.LTE_DC_SUB_ID_2);
+    }
+
+     /**
+         * Get the lte sub id by slot id.
+         * @param slotId slot id
+         * @return Lte sub`s id
+         */
+    public static int getLteDcSubId(int slotId) {
+        if (slotId == PhoneConstants.SIM_ID_1) {
+            return SubscriptionManager.LTE_DC_SUB_ID_1;
+        } else if (slotId == PhoneConstants.SIM_ID_2) {
+            return SubscriptionManager.LTE_DC_SUB_ID_2;
+        } else {
+            return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+        }
+    }
+
+     /**
+         * Check if phoneId is lte dc phone id.
+         * @param phoneId phone id
+         * @return true phoneId is lte dc phone id
+         */
+     public static boolean isLteDcPhoneId(int phoneId) {
+        return (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_1)
+            || (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_2);
+     }
+
+      /**
+         * Get the lte phone id by slot id.
+         * @param slotId slot id
+         * @return Lte phone`s id
+         */
+     public static int getLteDcPhoneId(int slotId) {
+         if (slotId == PhoneConstants.SIM_ID_1) {
+             return SubscriptionManager.LTE_DC_PHONE_ID_1;
+         } else if (slotId == PhoneConstants.SIM_ID_2) {
+             return SubscriptionManager.LTE_DC_PHONE_ID_2;
+         } else {
+             return SubscriptionManager.INVALID_PHONE_INDEX;
+         }
+     }
+
+    /**
+       * Get slot id by lte dc phone id.
+       * @param phoneId lte dc phone id
+       * @return slot id of lte dc phone
+       */
+    public static int getSlotId(int phoneId) {
+         int slotId = phoneId;
+         if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_1) {
+             slotId = PhoneConstants.SIM_ID_1;
+         } else if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_2) {
+             slotId = PhoneConstants.SIM_ID_2;
+         }
+         return slotId;
+    }
+
+    /**
+       * Get slot id by lte dc sub id.
+       * @param subId lte dc phone id
+       * @return slot id of lte dc phone
+       */
+    public static int getSlotIdbySubId(int subId) {
+         int slotId = SubscriptionManager.INVALID_SIM_SLOT_INDEX;
+         if (subId == SubscriptionManager.LTE_DC_SUB_ID_1) {
+             slotId = PhoneConstants.SIM_ID_1;
+         } else if (subId == SubscriptionManager.LTE_DC_SUB_ID_2) {
+             slotId = PhoneConstants.SIM_ID_2;
+         } else {
+             slotId = SubscriptionManager.getSlotId(subId);
+         }
+         return slotId;
+    }
+
+    /**
+       * Check if phone id is validate phone id in svlte.
+       * @param phoneId  phone id that will be check
+       * @return check result
+       */
+    public static boolean isValidPhoneId(int phoneId) {
+        return ((phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount())
+                   || isLteDcPhoneId(phoneId));
+    }
+
+    /**
+       * Check if slot id is validate slot id in svlte.
+       * @param slotId slot id that will be check
+       * @return check result
+       */
+    public static boolean isValidateSlotId(int slotId) {
+        return (slotId >= 0 && slotId < TelephonyManager.getDefault().getSimCount());
+    }
+
+    // MTK TODO
+    /**
+       * Get SvltePhoneProxy of phoneId.
+       * @param phoneId phone id
+       * @return SvltePhoneProxy of phoneId
+       */
+    /*
+    public static SvltePhoneProxy getSvltePhoneProxy(int phoneId) {
+        if (PhoneFactory.getPhone(phoneId) instanceof SvltePhoneProxy) {
+            return (SvltePhoneProxy) (PhoneFactory.getPhone(phoneId));
+        } else {
+            throw new IllegalStateException("Not SvltePhoneProxy!");
+        }
+    }
+    */
+
+    /**
+        * Check if phoneId is active svlte mode.
+        * @param phoneId Phone id
+        * @return true if phoneId is active svlte mode
+        */
+    public static boolean isActiveSvlteMode(int phoneId) {
+        // MTK TODO
+        // return SvlteModeController.getActiveSvlteModeSlotId() == getSlotId(phoneId);
+        return false;
+    }
+
+    /**
+        * Check if phone is active svlte mode.
+        * @param phone Phone
+        * @return true if phone is active svlte mode
+        */
+    public static boolean isActiveSvlteMode(Phone phone) {
+        return isActiveSvlteMode(phone.getPhoneId());
+    }
+
+    /**
+        * Get phone id of SVLTE active phone.
+        * @param phoneId Phone id
+        * @return  phone id of SVLTE phone
+        */
+    public static int getSvltePhoneIdByPhoneId(int phoneId) {
+        int curPhoneId = phoneId;
+        if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_1) {
+            curPhoneId = PhoneConstants.SIM_ID_1;
+        } else if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_2) {
+            curPhoneId = PhoneConstants.SIM_ID_2;
+        }
+        return curPhoneId;
+    }
+
+   /**
+       * Get phone id of SVLTE active phone.
+       * @param phone Phone
+       * @return  phone id of SVLTE phone
+       */
+    public static int getSvltePhoneIdByPhone(Phone phone) {
+        return getSvltePhoneIdByPhoneId(phone.getPhoneId());
+    }
+
+   /**
+       * Get sub id of SVLTE active phone.
+       * @param subId Sub id
+       * @return sub id of SVLTE phone
+       */
+    public static int getSvlteSubIdBySubId(int subId) {
+        if (isLteDcSubId(subId)) {
+            int[] subIds = SubscriptionManager.getSubId(getSlotIdbySubId(subId));
+            if (subIds != null && subIds.length > 0) {
+                return subIds[0];
+            }
+        }
+        return subId;
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, msg);
+    }
+
+    /**
+     * Get the cdma_rat_mode key.
+     * @param subId sub id
+     * @return the cdma_rat_mode key
+     */
+    public static String getCdmaRatModeKey(int subId) {
+        // MTK TODO
+        /*
+        if (("OP09").equals(SystemProperties.get("ro.operator.optr", "OM"))) {
+            return Settings.Global.LTE_ON_CDMA_RAT_MODE;
+        } else {
+            return Settings.Global.LTE_ON_CDMA_RAT_MODE + subId;
+        }
+        */
+        return null;
+    }
+}
+
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java b/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
new file mode 100755
index 0000000000..e5cd7416cb
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/IWorldPhone.java
@@ -0,0 +1,122 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+public interface IWorldPhone {
+    public static final String LOG_TAG = "PHONE";
+
+    public static final int POLICY_OM       = 0;
+    public static final int POLICY_OP01     = 1;
+
+    static final int SELECTION_MODE_MANUAL = 0;
+    static final int SELECTION_MODE_AUTO   = 1;
+
+    static final int UNKNOWN_USER = 0;
+    static final int TYPE1_USER   = 1;
+    static final int TYPE2_USER   = 2;
+    static final int TYPE3_USER   = 3;
+
+    static final int REGION_UNKNOWN  = 0;
+    static final int REGION_DOMESTIC = 1;
+    static final int REGION_FOREIGN  = 2;
+
+    static final int EVENT_RADIO_ON_1 = 0;
+    static final int EVENT_RADIO_ON_2 = 1;
+    static final int EVENT_REG_PLMN_CHANGED_1 = 10;
+    static final int EVENT_REG_PLMN_CHANGED_2 = 11;
+    static final int EVENT_REG_SUSPENDED_1    = 30;
+    static final int EVENT_REG_SUSPENDED_2    = 31;
+    static final int EVENT_STORE_MODEM_TYPE   = 40;
+    static final int EVENT_QUERY_MODEM_TYPE   = 50;
+    static final int EVENT_INVALID_SIM_NOTIFY_1 = 60;
+    static final int EVENT_INVALID_SIM_NOTIFY_2 = 61;
+    static final int EVENT_RESUME_CAMPING       = 70;   //[ALPS01974750]
+
+    //C2K world phone - start
+    static final int EVENT_RADIO_ON_SVLTE_1 = 1000;
+    static final int EVENT_RADIO_ON_SVLTE_2 = 1001;
+    static final int EVENT_REG_PLMN_CHANGED_SVLTE_1 = 1010;
+    static final int EVENT_REG_PLMN_CHANGED_SVLTE_2 = 1011;
+    static final int EVENT_REG_SUSPENDED_SVLTE_1    = 1030;
+    static final int EVENT_REG_SUSPENDED_SVLTE_2    = 1031;
+    static final int EVENT_INVALID_SIM_NOTIFY_SVLTE_1 = 1040;
+    static final int EVENT_INVALID_SIM_NOTIFY_SVLTE_2 = 1041;
+    static final int EVENT_WP_CARD_TYPE_READY         = 1050;  //[ALPS02045100]
+    static final int EVENT_WP_GMSS_RAT_CHANGED_1      = 1060;  //[ALPS02156732]
+    static final int EVENT_WP_GMSS_RAT_CHANGED_2      = 1061;  //[ALPS02156732]
+    //C2K world phone - end
+
+    static final int DEFAULT_MAJOR_SIM    = 0;
+    static final int MAJOR_CAPABILITY_OFF = -1;
+    static final int AUTO_SWITCH_OFF      = -98;
+    static final int MAJOR_SIM_UNKNOWN    = -99;
+
+    static final int CAMP_ON_NOT_DENIED                     = 0;
+    static final int CAMP_ON_DENY_REASON_UNKNOWN            = 1;
+    static final int CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD = 2;
+    static final int CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD = 3;
+    static final int CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD    = 4;
+
+    static final int ICC_CARD_TYPE_UNKNOWN = 0;
+    static final int ICC_CARD_TYPE_SIM     = 1;
+    static final int ICC_CARD_TYPE_USIM    = 2;
+
+    //switch modem cause type
+    static final int CAUSE_TYPE_PLMN_CHANGE = 0;
+    static final int CAUSE_TYPE_OOS   = 1;
+    static final int CAUSE_TYPE_OTHERS   = 255; //default value, EM, SIM switch,CU/CT card etc
+
+    //C2K world phone
+    static final int RADIO_TECH_MODE_FOR_WP_UNKNOWN = 0;
+    static final int RADIO_TECH_MODE_FOR_WP_CSFB  = 1;
+    static final int RADIO_TECH_MODE_FOR_WP_SVLTE = 2;
+
+    static final String NO_OP = "OM";
+    static final String ACTION_SHUTDOWN_IPO = "android.intent.action.ACTION_SHUTDOWN_IPO";
+    static final String ACTION_ADB_SWITCH_MODEM = "android.intent.action.ACTION_ADB_SWITCH_MODEM";
+    static final String PROPERTY_SWITCH_MODEM_CAUSE_TYPE = "ril.switch.modem.cause.type";
+
+    //[ALPS02302039]
+    static final String ACTION_SAP_CONNECTION_STATE_CHANGED =
+        "android.bluetooth.sap.profile.action.CONNECTION_STATE_CHANGED";
+
+    //For Test
+    static final String ACTION_TEST_WORLDPHONE = "android.intent.action.ACTION_TEST_WORLDPHOE";
+    static final String EXTRA_FAKE_USER_TYPE = "FAKE_USER_TYPE";
+    static final String EXTRA_FAKE_REGION = "EXTRA_FAKE_REGION";
+
+    public void setModemSelectionMode(int mode, int modemType);
+    public void notifyRadioCapabilityChange(int capailitySimId);
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldMode.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldMode.java
new file mode 100644
index 0000000000..f9708eaa5f
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldMode.java
@@ -0,0 +1,325 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony.worldphone;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemProperties;
+import android.telephony.Rlog;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+
+public class WorldMode extends Handler{
+    private static final String LOG_TAG = "PHONE";
+
+    public static final int MD_WORLD_MODE_UNKNOWN = 0;
+    public static final int MD_WORLD_MODE_LTG     = 8;   //uLTG
+    public static final int MD_WORLD_MODE_LWG     = 9;   //uLWG
+    public static final int MD_WORLD_MODE_LWTG    = 10;  //uLWTG
+    public static final int MD_WORLD_MODE_LWCG    = 11;  //uLWCG
+    public static final int MD_WORLD_MODE_LWCTG   = 12;  //uLWTCG(Auto mode)
+    public static final int MD_WORLD_MODE_LTTG    = 13;  //LtTG
+    public static final int MD_WORLD_MODE_LFWG    = 14;  //LfWG
+
+    public static final int MD_WM_CHANGED_UNKNOWN = -1;
+    public static final int MD_WM_CHANGED_START   = 0;
+    public static final int MD_WM_CHANGED_END     = 1;
+
+    static final int EVENT_RADIO_ON_1 = 1;
+    static final int EVENT_RADIO_ON_2 = 2;
+
+    static final String ACTION_ADB_SWITCH_WORLD_MODE =
+               "android.intent.action.ACTION_ADB_SWITCH_WORLD_MODE";
+    static final String EXTRA_WORLDMODE = "worldMode";
+
+    /** The singleton instance. */
+    private static WorldMode sInstance;
+
+    private static final int PROJECT_SIM_NUM = WorldPhoneUtil.getProjectSimNum();
+    private static int sCurrentWorldMode = updateCurrentWorldMode();
+    private static int sActiveWorldMode = MD_WORLD_MODE_UNKNOWN;
+    private static boolean sSwitchingState = false;
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+    private static Context sContext = null;
+    private static CommandsInterface[] sCi = new CommandsInterface[PROJECT_SIM_NUM];
+
+    public WorldMode() {
+        logd("Constructor invoked");
+        logd("Init world mode: " + sCurrentWorldMode);
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+            sCi[i] = ((PhoneBase) sActivePhones[i]).mCi;
+            sCi[i].registerForOn(this, EVENT_RADIO_ON_1 + i, null);
+        }
+
+        IntentFilter intentFilter = new IntentFilter(TelephonyIntents.ACTION_WORLD_MODE_CHANGED);
+        intentFilter.addAction(ACTION_ADB_SWITCH_WORLD_MODE);
+
+        if (PhoneFactory.getDefaultPhone() != null) {
+            sContext = PhoneFactory.getDefaultPhone().getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+        sContext.registerReceiver(mWorldModeReceiver, intentFilter);
+    }
+
+    /**
+     * Initialize the singleton WorldMode instance.
+     * This is only done once, at startup, from PhoneFactory.makeDefaultPhone().
+     */
+    public static void init() {
+        synchronized (WorldMode.class) {
+            if (sInstance == null) {
+                sInstance = new WorldMode();
+            } else {
+                logd("init() called multiple times!  sInstance = " + sInstance);
+            }
+        }
+    }
+
+    private final BroadcastReceiver mWorldModeReceiver = new  BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            logd("[Receiver]+");
+            String action = intent.getAction();
+            logd("Action: " + action);
+            int wmState = MD_WM_CHANGED_UNKNOWN;
+
+            if (TelephonyIntents.ACTION_WORLD_MODE_CHANGED.equals(action)) {
+                wmState = intent.getIntExtra(
+                        TelephonyIntents.EXTRA_WORLD_MODE_CHANGE_STATE, MD_WM_CHANGED_UNKNOWN);
+                logd("wmState: " + wmState);
+                if (wmState == MD_WM_CHANGED_END) {
+                    sCurrentWorldMode = updateCurrentWorldMode();
+                }
+            } else if (ACTION_ADB_SWITCH_WORLD_MODE.equals(action)){
+                int toMode = intent.getIntExtra(
+                        EXTRA_WORLDMODE, MD_WORLD_MODE_UNKNOWN);
+                logd("toModem: " + toMode);
+                if (toMode == MD_WORLD_MODE_LTG
+                        || toMode == MD_WORLD_MODE_LWG
+                        || toMode == MD_WORLD_MODE_LWTG
+                        || toMode == MD_WORLD_MODE_LTTG) {
+                    setWorldMode(toMode);
+                }
+            }
+            logd("[Receiver]-");
+        }
+    };
+
+    public void handleMessage(Message msg) {
+        AsyncResult ar = (AsyncResult) msg.obj;
+        int protocolSim = WorldPhoneUtil.getMajorSim();
+        switch (msg.what) {
+            case EVENT_RADIO_ON_1:
+                logd("handleMessage : <EVENT_RADIO_ON_1>");
+                protocolSim = WorldPhoneUtil.getMajorSim();
+                if (protocolSim == PhoneConstants.SIM_ID_1) {
+                    sCurrentWorldMode = updateCurrentWorldMode();
+                }
+                break;
+            case EVENT_RADIO_ON_2:
+                logd("handleMessage : <EVENT_RADIO_ON_2>");
+                protocolSim = WorldPhoneUtil.getMajorSim();
+                if (protocolSim == PhoneConstants.SIM_ID_2) {
+                    sCurrentWorldMode = updateCurrentWorldMode();
+                }
+                break;
+            default:
+                logd("Unknown msg:" + msg.what);
+        }
+    }
+
+    /**
+     * Trigger RILD to switch world mode
+     * @param worldMode 0 : world mode is unknown
+     *                  8 : uTLG (MD_WORLD_MODE_LTG)
+     *                  9 : uLWG (MD_WORLD_MODE_LWG)
+     *                  10 : uLWTG (MD_WORLD_MODE_LWTG)
+     *                  11 : uLWCG (MD_WORLD_MODE_LWCG)
+     *                  12 : uLWTCG (MD_WORLD_MODE_LWCTG)
+     *                  13 : LtTG (MD_WORLD_MODE_LTTG)
+     *                  14 : LfWG (MD_WORLD_MODE_LFWG)
+     */
+    public static void setWorldMode(int worldMode) {
+        int protocolSim = WorldPhoneUtil.getMajorSim();
+        logd("[setWorldMode]protocolSim: " + protocolSim);
+        if (protocolSim >= PhoneConstants.SIM_ID_1 &&
+                protocolSim <= PhoneConstants.SIM_ID_4) {
+            setWorldMode(sCi[protocolSim], worldMode);
+        } else {
+            setWorldMode(sCi[PhoneConstants.SIM_ID_1], worldMode);
+        }
+    }
+
+    /**
+     * Trigger RILD to switch world mode with desinated RIL instance
+     * @param worldMode 0 : world mode is unknown
+     *                  8 : uTLG (MD_WORLD_MODE_LTG)
+     *                  9 : uLWG (MD_WORLD_MODE_LWG)
+     *                  10 : uLWTG (MD_WORLD_MODE_LWTG)
+     *                  11 : uLWCG (MD_WORLD_MODE_LWCG)
+     *                  12 : uLWTCG (MD_WORLD_MODE_LWCTG)
+     *                  13 : LtTG (MD_WORLD_MODE_LTTG)
+     *                  14 : LfWG (MD_WORLD_MODE_LFWG)
+     */
+    private static void setWorldMode(CommandsInterface ci, int worldMode) {
+        logd("[setWorldMode] worldMode=" + worldMode);
+        if (worldMode == sCurrentWorldMode) {
+            if (worldMode == MD_WORLD_MODE_LTG) {
+                logd("Already in uTLG mode");
+            } else if (worldMode == MD_WORLD_MODE_LWG) {
+                logd("Already in uLWG mode");
+            } else if (worldMode == MD_WORLD_MODE_LWTG) {
+                logd("Already in uLWTG mode");
+            } else if (worldMode == MD_WORLD_MODE_LWCG) {
+                logd("Already in uLWCG mode");
+            } else if (worldMode == MD_WORLD_MODE_LWCTG) {
+                logd("Already in uLWTCG mode");
+            } else if (worldMode == MD_WORLD_MODE_LTTG) {
+                logd("Already in LtTG mode");
+            } else if (worldMode == MD_WORLD_MODE_LFWG) {
+                logd("Already in LfWG mode");
+            }
+            return;
+        }
+        if (ci.getRadioState() ==
+                CommandsInterface.RadioState.RADIO_UNAVAILABLE) {
+            logd("Radio unavailable, can not switch world mode");
+            return;
+        }
+        if ((worldMode >= MD_WORLD_MODE_LTG) &&
+                (worldMode <= MD_WORLD_MODE_LFWG)){
+            ci.reloadModemType(worldMode, null);
+            ci.storeModemType(worldMode, null);
+            ci.setTrm(2, null);
+        } else {
+            logd("Invalid world mode:" + worldMode);
+            return;
+        }
+    }
+
+    /**
+     * Returns modem world mode
+     *
+     * @return 0 : world mode is unknown
+     *         8 : uTLG (MD_WORLD_MODE_LTG)
+     *         9 : uLWG (MD_WORLD_MODE_LWG)
+     *         10 : uLWTG (MD_WORLD_MODE_LWTG)
+     *         11 : uLWCG (MD_WORLD_MODE_LWCG)
+     *         12 : uLWTCG (MD_WORLD_MODE_LWCTG)
+     *         13 : LtTG (MD_WORLD_MODE_LTTG)
+     *         14 : LfWG (MD_WORLD_MODE_LFWG)
+     */
+    public static int getWorldMode() {
+        logd("getWorldMode=" + WorldModeToString(sCurrentWorldMode));
+        return sCurrentWorldMode;
+    }
+
+    /**
+     * Returns modem world mode
+     *
+     * @return 0 : world mode is unknown
+     *         8 : uTLG (MD_WORLD_MODE_LTG)
+     *         9 : uLWG (MD_WORLD_MODE_LWG)
+     *         10 : uLWTG (MD_WORLD_MODE_LWTG)
+     *         11 : uLWCG (MD_WORLD_MODE_LWCG)
+     *         12 : uLWTCG (MD_WORLD_MODE_LWCTG)
+     *         13 : LtTG (MD_WORLD_MODE_LTTG)
+     *         14 : LfWG (MD_WORLD_MODE_LFWG)
+     */
+    private static int updateCurrentWorldMode() {
+        sCurrentWorldMode = Integer.valueOf(
+                SystemProperties.get(TelephonyProperties.PROPERTY_ACTIVE_MD,
+                Integer.toString(MD_WORLD_MODE_UNKNOWN)));
+        logd("updateCurrentWorldMode=" + WorldModeToString(sCurrentWorldMode));
+        return sCurrentWorldMode;
+    }
+
+    public static void updateSwitchingState(boolean isSwitching){
+        sSwitchingState = isSwitching;
+        logd("updateSwitchingState=" + sSwitchingState);
+    }
+
+    public static boolean isWorldModeSwitching(){
+        if (sSwitchingState){
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public static String WorldModeToString(int worldMode) {
+        String worldModeString;
+        if (worldMode == MD_WORLD_MODE_LTG) {
+            worldModeString = "uTLG";
+        } else if (worldMode == MD_WORLD_MODE_LWG) {
+            worldModeString = "uLWG";
+        } else if (worldMode == MD_WORLD_MODE_LWTG) {
+            worldModeString = "uLWTG";
+        } else if (worldMode == MD_WORLD_MODE_LWCG) {
+            worldModeString = "uLWCG";
+        } else if (worldMode == MD_WORLD_MODE_LWCTG) {
+            worldModeString = "uLWTCG";
+        } else if (worldMode == MD_WORLD_MODE_LTTG) {
+            worldModeString = "LtTG";
+        } else if (worldMode == MD_WORLD_MODE_LFWG) {
+            worldModeString = "LfWG";
+        } else {
+            worldModeString = "Invalid world mode";
+        }
+
+        return worldModeString;
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WorldMode]" + msg);
+    }
+}
diff --git a/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java
new file mode 100755
index 0000000000..5cec9e36e6
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/worldphone/WorldPhoneUtil.java
@@ -0,0 +1,431 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony.worldphone;
+
+import android.content.Context;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.ProxyController;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+import com.mediatek.internal.telephony.ModemSwitchHandler;
+import com.mediatek.internal.telephony.worldphone.WorldMode;
+
+/**
+ *@hide
+ */
+public class WorldPhoneUtil implements IWorldPhone {
+
+    public static final int UTRAN_DIVISION_DUPLEX_MODE_UNKNOWN = 0;
+    public static final int UTRAN_DIVISION_DUPLEX_MODE_FDD = 1;
+    public static final int UTRAN_DIVISION_DUPLEX_MODE_TDD = 2;
+
+    private static final int ACTIVE_MD_TYPE_UNKNOWN = 0;
+    private static final int ACTIVE_MD_TYPE_WG   = 1;//3G(WCDMA)+2G(GSM)
+    private static final int ACTIVE_MD_TYPE_TG   = 2;//3G(TDS-CDMA)+2G(GSM)
+    private static final int ACTIVE_MD_TYPE_LWG  = 3;//4G(TDD-LTE+FDD-LTE)+3G(WCDMA)+2G(GSM)
+    private static final int ACTIVE_MD_TYPE_LTG  = 4;//4G(TDD-LTE+FDD-LTE)+3G(TDS-CDMA)+2G(GSM)
+    //4G(TDD-LTE+FDD-LTE)+3G(WCDMA+EVDO)+2G(GSM+CDMA2000)
+    private static final int ACTIVE_MD_TYPE_LWCG = 5;
+    private static final int ACTIVE_MD_TYPE_LtTG = 6;//4G(TDD-LTE)+3G(TDS-CDMA)+2G(GSM)
+    private static final int ACTIVE_MD_TYPE_LfWG = 7;//4G(FDD-LTE)+3G(WCDMA)+2G(GSM)
+
+    private static final int PROJECT_SIM_NUM = TelephonyManager.getDefault().getSimCount();
+    private static final boolean IS_WORLD_PHONE_SUPPORT =
+            (SystemProperties.getInt("ro.mtk_world_phone", 0) == 1);
+    private static final boolean IS_LTE_SUPPORT =
+            (SystemProperties.getInt("ro.mtk_lte_support", 0) == 1);
+    private static final boolean IS_CDMA_LTE_DC_SUPPORT =
+            CdmaFeatureOptionUtils.isCdmaLteDcSupport();
+    private static final boolean IS_WORLD_MODE_SUPPORT =
+            (SystemProperties.getInt("ro.mtk_md_world_mode_support", 0) == 1);
+    private static final String PROPERTY_MAJOR_SIM = "persist.radio.simswitch";
+    private static Context sContext = null;
+    private static Phone sDefultPhone = null;
+    private static Phone[] sProxyPhones = null;
+    private static Phone[] sActivePhones = new Phone[PROJECT_SIM_NUM];
+
+
+    public WorldPhoneUtil() {
+        logd("Constructor invoked");
+        sDefultPhone = PhoneFactory.getDefaultPhone();
+        sProxyPhones = PhoneFactory.getPhones();
+        for (int i = 0; i < PROJECT_SIM_NUM; i++) {
+            sActivePhones[i] = ((PhoneProxy) sProxyPhones[i]).getActivePhone();
+        }
+        if (sDefultPhone != null) {
+            sContext = sDefultPhone.getContext();
+        } else {
+            logd("DefaultPhone = null");
+        }
+    }
+
+    public static int getProjectSimNum() {
+        return PROJECT_SIM_NUM;
+    }
+
+    public static int getMajorSim() {
+        // MTK TODO
+        if (true /* !ProxyController.getInstance().isCapabilitySwitching() */) {
+            String currMajorSim = SystemProperties.get(PROPERTY_MAJOR_SIM, "");
+            if (currMajorSim != null && !currMajorSim.equals("")) {
+                logd("[getMajorSim]: " + ((Integer.parseInt(currMajorSim)) - 1));
+                return (Integer.parseInt(currMajorSim)) - 1;
+            } else {
+                logd("[getMajorSim]: fail to get major SIM");
+                return MAJOR_SIM_UNKNOWN;
+            }
+        } else {
+            logd("[getMajorSim]: radio capability is switching");
+            return MAJOR_SIM_UNKNOWN;
+        }
+    }
+
+    public static int getModemSelectionMode() {
+        if (sContext == null) {
+            logd("sContext = null");
+            return SELECTION_MODE_AUTO;
+        }
+
+        // MTK TODO
+        // return Settings.Global.getInt(sContext.getContentResolver(),
+        //             Settings.Global.WORLD_PHONE_AUTO_SELECT_MODE, SELECTION_MODE_AUTO);
+        return SELECTION_MODE_AUTO;
+    }
+
+    public static boolean isWorldPhoneSupport() {
+        return IS_WORLD_PHONE_SUPPORT;
+    }
+
+    public static boolean isLteSupport() {
+        return IS_LTE_SUPPORT;
+    }
+
+    public static String regionToString(int region) {
+        String regionString;
+        switch (region) {
+            case REGION_UNKNOWN:
+                regionString = "REGION_UNKNOWN";
+                break;
+            case REGION_DOMESTIC:
+                regionString = "REGION_DOMESTIC";
+                break;
+            case REGION_FOREIGN:
+                regionString = "REGION_FOREIGN";
+                break;
+            default:
+                regionString = "Invalid Region";
+                break;
+        }
+
+        return regionString;
+    }
+
+    public static String stateToString(int state) {
+        String stateString;
+        switch (state) {
+            case ServiceState.STATE_POWER_OFF:
+                stateString = "STATE_POWER_OFF";
+                break;
+            case ServiceState.STATE_IN_SERVICE:
+                stateString = "STATE_IN_SERVICE";
+                break;
+            case ServiceState.STATE_OUT_OF_SERVICE:
+                stateString = "STATE_OUT_OF_SERVICE";
+                break;
+            case ServiceState.STATE_EMERGENCY_ONLY:
+                stateString = "STATE_EMERGENCY_ONLY";
+                break;
+            default:
+                stateString = "Invalid State";
+                break;
+        }
+
+        return stateString;
+    }
+
+    public static String regStateToString(int regState) {
+        String rsString;
+        switch (regState) {
+            case ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING:
+                rsString = "REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING";
+                break;
+            case ServiceState.REGISTRATION_STATE_HOME_NETWORK:
+                rsString = "REGISTRATION_STATE_HOME_NETWORK";
+                break;
+            case ServiceState.REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING:
+                rsString = "REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING";
+                break;
+            case ServiceState.REGISTRATION_STATE_REGISTRATION_DENIED:
+                rsString = "REGISTRATION_STATE_REGISTRATION_DENIED";
+                break;
+            case ServiceState.REGISTRATION_STATE_UNKNOWN:
+                rsString = "REGISTRATION_STATE_UNKNOWN";
+                break;
+            case ServiceState.REGISTRATION_STATE_ROAMING:
+                rsString = "REGISTRATION_STATE_ROAMING";
+                break;
+            case ServiceState.
+                    REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING_EMERGENCY_CALL_ENABLED:
+                rsString =
+                    "REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING_EMERGENCY_CALL_ENABLED";
+                break;
+            case ServiceState.
+                    REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING_EMERGENCY_CALL_ENABLED:
+                rsString =
+                    "REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING_EMERGENCY_CALL_ENABLED";
+                break;
+            case ServiceState.REGISTRATION_STATE_REGISTRATION_DENIED_EMERGENCY_CALL_ENABLED:
+                rsString = "REGISTRATION_STATE_REGISTRATION_DENIED_EMERGENCY_CALL_ENABLED";
+                break;
+            case ServiceState.REGISTRATION_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED:
+                rsString = "REGISTRATION_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED";
+                break;
+            default:
+                rsString = "Invalid RegState";
+                break;
+        }
+
+        return rsString;
+    }
+
+    public static String denyReasonToString(int reason) {
+        String drString;
+        switch (reason) {
+            case CAMP_ON_NOT_DENIED:
+                drString = "CAMP_ON_NOT_DENIED";
+                break;
+            case CAMP_ON_DENY_REASON_UNKNOWN:
+                drString = "CAMP_ON_DENY_REASON_UNKNOWN";
+                break;
+            case CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD:
+                drString = "CAMP_ON_DENY_REASON_NEED_SWITCH_TO_FDD";
+                break;
+            case CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD:
+                drString = "CAMP_ON_DENY_REASON_NEED_SWITCH_TO_TDD";
+                break;
+            case CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD:
+                drString = "CAMP_ON_DENY_REASON_DOMESTIC_FDD_MD";
+                break;
+            default:
+                drString = "Invalid Reason";
+                break;
+        }
+
+        return drString;
+    }
+
+    public static String iccCardTypeToString(int iccCardType) {
+        String iccTypeString;
+        switch (iccCardType) {
+            case ICC_CARD_TYPE_SIM:
+                iccTypeString = "SIM";
+                break;
+            case ICC_CARD_TYPE_USIM:
+                iccTypeString = "USIM";
+                break;
+            case ICC_CARD_TYPE_UNKNOWN:
+                iccTypeString = "Icc Card Type Unknown";
+                break;
+            default:
+                iccTypeString = "Invalid Icc Card Type";
+                break;
+        }
+
+        return iccTypeString;
+    }
+
+    public void setModemSelectionMode(int mode, int modemType) {
+    }
+
+    public void notifyRadioCapabilityChange(int capailitySimId) {
+    }
+
+    public static boolean isCdmaLteDcSupport() {
+        return IS_CDMA_LTE_DC_SUPPORT;
+    }
+
+    //C2K world phone
+    public static int getRadioTechModeForWp() {
+        int mode = RADIO_TECH_MODE_FOR_WP_UNKNOWN;
+        if (isCdmaLteDcSupport()) {
+            // MTK TODO
+            /*
+            int majorySimId = getMajorSim();
+            int svlteModeSlotId = SvlteModeController.getActiveSvlteModeSlotId();
+            logd("[getRadioTechModeForWp]: majorySimId=" + majorySimId +
+                    " svlteModeSlotId=" + svlteModeSlotId);
+            if (majorySimId != MAJOR_SIM_UNKNOWN) {
+                if (svlteModeSlotId == majorySimId) {
+                    mode = RADIO_TECH_MODE_FOR_WP_SVLTE;
+                } else {
+                    mode = RADIO_TECH_MODE_FOR_WP_CSFB;
+                }
+            } else {
+                mode = RADIO_TECH_MODE_FOR_WP_UNKNOWN;
+            }
+            */
+            logd("[getRadioTechModeForWp]: xen0n: TODO for CDMA!");
+        } else {
+            mode = RADIO_TECH_MODE_FOR_WP_CSFB;
+        }
+        logd("[getRadioTechModeForWp]: " + mode);
+        return mode;
+    }
+
+    //WorldMode
+    public static boolean isWorldModeSupport() {
+        return IS_WORLD_MODE_SUPPORT;
+    }
+
+    /**
+     * In world phone support project, modem support both FDD(Frequency-division duplexing) mode and
+     * TDD(Time-division duplexin) mode for 3G(UTRAN). It runs only one mode, FDD or TDD, at a time.
+     * This API will return acully divison duplexing mode.
+     *
+     * @return 0 :unknown
+     *         1 : FDD
+     *         2 : TDD
+     */
+    public static int get3GDivisionDuplexMode(){
+        int duplexMode = UTRAN_DIVISION_DUPLEX_MODE_UNKNOWN;
+        int activeMdType = getActiveModemType();
+
+
+        switch (activeMdType) {
+            case ACTIVE_MD_TYPE_WG:
+            case ACTIVE_MD_TYPE_LWG:
+            case ACTIVE_MD_TYPE_LfWG:
+                duplexMode = UTRAN_DIVISION_DUPLEX_MODE_FDD;
+                break;
+
+            case ACTIVE_MD_TYPE_TG:
+            case ACTIVE_MD_TYPE_LTG:
+            case ACTIVE_MD_TYPE_LtTG:
+                duplexMode = UTRAN_DIVISION_DUPLEX_MODE_TDD;
+                break;
+            default:
+                duplexMode = UTRAN_DIVISION_DUPLEX_MODE_UNKNOWN;
+            break;
+        }
+        logd("get3GDivisionDuplexMode=" + duplexMode);
+        return duplexMode;
+    }
+
+    private static int getActiveModemType(){
+        int modemType = 0;
+        int activeMdType = ACTIVE_MD_TYPE_UNKNOWN;
+
+        if(!isWorldModeSupport()){
+            modemType = ModemSwitchHandler.getActiveModemType();
+            switch (modemType) {
+                case ModemSwitchHandler.MD_TYPE_WG:
+                    activeMdType = ACTIVE_MD_TYPE_WG;
+                    break;
+                case ModemSwitchHandler.MD_TYPE_TG:
+                    activeMdType = ACTIVE_MD_TYPE_TG;
+                    break;
+                case ModemSwitchHandler.MD_TYPE_LWG:
+                    activeMdType = ACTIVE_MD_TYPE_LWG;
+                    break;
+                case ModemSwitchHandler.MD_TYPE_LTG:
+                    activeMdType = ACTIVE_MD_TYPE_LTG;
+                    break;
+                default:
+                    activeMdType = ACTIVE_MD_TYPE_UNKNOWN;
+                break;
+            }
+        } else {
+            modemType = WorldMode.getWorldMode();
+            int activeMode = Integer.valueOf(
+                    SystemProperties.get("ril.nw.worldmode.activemode",
+                    Integer.toString(ACTIVE_MD_TYPE_UNKNOWN)));
+            logd("[getActiveModemType]: activeMode"+ activeMode);
+            switch (modemType) {
+                case WorldMode.MD_WORLD_MODE_LTG:
+                    activeMdType = ACTIVE_MD_TYPE_LTG;
+                    break;
+                case WorldMode.MD_WORLD_MODE_LWG:
+                    activeMdType = ACTIVE_MD_TYPE_LWG;
+                    break;
+                case WorldMode.MD_WORLD_MODE_LWTG:
+                case WorldMode.MD_WORLD_MODE_LWCTG:
+                    if (activeMode > 0){
+                        if (activeMode == 1){
+                            //FDD mode
+                            activeMdType = ACTIVE_MD_TYPE_LWG;
+                        } else if (activeMode == 2){
+                            //TDD mode
+                            activeMdType = ACTIVE_MD_TYPE_LTG;
+                        }
+                    }
+                    break;
+                case WorldMode.MD_WORLD_MODE_LWCG:
+                    activeMdType = ACTIVE_MD_TYPE_LWCG;
+                    break;
+                case WorldMode.MD_WORLD_MODE_LTTG:
+                    activeMdType = ACTIVE_MD_TYPE_LtTG;
+                    break;
+                case WorldMode.MD_WORLD_MODE_LFWG:
+                    activeMdType = ACTIVE_MD_TYPE_LfWG;
+                    break;
+                default:
+                    activeMdType = ACTIVE_MD_TYPE_UNKNOWN;
+                break;
+            }
+        }
+        logd("getActiveModemType=" + activeMdType);
+        return activeMdType;
+    }
+
+    public static boolean isWorldPhoneSwitching(){
+        if (isWorldModeSupport()){
+            return WorldMode.isWorldModeSwitching();
+        } else {
+            return false;
+        }
+    }
+
+    private static void logd(String msg) {
+        Rlog.d(LOG_TAG, "[WPP_UTIL]" + msg);
+    }
+}
