From d6cdc29eeef31fda47b80cf4e93d72520bab99e3 Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Fri, 3 Nov 2017 20:55:38 +0300
Subject: [PATCH] xen0n patchs

Change-Id: I650c89d0a1d585209ee3bd714ee0fb9e640b30e3
---
 camera/Android.mk                                  |   6 +
 camera/MtkCamera.cpp                               | 212 ++++++++++++++
 include/camera/MtkCamera.h                         | 323 +++++++++++++++++++++
 media/libmedia/Android.mk                          |  12 +
 media/libmedia/IOMX.cpp                            |  32 ++
 media/libmedia/mtkaudio_stubs.cpp                  | 219 ++++++++++++++
 media/libstagefright/ACodec.cpp                    |   5 +
 media/libstagefright/Android.mk                    |   6 +
 media/libstagefright/AwesomePlayer.cpp             |  21 +-
 media/libstagefright/CameraSource.cpp              |   2 +
 media/libstagefright/MediaSync.cpp                 |   3 +-
 media/libstagefright/OMXCodec.cpp                  |   9 +
 media/libstagefright/SurfaceMediaSource.cpp        |   2 +-
 .../filters/GraphicBufferListener.cpp              |   2 +-
 media/libstagefright/include/AwesomePlayer.h       |   6 +
 media/libstagefright/include/OMXNodeInstance.h     |   6 +
 .../include/SoftVideoDecoderOMXComponent.h         |   3 +
 media/libstagefright/omx/Android.mk                |   6 +
 media/libstagefright/omx/GraphicBufferSource.cpp   |  10 +-
 media/libstagefright/omx/OMXNodeInstance.cpp       |  30 ++
 .../omx/SoftVideoDecoderOMXComponent.cpp           |  32 +-
 .../device1/CameraHardwareInterface.h              |  36 +++
 .../libcameraservice/gui/RingBufferConsumer.h      |  10 +-
 services/soundtrigger/SoundTriggerHwService.cpp    |   2 +-
 24 files changed, 978 insertions(+), 17 deletions(-)
 create mode 100644 camera/MtkCamera.cpp
 create mode 100644 include/camera/MtkCamera.h
 create mode 100644 media/libmedia/mtkaudio_stubs.cpp

diff --git a/camera/Android.mk b/camera/Android.mk
index 36f6da1..b0e0c10 100644
--- a/camera/Android.mk
+++ b/camera/Android.mk
@@ -58,6 +58,12 @@ else
 LOCAL_WHOLE_STATIC_LIBRARIES += libcamera_parameters
 endif
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_SRC_FILES += \
+    MtkCamera.cpp \
+
+endif
+
 LOCAL_MODULE:= libcamera_client
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/camera/MtkCamera.cpp b/camera/MtkCamera.cpp
new file mode 100644
index 0000000..17e6e39
--- /dev/null
+++ b/camera/MtkCamera.cpp
@@ -0,0 +1,212 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "MtkCamera"
+#include <utils/Log.h>
+
+#include <binder/MemoryBase.h>
+#include <binder/MemoryHeapBase.h>
+#include <camera/MtkCamera.h>
+
+namespace android {
+
+
+MtkCamMsgExtDataHelper::
+MtkCamMsgExtDataHelper()
+    : mIsValid(false)
+    , mspData(0)
+    , mspHeap(0)
+    , mDataOffset(0)
+    , mDataSize(0)
+{
+    ::memset(&mExtDataHdr, 0, sizeof(mExtDataHdr));
+}
+
+
+MtkCamMsgExtDataHelper::
+~MtkCamMsgExtDataHelper()
+{
+    uninit();
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+init(const sp<IMemory>& dataPtr)
+{
+    bool ret = false;
+    //
+    sp<IMemoryHeap> heap = 0;
+    ssize_t         offset = 0;
+    size_t          size = 0;
+    //
+    if  ( NULL == dataPtr.get() ) {
+        ALOGE("[MtkCamMsgExtDataHelper] dataPtr is NULL \r\n");
+        goto lbExit;
+    }
+    //
+    heap = dataPtr->getMemory(&offset, &size);
+    if  ( NULL == heap.get() || NULL == heap->base() ) {
+        ALOGE("[MtkCamMsgExtDataHelper] heap or heap->base() is NULL - (heap,offset,size)=(%p,%d,%d) \r\n", heap.get(), offset, size);
+        goto lbExit;
+    }
+    //
+    if ( sizeof(DataHeader) > size ) {
+        ALOGE("[MtkCamMsgExtDataHelper] sizeof(DataHeader)(%d) > size(%d) \r\n", sizeof(DataHeader), size);
+        goto lbExit;
+    }
+    //
+    ::memcpy(&mExtDataHdr, ((uint8_t*)heap->base()) + offset, sizeof(DataHeader));
+    mspData = dataPtr;
+    mspHeap = heap;
+    mDataOffset = offset;
+    mDataSize   = size;
+    mIsValid= true;
+    ret = true;
+lbExit:
+    return  ret;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+uninit()
+{
+    mIsValid= false;
+    mspData = NULL;
+    mspHeap = NULL;
+    mDataOffset = 0;
+    mDataSize   = 0;
+    ::memset(&mExtDataHdr, 0, sizeof(mExtDataHdr));
+    return  true;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+create(size_t const extParamSize, uint32_t const u4ExtMsgType)
+{
+    bool ret = false;
+    //
+    size_t const extDataSize = sizeof(DataHeader) + extParamSize;
+    sp<IMemoryHeap> heap = 0;
+    sp<IMemory> dataPtr = 0;
+
+    //  (1) Check arguments.
+    if  ( 0 == extParamSize )
+    {
+        ALOGW("[MtkCamMsgExtDataHelper::create] extParamSize==0 \r\n");
+    }
+
+    //  (2) Allocate memory
+    heap = new MemoryHeapBase(extDataSize, 0, NULL);
+    dataPtr = new MemoryBase(heap, 0, extDataSize);
+
+    //  (3) Initialize.
+    ret = init(dataPtr);
+    if  ( ! ret )
+    {
+        ALOGE("[MtkCamMsgExtDataHelper::create] init fail \r\n");
+        goto lbExit;
+    }
+
+    //  (4) Assign the header.
+    mExtDataHdr.extMsgType = u4ExtMsgType;
+    ::memcpy(((uint8_t*)mspHeap->base()) + mDataOffset, &mExtDataHdr, sizeof(DataHeader));
+
+    ret = true;
+lbExit:
+    return  ret;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+destroy()
+{
+    return  uninit();
+}
+
+
+uint8_t*
+MtkCamMsgExtDataHelper::
+getExtParamBase() const
+{
+    return  mIsValid
+        ?   static_cast<uint8_t*>(mspHeap->base()) + mDataOffset + sizeof(DataHeader)
+        :   NULL;
+}
+
+
+size_t
+MtkCamMsgExtDataHelper::
+getExtParamSize() const
+{
+    return  mIsValid
+        ?   (mDataSize - sizeof(DataHeader))
+        :   0;
+}
+
+
+ssize_t
+MtkCamMsgExtDataHelper::
+getExtParamOffset() const
+{
+    return  mIsValid
+        ?   (mDataOffset + sizeof(DataHeader))
+        :   0;
+}
+
+
+}; // namespace android
diff --git a/include/camera/MtkCamera.h b/include/camera/MtkCamera.h
new file mode 100644
index 0000000..b11b698
--- /dev/null
+++ b/include/camera/MtkCamera.h
@@ -0,0 +1,323 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
+#define _MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
+
+#include <binder/IMemory.h>
+
+namespace android {
+
+// extended msgType in notifyCallback and dataCallback functions
+enum {
+    MTK_CAMERA_MSG_EXT_NOTIFY       = 0x40000000,
+    MTK_CAMERA_MSG_EXT_DATA         = 0x80000000,
+};
+
+// extended notify message related to MTK_CAMERA_MSG_EXT_NOTIFY used in notifyCallback functions
+enum {
+    //
+    //  Smile Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_SMILE_DETECT      = 0x00000001,
+    //
+    //  Auto Scene Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_ASD               = 0x00000002,
+    //
+    //  Multi Angle View
+    MTK_CAMERA_MSG_EXT_NOTIFY_MAV               = 0x00000003,
+    //
+    // Burst Shutter Callback
+    //  ext2: count-down shutter number; 0: the last one shutter.
+    MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER     = 0x00000004,
+    //
+    // Continuous Shutter Callback
+    //  ext2: current continuous shutter number.
+    MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER= 0x00000005,
+    //
+    // Continuous EndCallback
+    MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END    = 0x00000006,
+
+    // ZSD preview done
+    MTK_CAMERA_MSG_EXT_NOTIFY_ZSD_PREVIEW_DONE = 0x00000007,
+    //
+    // Capture done (disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE)
+    MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE      = 0x00000010,
+    //
+    // Shutter Callback (not disable CAMERA_MSG_SHUTTER)
+    //  ext2: 1: CameraService will play shutter sound.
+    MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER           = 0x00000011,
+    //
+    // for EM preview raw dump error notify
+    MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED  = 0x00000012,
+    //
+    // Gesture Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_GESTURE_DETECT  = 0x00000013,
+    //
+    // Stereo Feature: warning message
+    MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_WARNING    = 0x00000014,
+    //
+    // Stereo Feature: distance value
+    MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_DISTANCE   = 0x00000015,
+    //
+    // Result & Static metadata
+    MTK_CAMERA_MSG_EXT_NOTIFY_METADATA_DONE   = 0x00000016,
+    //
+    // ZSD capture early callback
+    MTK_CAMERA_MSG_EXT_NOTIFY_P2DONE            = 0x00000017
+};
+
+// extended data message related to MTK_CAMERA_MSG_EXT_DATA used in dataCallback functions
+// extended data header is located at the top of dataPrt in dataCallback functions
+//  DATA: Header + Params
+enum {
+    //
+    // Auto Panorama
+    //  Params:
+    //      int[0]: 0:mAUTORAMAMVCallback, 1:mAUTORAMACallback
+    //      int[1~]:depends on
+    //
+    MTK_CAMERA_MSG_EXT_DATA_AUTORAMA            = 0x00000001,
+    //
+    // AF Window Results
+    MTK_CAMERA_MSG_EXT_DATA_AF                    = 0x00000002,
+    //
+    // Burst Shot (EV Shot)
+    //      int[0]: the total shut count.
+    //      int[1]: count-down shut number; 0: the last one shut.
+    MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT          = 0x00000003,
+    //
+    //    Continuous Shot
+    //        int[0]: current continuous shut number.
+    MTK_CAMERA_MSG_EXT_DATA_CONTINUOUS_SHOT     = 0x00000004,
+
+
+    MTK_CAMERA_MSG_EXT_DATA_OT                  = 0x00000005,
+
+    //  Facebeauty Shot
+    //      int[0]: data type. 0:original image.
+    MTK_CAMERA_MSG_EXT_DATA_FACEBEAUTY          = 0x00000006,
+    //
+    //  MAV Shot
+    //      int[0]: data type. 0:original image.
+    MTK_CAMERA_MSG_EXT_DATA_MAV                 = 0x00000007,
+    //
+    //  HDR Shot
+    //      int[0]: data type. 0:0EV image.
+    MTK_CAMERA_MSG_EXT_DATA_HDR                 = 0x00000008,
+
+    //
+    // Motion Track
+    //  Params:
+    //      int[0]: 0: frame EIS, 1: captured image, 2: blended image, 3: intermediate data
+    //      int[1~]:depends on
+    //
+    MTK_CAMERA_MSG_EXT_DATA_MOTIONTRACK         = 0x00000009,
+
+    //
+    //  Compressed Image (not disable CAMERA_MSG_COMPRESSED_IMAGE)
+    //      int[0]: current shut index; 0: the first one shut.
+    MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE    = 0x00000010,
+
+    //
+    //  Stereo Shot
+    //      int[0]: data type.
+    MTK_CAMERA_MSG_EXT_DATA_JPS                 = 0x00000011,
+
+    //
+    //  Stereo Debug Data
+    //      int[0]: data type.
+    MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG          = 0x00000012,
+
+    //
+    // raw16
+    MTK_CAMERA_MSG_EXT_DATA_RAW16               = 0x00000013,
+
+};
+// extended data message related to MTK_CAMERA_MSG_EXT_DATA used in dataCallback functions
+// extended data header is located at the top of dataPrt in dataCallback functions
+//  DATA: Header + Params
+enum {
+    //
+    // static & result metadata for raw16
+    MTK_CAMERA_MSG_EXT_METADATA_RAW16            = 0x00000001,
+};
+
+//  MTK-extended camera message data helper.
+//  DATA: Header + Params
+class MtkCamMsgExtDataHelper
+{
+public:
+    //  The header type of MTK-extended camera message data.
+    struct DataHeader {
+        uint32_t        extMsgType;
+    };
+
+public:
+    MtkCamMsgExtDataHelper();
+    ~MtkCamMsgExtDataHelper();
+    bool            init(const sp<IMemory>& dataPtr);
+    bool            uninit();
+    bool            create(size_t const extParamSize, uint32_t const u4ExtMsgType);
+    bool            destroy();
+
+    uint8_t*                        getExtParamBase() const;
+    size_t                          getExtParamSize() const;
+    ssize_t                         getExtParamOffset() const;
+    inline uint32_t                 getExtMsgType() const { return mExtDataHdr.extMsgType; }
+    inline DataHeader const&        getExtDataHeader() const { return mExtDataHdr; }
+    inline sp<IMemory>const&        getData() const { return mspData; }
+    inline sp<IMemoryHeap>const&    getHeap() const { return mspHeap; }
+
+protected:
+    bool            mIsValid;
+    sp<IMemory>     mspData;
+    sp<IMemoryHeap> mspHeap;
+    ssize_t         mDataOffset;
+    size_t          mDataSize;
+    DataHeader      mExtDataHdr;
+};
+
+
+// cmdType in sendCommand functions
+enum {
+    CAMERA_CMD_MTK_DEFINE_START     = 0x10000000,
+    CAMERA_CMD_DO_PANORAMA,
+    CAMERA_CMD_CANCEL_PANORAMA,
+    CAMERA_CMD_START_SD_PREVIEW,            //(Smile Detection)
+    CAMERA_CMD_CANCEL_SD_PREVIEW,           //(Smile Detection)
+    CAMERA_CMD_START_OT,
+    CAMERA_CMD_STOP_OT,
+    CAMERA_CMD_START_MAV,
+    CAMERA_CMD_STOP_MAV,
+    CAMERA_CMD_START_AUTORAMA,
+    CAMERA_CMD_STOP_AUTORAMA,
+    CAMERA_CMD_GET_MEM_INFO,                //For Video to get PMEM buffer info
+    CAMERA_CMD_GET_REC_BUF_INFO,
+    CAMERA_CMD_CANCEL_CSHOT,
+    CAMERA_CMD_SET_CSHOT_SPEED,
+    CAMERA_CMD_START_3DSHOT,
+    CAMERA_CMD_STOP_3DSHOT,
+    CAMERA_CMD_START_MOTIONTRACK,
+    CAMERA_CMD_STOP_MOTIONTRACK,
+    CAMERA_CMD_START_CLONECAMERA,
+    CAMERA_CMD_SHOT_CLONECAMERA,
+    CAMERA_CMD_STOP_CLONECAMERA,
+    CAMERA_CMD_START_GD_PREVIEW,            //(Gesture Detection)
+    CAMERA_CMD_CANCEL_GD_PREVIEW,           //(Gesture Detection)
+
+    // For SDK Heartrate
+    CAMERA_CMD_START_HR_PREVIEW,            //(Heartrate Detection)
+    CAMERA_CMD_STOP_HR_PREVIEW,             //(Heartrate Detection)
+    CAMERA_CMD_SETCB_HR_PREVIEW,            //(Heartrate Detection)
+    CAMERA_CMD_SETUSER_HR_PREVIEW,          //(Heartrate Detection)
+    CAMERA_CMD_SETMODE_HR_PREVIEW,          //(Heartrate Detection)
+    CAMERA_CMD_CHECKPARA_HR_PREVIEW,        //(Heartrate Detection)
+
+    // For Main face informatin
+    CAMERA_CMD_SET_MAIN_FACE_COORDINATE,
+    CAMERA_CMD_CANCEL_MAIN_FACE,
+    //
+    CAMERA_CMD_ENABLE_RAW16_CALLBACK,
+};
+
+/*
+ * For Video to get PMEM buffer info
+ *
+ * Command: CAMERA_CMD_GET_MEM_INFO
+ */
+struct CameraMemInfo {
+    enum { eTYPE_PMEM = 0 };
+    uint32_t    u4Type;
+    uint32_t    u4VABase;
+    uint32_t    u4PABase;
+    uint32_t    u4MemSize;
+    uint32_t    u4MemCount;
+};
+
+
+/*
+ *  set camera fatal errors enum
+ *
+ */
+enum {
+    CAMERA_ERROR_NO_MEMORY   = 1000,
+    CAMERA_ERROR_RESET       = 1001,
+    CAMERA_ERROR_CALI_FLASH  = 1002,
+};
+
+/*
+ * For Video to get buffer info
+ *
+ * Command: CAMERA_CMD_GET_REC_BUF_INFO
+ */
+struct CameraRecBufInfo {
+    int32_t     i4MemId;
+    uint32_t    u4VirAddr;
+    uint32_t    u4Size;
+};
+
+
+/*
+ * For Video to set setting
+ *
+ * Command: CAMERA_CMD_GET_REC_BUF_INFO
+ */
+struct CameraRecSetting {
+    int32_t     mi4BufSecu; //security
+    int32_t     mi4BufCohe; //coherent
+};
+
+
+}; // namespace android
+
+#endif  //_MTK_FRAMEWORKS_AV_INCLUDE_CAMERA_MTKCAMERA_H_
diff --git a/media/libmedia/Android.mk b/media/libmedia/Android.mk
index efcd541..9dbd7e4 100644
--- a/media/libmedia/Android.mk
+++ b/media/libmedia/Android.mk
@@ -101,5 +101,17 @@ LOCAL_C_INCLUDES := \
 LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
 LOCAL_CLANG := true
 
+ifeq ($(MTK_HARDWARE),true)
+LOCAL_SRC_FILES += \
+    mtkaudio_stubs.cpp
+
+# StrongPointer.h
+LOCAL_C_INCLUDES += $(TOP)/frameworks/rs/server
+
+ifeq ($(BOARD_USES_LEGACY_MTK_AV_BLOB),true)
+LOCAL_CFLAGS += -DUSE_LEGACY_MTK_AV_BLOB
+endif
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/media/libmedia/IOMX.cpp b/media/libmedia/IOMX.cpp
index 7e951c9..59ce0cb 100644
--- a/media/libmedia/IOMX.cpp
+++ b/media/libmedia/IOMX.cpp
@@ -147,7 +147,11 @@ public:
         data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
         data.writeInt32((int32_t)node);
         data.writeInt32(index);
+#ifdef USE_LEGACY_MTK_AV_BLOB
+        data.writeInt32(size);
+#else
         data.writeInt64(size);
+#endif
         data.write(params, size);
         remote()->transact(GET_PARAMETER, data, &reply);
 
@@ -168,7 +172,11 @@ public:
         data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
         data.writeInt32((int32_t)node);
         data.writeInt32(index);
+#ifdef USE_LEGACY_MTK_AV_BLOB
+        data.writeInt32(size);
+#else
         data.writeInt64(size);
+#endif
         data.write(params, size);
         remote()->transact(SET_PARAMETER, data, &reply);
 
@@ -182,7 +190,11 @@ public:
         data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
         data.writeInt32((int32_t)node);
         data.writeInt32(index);
+#ifdef USE_LEGACY_MTK_AV_BLOB
+        data.writeInt32(size);
+#else
         data.writeInt64(size);
+#endif
         data.write(params, size);
         remote()->transact(GET_CONFIG, data, &reply);
 
@@ -203,7 +215,11 @@ public:
         data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
         data.writeInt32((int32_t)node);
         data.writeInt32(index);
+#ifdef USE_LEGACY_MTK_AV_BLOB
+        data.writeInt32(size);
+#else
         data.writeInt64(size);
+#endif
         data.write(params, size);
         remote()->transact(SET_CONFIG, data, &reply);
 
@@ -464,7 +480,11 @@ public:
         data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
         data.writeInt32((int32_t)node);
         data.writeInt32(port_index);
+#ifdef USE_LEGACY_MTK_AV_BLOB
+        data.writeInt32(size);
+#else
         data.writeInt64(size);
+#endif
         remote()->transact(ALLOC_BUFFER, data, &reply);
 
         status_t err = reply.readInt32();
@@ -583,7 +603,11 @@ public:
         data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
         data.writeInt32((int32_t)node);
         data.writeInt32(port_index);
+#ifdef USE_LEGACY_MTK_AV_BLOB
+        data.writeInt32(size);
+#else
         data.writeInt64(size);
+#endif
         data.write(optionData, size);
         data.writeInt32(type);
         remote()->transact(SET_INTERNAL_OPTION, data, &reply);
@@ -695,7 +719,11 @@ status_t BnOMX::onTransact(
             node_id node = (node_id)data.readInt32();
             OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());
 
+#ifdef USE_LEGACY_MTK_AV_BLOB
+            size_t size = data.readInt32();
+#else
             size_t size = data.readInt64();
+#endif
 
             status_t err = NOT_ENOUGH_DATA;
             void *params = NULL;
@@ -1036,7 +1064,11 @@ status_t BnOMX::onTransact(
                 return NO_ERROR;
             }
 
+#ifdef USE_LEGACY_MTK_AV_BLOB
+            size_t size = data.readInt32();
+#else
             size_t size = data.readInt64();
+#endif
 
             buffer_id buffer;
             void *buffer_data;
diff --git a/media/libmedia/mtkaudio_stubs.cpp b/media/libmedia/mtkaudio_stubs.cpp
new file mode 100644
index 0000000..2d9f2cc
--- /dev/null
+++ b/media/libmedia/mtkaudio_stubs.cpp
@@ -0,0 +1,219 @@
+// #include <MtpTypes.h>
+#include <system/audio.h>
+#include <StrongPointer.h>
+#include <media/IAudioFlinger.h>
+#include <hardware/audio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+
+namespace android {
+
+typedef void (*audio_error_callback)(status_t err);
+
+class AudioSystem
+{
+public:
+    static bool getVoiceUnlockDLInstance();
+    static int GetVoiceUnlockDLLatency();
+    static int SetVoiceUnlockSRC(uint outSR, uint outChannel);
+    static bool stopVoiceUnlockDL();
+    static bool startVoiceUnlockDL();
+    static int ReadRefFromRing(void*buf, uint32_t datasz,void* DLtime);
+    static int GetVoiceUnlockULTime(void* DLtime);
+    static void freeVoiceUnlockDLInstance();
+
+}; // class
+
+bool AudioSystem::getVoiceUnlockDLInstance()
+{
+  return 0;
+}
+
+int AudioSystem::GetVoiceUnlockDLLatency()
+{
+  return 0;
+}
+
+int AudioSystem::SetVoiceUnlockSRC(uint outSR __unused, uint outChannel __unused)
+{
+  return 0;
+}
+
+bool AudioSystem::stopVoiceUnlockDL()
+{
+  return 0;
+}
+
+bool AudioSystem::startVoiceUnlockDL()
+{
+  return 0;
+}
+
+int AudioSystem::ReadRefFromRing(
+        void *buf __unused,
+        uint32_t datasz __unused,
+        void* DLtime __unused
+        )
+{
+  return 0;
+}
+
+int AudioSystem::GetVoiceUnlockULTime(void* DLtime __unused)
+{
+  return 0;
+}
+
+void AudioSystem::freeVoiceUnlockDLInstance()
+{
+  return;
+}
+
+class IATVCtrlClient
+{
+};
+
+class IATVCtrlService: public IInterface
+{
+public:
+  DECLARE_META_INTERFACE(ATVCtrlService);
+};
+
+class BpATVCtrlService : public BpInterface<IATVCtrlService>
+{
+public:
+    BpATVCtrlService(const sp<IBinder>& impl)
+        : BpInterface<IATVCtrlService>(impl)
+    {
+    }
+    virtual ~BpATVCtrlService()
+    {
+    }
+    virtual int ATVCS_matv_init()
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_ps_init(int on __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_set_parameterb(int in __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_suspend(int on __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_shutdown()
+    {
+        return 0;
+    }
+    virtual void ATVCS_matv_chscan(int mode __unused)
+    {
+    }
+    virtual void ATVCS_matv_chscan_stop()
+    {
+    }
+    virtual int ATVCS_matv_get_chtable(int ch __unused, void *entry __unused, int len __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_set_chtable(int ch __unused, void *entry __unused, int len __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_clear_chtable()
+    {
+        return 0;
+    }
+    virtual void ATVCS_matv_change_channel(int ch __unused)
+    {
+    }
+    virtual void ATVCS_matv_set_country(int country __unused)
+    {
+    }
+    virtual void ATVCS_matv_set_tparam(int mode __unused)
+    {
+    }
+    virtual void ATVCS_matv_audio_play()
+    {
+    }
+    virtual void ATVCS_matv_audio_stop()
+    {
+    }
+    virtual int ATVCS_matv_audio_get_format()
+    {
+        return 0;
+    }
+    virtual void ATVCS_matv_audio_set_format(int val __unused)
+    {
+    }
+    virtual int ATVCS_matv_audio_get_sound_system()
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_adjust(int item __unused, int val __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_get_chipdep(int item __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_set_chipdep(int item __unused, int val __unused)
+    {
+        return 0;
+    }
+    virtual void ATVCS_matv_register_callback()
+    {
+    }
+    virtual void registerClient(const sp<IATVCtrlClient>& client __unused)
+    {
+    }
+    virtual void registerClient_FM(const sp<IATVCtrlClient>& client __unused)
+    {
+    }
+    virtual void CLI(char input __unused)
+    {
+    }
+    virtual int ATVCS_fm_powerup(void *parm __unused, int len __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_powerdown()
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_getrssi()
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_tune(void *parm __unused, int len __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_seek(void *parm __unused, int len __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_scan(void *parm __unused, int len __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_mute(int val __unused)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_getchipid()
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_isFMPowerUp()
+    {
+        return 0;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(ATVCtrlService, "android.media.IATVCtrlService");
+
+} // namespace
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 581bfba..fb2304b 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -929,6 +929,7 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
     int32_t width = 0, height = 0;
     int32_t isAdaptivePlayback = 0;
 
+#ifndef MTK_HARDWARE
     if (mInputFormat->findInt32("adaptive-playback", &isAdaptivePlayback)
             && isAdaptivePlayback
             && mInputFormat->findInt32("max-width", &width)
@@ -940,6 +941,10 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
         width = def.format.video.nFrameWidth;
         height = def.format.video.nFrameHeight;
     }
+#else
+    width = def.format.video.nStride;
+    height = def.format.video.nSliceHeight;
+#endif
     err = setNativeWindowSizeFormatAndUsage(
             nativeWindow,
             width,
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 792c139..1d5a32c 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -212,6 +212,12 @@ LOCAL_C_INCLUDES += \
 	$(TOP)/hardware/samsung/exynos4/include
 endif
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+ifeq ($(BOARD_USES_LEGACY_MTK_AV_BLOB),true)
+LOCAL_CFLAGS += -DUSE_LEGACY_MTK_AV_BLOB
+endif
+endif
+
 LOCAL_MODULE:= libstagefright
 
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index 933f241..de2e0a6 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -217,7 +217,12 @@ AwesomePlayer::AwesomePlayer()
       mTextDriver(NULL),
       mOffloadAudio(false),
       mAudioTearDown(false),
-      mIsFirstFrameAfterResume(false) {
+      mIsFirstFrameAfterResume(false)
+#ifdef MTK_HARDWARE
+	  ,
+      mAVSyncTimeUs(-1)
+#endif
+{
     CHECK_EQ(mClient.connect(), (status_t)OK);
 
     DataSource::RegisterDefaultSniffers();
@@ -1617,6 +1622,17 @@ void AwesomePlayer::setVideoSource(sp<MediaSource> source) {
     mVideoTrack = source;
 }
 
+#ifdef MTK_HARDWARE
+void AwesomePlayer::mtk_omx_get_current_time(int64_t* pReal_time) {
+    if((mFlags & FIRST_FRAME) || mSeeking == SEEK) {
+            *pReal_time = -1;
+    } else {
+            *pReal_time = mAVSyncTimeUs;
+    }
+
+}
+#endif
+
 status_t AwesomePlayer::initVideoDecoder(uint32_t flags) {
     ATRACE_CALL();
 
@@ -1936,6 +1952,9 @@ void AwesomePlayer::onVideoEvent() {
         int64_t nowUs = estimateRealTimeUs(ts, systemTimeUs) - mTimeSourceDeltaUs;
 
         int64_t latenessUs = nowUs - timeUs;
+#ifdef MTK_HARDWARE
+        mAVSyncTimeUs = nowUs;
+#endif
 
         ATRACE_INT("Video Lateness (ms)", latenessUs / 1E3);
 
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index f6b4741..7a019f3 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -639,6 +639,7 @@ status_t CameraSource::startCameraRecording() {
         }
     }
 
+#ifndef USE_LEGACY_MTK_AV_BLOB
     err = mCamera->sendCommand(
         CAMERA_CMD_SET_VIDEO_FORMAT, mEncoderFormat, mEncoderDataSpace);
 
@@ -648,6 +649,7 @@ status_t CameraSource::startCameraRecording() {
         ALOGW("Failed to set video encoder format/dataspace to %d, %d due to %d",
                 mEncoderFormat, mEncoderDataSpace, err);
     }
+#endif
 
     err = OK;
     if (mCameraFlags & FLAGS_HOT_CAMERA) {
diff --git a/media/libstagefright/MediaSync.cpp b/media/libstagefright/MediaSync.cpp
index 3a45e25..1dc10c7 100644
--- a/media/libstagefright/MediaSync.cpp
+++ b/media/libstagefright/MediaSync.cpp
@@ -19,6 +19,7 @@
 #include <inttypes.h>
 
 #include <gui/BufferQueue.h>
+#include <gui/BufferItem.h>
 #include <gui/IGraphicBufferConsumer.h>
 #include <gui/IGraphicBufferProducer.h>
 
@@ -625,7 +626,7 @@ void MediaSync::onFrameAvailableFromInput() {
     }
 
     // Acquire and detach the buffer from the input.
-    BufferItem bufferItem;
+    BufferQueue::BufferItem bufferItem;
     status_t status = mInput->acquireBuffer(&bufferItem, 0 /* presentWhen */);
     if (status != NO_ERROR) {
         ALOGE("acquiring buffer from input failed (%d)", status);
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index de00ff2..32576c1 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -1799,10 +1799,19 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
 #endif
     }
 
+#ifdef MTK_HARDWARE
+    usage |= (GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_SW_READ_OFTEN);
+#endif
+
     err = setNativeWindowSizeFormatAndUsage(
             mNativeWindow.get(),
+#ifdef MTK_HARDWARE
+            def.format.video.nStride,
+            def.format.video.nSliceHeight,
+#else
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+#endif
             def.format.video.eColorFormat,
             rotationDegrees,
             usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
diff --git a/media/libstagefright/SurfaceMediaSource.cpp b/media/libstagefright/SurfaceMediaSource.cpp
index 147eb45..0c83035 100644
--- a/media/libstagefright/SurfaceMediaSource.cpp
+++ b/media/libstagefright/SurfaceMediaSource.cpp
@@ -298,7 +298,7 @@ status_t SurfaceMediaSource::read(
     // TODO: mCurrentSlot can be made a bufferstate since there
     // can be more than one "current" slots.
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     // If the recording has started and the queue is empty, then just
     // wait here till the frames come in from the client side
     while (mStarted) {
diff --git a/media/libstagefright/filters/GraphicBufferListener.cpp b/media/libstagefright/filters/GraphicBufferListener.cpp
index a606315..a9bfc03 100644
--- a/media/libstagefright/filters/GraphicBufferListener.cpp
+++ b/media/libstagefright/filters/GraphicBufferListener.cpp
@@ -86,7 +86,7 @@ void GraphicBufferListener::onSidebandStreamChanged() {
 }
 
 BufferItem GraphicBufferListener::getBufferItem() {
-    BufferItem item;
+    BufferQueue::BufferItem item;
 
     {
         Mutex::Autolock autoLock(mMutex);
diff --git a/media/libstagefright/include/AwesomePlayer.h b/media/libstagefright/include/AwesomePlayer.h
index 1a8e6c8..052c954 100644
--- a/media/libstagefright/include/AwesomePlayer.h
+++ b/media/libstagefright/include/AwesomePlayer.h
@@ -107,6 +107,9 @@ struct AwesomePlayer {
     void postAudioEOS(int64_t delayUs = 0ll);
     void postAudioSeekComplete();
     void postAudioTearDown();
+#ifdef MTK_HARDWARE
+    void mtk_omx_get_current_time(int64_t* pReal_time);
+#endif
     status_t dump(int fd, const Vector<String16> &args) const;
 
     status_t suspend();
@@ -375,6 +378,9 @@ private:
 
     AwesomePlayer(const AwesomePlayer &);
     AwesomePlayer &operator=(const AwesomePlayer &);
+#ifdef MTK_HARDWARE
+    int64_t mAVSyncTimeUs;
+#endif
 };
 
 }  // namespace android
diff --git a/media/libstagefright/include/OMXNodeInstance.h b/media/libstagefright/include/OMXNodeInstance.h
index 5ba0e8f..bcfcab6 100644
--- a/media/libstagefright/include/OMXNodeInstance.h
+++ b/media/libstagefright/include/OMXNodeInstance.h
@@ -165,10 +165,13 @@ private:
     };
     Vector<ActiveBuffer> mActiveBuffers;
     // for buffer ptr to buffer id translation
+    // but don't enable for use with MTK Lollipop- blob
+#ifndef USE_LEGACY_MTK_AV_BLOB
     Mutex mBufferIDLock;
     uint32_t mBufferIDCount;
     KeyedVector<OMX::buffer_id, OMX_BUFFERHEADERTYPE *> mBufferIDToBufferHeader;
     KeyedVector<OMX_BUFFERHEADERTYPE *, OMX::buffer_id> mBufferHeaderToBufferID;
+#endif
     MetadataBufferType mMetadataType[2];
 
     // For debug support
@@ -192,6 +195,9 @@ private:
     // For buffer id management
     OMX::buffer_id makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
     OMX_BUFFERHEADERTYPE *findBufferHeader(OMX::buffer_id buffer, OMX_U32 portIndex);
+#ifdef USE_LEGACY_MTK_AV_BLOB
+    OMX_BUFFERHEADERTYPE *findBufferHeader(OMX::buffer_id buffer);
+#endif
     OMX::buffer_id findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
     void invalidateBufferID(OMX::buffer_id buffer);
 
diff --git a/media/libstagefright/include/SoftVideoDecoderOMXComponent.h b/media/libstagefright/include/SoftVideoDecoderOMXComponent.h
index 4529007..37cc066 100644
--- a/media/libstagefright/include/SoftVideoDecoderOMXComponent.h
+++ b/media/libstagefright/include/SoftVideoDecoderOMXComponent.h
@@ -64,6 +64,9 @@ protected:
             const char *mimeType,
             OMX_U32 minCompressionRatio = 1u);
 
+    // For MTK blob compatibility
+    virtual void updatePortDefinitions(bool updateCrop = true);
+
     virtual void updatePortDefinitions(bool updateCrop = true, bool updateInputSize = false);
 
     uint32_t outputBufferWidth();
diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index d16d5df..31a0c4f 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -36,6 +36,12 @@ ifeq ($(strip $(AUDIO_FEATURE_ENABLED_EXTN_FLAC_DECODER)),true)
 endif
 endif
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+ifeq ($(BOARD_USES_LEGACY_MTK_AV_BLOB),true)
+LOCAL_CFLAGS += -DUSE_LEGACY_MTK_AV_BLOB
+endif
+endif
+
 LOCAL_MODULE:= libstagefright_omx
 LOCAL_CFLAGS += -Werror -Wall
 LOCAL_CLANG := true
diff --git a/media/libstagefright/omx/GraphicBufferSource.cpp b/media/libstagefright/omx/GraphicBufferSource.cpp
index 28fa730..5dc8241 100644
--- a/media/libstagefright/omx/GraphicBufferSource.cpp
+++ b/media/libstagefright/omx/GraphicBufferSource.cpp
@@ -57,7 +57,7 @@ void GraphicBufferSource::PersistentProxyListener::onFrameAvailable(
         if (consumer == NULL) {
             return;
         }
-        BufferItem bi;
+        BufferQueue::BufferItem bi;
         status_t err = consumer->acquireBuffer(&bi, 0);
         if (err != OK) {
             ALOGE("PersistentProxyListener: acquireBuffer failed (%d)", err);
@@ -463,7 +463,7 @@ void GraphicBufferSource::suspend(bool suspend) {
         mSuspended = true;
 
         while (mNumFramesAvailable > 0) {
-            BufferItem item;
+            BufferQueue::BufferItem item;
             status_t err = mConsumer->acquireBuffer(&item, 0);
 
             if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
@@ -520,7 +520,7 @@ bool GraphicBufferSource::fillCodecBuffer_l() {
 
     ALOGV("fillCodecBuffer_l: acquiring buffer, avail=%zu",
             mNumFramesAvailable);
-    BufferItem item;
+    BufferQueue::BufferItem item;
     status_t err = mConsumer->acquireBuffer(&item, 0);
     if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
         // shouldn't happen
@@ -611,7 +611,7 @@ bool GraphicBufferSource::repeatLatestBuffer_l() {
         return false;
     }
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     item.mBuf = mLatestBufferId;
     item.mFrameNumber = mLatestBufferFrameNum;
     item.mTimestamp = mRepeatLastFrameTimestamp;
@@ -884,7 +884,7 @@ void GraphicBufferSource::onFrameAvailable(const BufferItem& /*item*/) {
             ALOGV("onFrameAvailable: suspended, ignoring frame");
         }
 
-        BufferItem item;
+        BufferQueue::BufferItem item;
         status_t err = mConsumer->acquireBuffer(&item, 0);
         if (err == OK) {
             if (item.mBuf < 0 ||
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 8d7ffb9..beb5dba 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -220,10 +220,14 @@ OMXNodeInstance::OMXNodeInstance(
     : mOwner(owner),
       mNodeID(0),
       mHandle(NULL),
+#ifndef USE_LEGACY_MTK_AV_BLOB
       mObserver(observer),
       mSailed(false),
       mQueriedProhibitedExtensions(false),
       mBufferIDCount(0)
+#else
+      mObserver(observer)
+#endif
 {
     mName = ADebug::GetDebugName(name);
     DEBUG = ADebug::GetDebugLevelFromProperty(name, "debug.stagefright.omx-debug");
@@ -1797,6 +1801,8 @@ void OMXNodeInstance::freeActiveBuffers() {
     }
 }
 
+#ifndef USE_LEGACY_MTK_AV_BLOB
+
 OMX::buffer_id OMXNodeInstance::makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
     if (bufferHeader == NULL) {
         return 0;
@@ -1863,4 +1869,28 @@ void OMXNodeInstance::invalidateBufferID(OMX::buffer_id buffer) {
     mBufferIDToBufferHeader.removeItemsAt(index);
 }
 
+#else
+
+OMX::buffer_id OMXNodeInstance::makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
+    return (OMX::buffer_id)(size_t)bufferHeader;
+}
+
+OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(
+        OMX::buffer_id buffer, OMX_U32 portIndex __unused) {
+    return findBufferHeader(buffer);
+}
+
+OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) {
+    return (OMX_BUFFERHEADERTYPE *)(size_t)buffer;
+}
+
+OMX::buffer_id OMXNodeInstance::findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
+    return (OMX::buffer_id)(size_t)bufferHeader;
+}
+
+void OMXNodeInstance::invalidateBufferID(OMX::buffer_id buffer __unused) {
+}
+
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp b/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
index 19dde83..61a4fdc 100644
--- a/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
+++ b/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
@@ -130,6 +130,34 @@ void SoftVideoDecoderOMXComponent::initPorts(
     updatePortDefinitions(true /* updateCrop */, true /* updateInputSize */);
 }
 
+// For MTK blob compatibility
+void SoftVideoDecoderOMXComponent::updatePortDefinitions(bool updateCrop) {
+    OMX_PARAM_PORTDEFINITIONTYPE *def = &editPortInfo(kInputPortIndex)->mDef;
+    def->format.video.nFrameWidth = mWidth;
+    def->format.video.nFrameHeight = mHeight;
+    def->format.video.nStride = def->format.video.nFrameWidth;
+    def->format.video.nSliceHeight = def->format.video.nFrameHeight;
+
+    def->nBufferSize = def->format.video.nFrameWidth * def->format.video.nFrameHeight * 3 / 2;
+
+    def = &editPortInfo(kOutputPortIndex)->mDef;
+    def->format.video.nFrameWidth = outputBufferWidth();
+    def->format.video.nFrameHeight = outputBufferHeight();
+    def->format.video.nStride = def->format.video.nFrameWidth;
+    def->format.video.nSliceHeight = def->format.video.nFrameHeight;
+
+    def->nBufferSize =
+            (def->format.video.nFrameWidth *
+             def->format.video.nFrameHeight * 3) / 2;
+
+    if (updateCrop) {
+        mCropLeft = 0;
+        mCropTop = 0;
+        mCropWidth = mWidth;
+        mCropHeight = mHeight;
+    }
+}
+
 void SoftVideoDecoderOMXComponent::updatePortDefinitions(bool updateCrop, bool updateInputSize) {
     OMX_PARAM_PORTDEFINITIONTYPE *outDef = &editPortInfo(kOutputPortIndex)->mDef;
     outDef->format.video.nFrameWidth = outputBufferWidth();
@@ -202,12 +230,12 @@ void SoftVideoDecoderOMXComponent::handlePortSettingsChange(
                     mAdaptiveMaxHeight = height;
                 }
             }
-            updatePortDefinitions(updateCrop);
+            updatePortDefinitions(updateCrop, false);
             notify(OMX_EventPortSettingsChanged, kOutputPortIndex, 0, NULL);
             mOutputPortSettingsChange = AWAITING_DISABLED;
             *portWillReset = true;
         } else {
-            updatePortDefinitions(updateCrop);
+            updatePortDefinitions(updateCrop, false);
 
             if (fakeStride) {
                 // MAJOR HACK that is not pretty, it's just to fool the renderer to read the correct
diff --git a/services/camera/libcameraservice/device1/CameraHardwareInterface.h b/services/camera/libcameraservice/device1/CameraHardwareInterface.h
index 35947a9..7a61c56 100644
--- a/services/camera/libcameraservice/device1/CameraHardwareInterface.h
+++ b/services/camera/libcameraservice/device1/CameraHardwareInterface.h
@@ -627,6 +627,10 @@ private:
                       buffer_handle_t* buffer)
     {
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
         return a->queueBuffer(a,
                   container_of(buffer, ANativeWindowBuffer, handle), -1);
     }
@@ -635,6 +639,10 @@ private:
                       buffer_handle_t* buffer)
     {
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
         return a->cancelBuffer(a,
                   container_of(buffer, ANativeWindowBuffer, handle), -1);
     }
@@ -642,6 +650,10 @@ private:
     static int __set_buffer_count(struct preview_stream_ops* w, int count)
     {
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
         return native_window_set_buffer_count(a, count);
     }
 
@@ -650,6 +662,10 @@ private:
     {
         int rc;
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
 
         rc = native_window_set_buffers_dimensions(a, width, height);
         if (!rc) {
@@ -662,6 +678,10 @@ private:
                       int left, int top, int right, int bottom)
     {
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
         android_native_rect_t crop;
         crop.left = left;
         crop.top = top;
@@ -673,18 +693,30 @@ private:
     static int __set_timestamp(struct preview_stream_ops *w,
                                int64_t timestamp) {
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
         return native_window_set_buffers_timestamp(a, timestamp);
     }
 
     static int __set_usage(struct preview_stream_ops* w, int usage)
     {
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
         return native_window_set_usage(a, usage);
     }
 
     static int __set_swap_interval(struct preview_stream_ops *w, int interval)
     {
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
         return a->setSwapInterval(a, interval);
     }
 
@@ -693,6 +725,10 @@ private:
                       int *count)
     {
         ANativeWindow *a = anw(w);
+        if (!a) {
+            ALOGE("%s: ANativeWindow is NULL!", __FUNCTION__);
+            return 0;
+        }
         return a->query(a, NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS, count);
     }
 
diff --git a/services/camera/libcameraservice/gui/RingBufferConsumer.h b/services/camera/libcameraservice/gui/RingBufferConsumer.h
index 83e7298..4d98a58 100644
--- a/services/camera/libcameraservice/gui/RingBufferConsumer.h
+++ b/services/camera/libcameraservice/gui/RingBufferConsumer.h
@@ -136,12 +136,12 @@ class RingBufferConsumer : public ConsumerBase,
             return mBufferItem.mBuf == BufferQueue::INVALID_BUFFER_SLOT;
         }
 
-        BufferItem& getBufferItem() { return mBufferItem; }
-        const BufferItem& getBufferItem() const { return mBufferItem; }
+        BufferQueue::BufferItem& getBufferItem() { return mBufferItem; }
+        const BufferQueue::BufferItem& getBufferItem() const { return mBufferItem; }
 
       private:
         wp<RingBufferConsumer> mConsumer;
-        BufferItem             mBufferItem;
+        BufferQueue::BufferItem mBufferItem;
     };
 
     // Find a buffer using the filter, then pin it before returning it.
@@ -174,8 +174,8 @@ class RingBufferConsumer : public ConsumerBase,
     // Returns NOT_ENOUGH_DATA if list was empty.
     status_t releaseOldestBufferLocked(size_t* pinnedFrames);
 
-    struct RingBufferItem : public BufferItem {
-        RingBufferItem() : BufferItem(), mPinCount(0) {}
+    struct RingBufferItem : public BufferQueue::BufferItem {
+        RingBufferItem() : BufferQueue::BufferItem(), mPinCount(0) {}
         int mPinCount;
     };
 
diff --git a/services/soundtrigger/SoundTriggerHwService.cpp b/services/soundtrigger/SoundTriggerHwService.cpp
index a45d5f6..a1cc6ff 100644
--- a/services/soundtrigger/SoundTriggerHwService.cpp
+++ b/services/soundtrigger/SoundTriggerHwService.cpp
@@ -270,12 +270,12 @@ void SoundTriggerHwService::sendRecognitionEvent(struct sound_trigger_recognitio
      if (module == NULL) {
          return;
      }
-    struct sound_trigger_phrase_recognition_event newEvent;
     if (event-> type == SOUND_MODEL_TYPE_KEYPHRASE && event->data_size != 0
         && event->data_offset != sizeof(struct sound_trigger_phrase_recognition_event)) {
         // set some defaults for the phrase if the recognition event won't be parsed properly
         // TODO: read defaults from the config
 
+        struct sound_trigger_phrase_recognition_event newEvent;
         memset(&newEvent, 0, sizeof(struct sound_trigger_phrase_recognition_event));
 
         sp<Model> model = module->getModel(event->model);
-- 
2.7.4

