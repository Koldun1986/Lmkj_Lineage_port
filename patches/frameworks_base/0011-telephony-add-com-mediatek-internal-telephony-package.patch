From a64db96f945fbd93455e5664a056e87f7bf68c46 Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Sat, 26 Mar 2016 18:40:18 +0800
Subject: [PATCH] telephony: add com.mediatek.internal.telephony package

Change-Id: I28d10484bb9f4d362c759be891c6c767e6c9f638
---
 Android.mk                                         |   3 +
 .../internal/telephony/BtSimapOperResponse.aidl    |  39 ++
 .../internal/telephony/BtSimapOperResponse.java    | 271 +++++++++++
 .../internal/telephony/DefaultSmsSimSettings.java  |  81 ++++
 .../telephony/DefaultVoiceCallSubSettings.java     |  71 +++
 .../mediatek/internal/telephony/ITelephonyEx.aidl  | 520 +++++++++++++++++++++
 .../mediatek/internal/telephony/IccCardType.java   | 141 ++++++
 .../internal/telephony/IccSmsStorageStatus.aidl    |  50 ++
 .../internal/telephony/IccSmsStorageStatus.java    | 130 ++++++
 .../internal/telephony/SmsCbConfigInfo.aidl        |  50 ++
 .../internal/telephony/SmsCbConfigInfo.java        |  70 +++
 .../telephony/gsm/IGsmVideoCallCallback.aidl       |  54 +++
 .../telephony/gsm/IGsmVideoCallProvider.aidl       |  69 +++
 13 files changed, 1549 insertions(+)
 create mode 100755 telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl
 create mode 100755 telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.java
 create mode 100755 telephony/java/com/mediatek/internal/telephony/DefaultSmsSimSettings.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/DefaultVoiceCallSubSettings.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/IccCardType.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl

diff --git a/Android.mk b/Android.mk
index e7a6038fe1079..47ac718a7015c 100644
--- a/Android.mk
+++ b/Android.mk
@@ -421,6 +421,9 @@ LOCAL_SRC_FILES += \
 	packages/services/Proxy/com/android/net/IProxyCallback.aidl \
 	packages/services/Proxy/com/android/net/IProxyPortListener.aidl \
 	../../vendor/cmsdk/sdk/src/java/org/cyanogenmod/internal/themes/IIconCacheManager.aidl \
+    telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl \
+    telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl \
+    telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl \
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
 LOCAL_AIDL_INCLUDES += $(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
diff --git a/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl
new file mode 100755
index 0000000000000..ffe11c78929e5
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl
@@ -0,0 +1,39 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+parcelable BtSimapOperResponse;
+
diff --git a/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.java b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.java
new file mode 100755
index 0000000000000..9f73779e5330d
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.java
@@ -0,0 +1,271 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony;
+
+ import android.os.Parcel;
+ import android.os.Parcelable;
+ /**
+ * Represents the response information of BTSimap operation, including
+ * Received protocal type and APDU data.
+ * @hide
+ */
+public class BtSimapOperResponse implements Parcelable {
+    public static final int SUCCESS = 0;
+    public static final int ERR_NO_REASON_DEFINED = 1;    //CME ERROR: 611
+    public static final int ERR_CARD_NOT_ACCESSIBLE = 2;   //CME ERROR: 612
+    public static final int ERR_CARD_POWERED_OFF = 3;
+    public static final int ERR_CARD_REMOVED = 4;              // CME ERROR:613
+    public static final int ERR_CARD_POWERED_ON = 5;   // already power on
+    public static final int ERR_DATA_NOT_AVAILABLE = 6;
+    public static final int ERR_NOT_SUPPORTED = 7;
+
+    private static final byte CURTYPE_MASK = 0x01;
+    private static final byte SUPPORTTYPE_MASK = 0x02;
+    private static final byte ATR_MASK = 0x04;
+    private static final byte APDU_RESPONSE_MASK = 0x08;
+
+    static final int UNKNOWN_PROTOCOL_TYPE = -1;
+
+    private int mParams;
+    private int mCurType;
+    private int mSupportType;
+    private String mStrATR;
+    private String mStrAPDU;
+
+    public BtSimapOperResponse() {
+        mParams = 0;
+        mCurType = UNKNOWN_PROTOCOL_TYPE;
+        mSupportType = UNKNOWN_PROTOCOL_TYPE;
+        mStrATR = null;
+        mStrAPDU = null;
+    }
+
+    /**
+     * Initialize the object from a parcel.
+     */
+    public BtSimapOperResponse(Parcel in) {
+        mParams = in.readInt();
+        mCurType = in.readInt();
+        mSupportType = in.readInt();
+        mStrATR = in.readString();
+        mStrAPDU = in.readString();
+    }
+
+    public boolean isCurTypeExist() {
+        if ((mParams & CURTYPE_MASK) > 0) {
+            return true;
+        } else {
+           return false;
+        }
+    }
+
+    public boolean isSupportTypeExist() {
+        if ((mParams & SUPPORTTYPE_MASK) > 0) {
+            return true;
+        } else {
+           return false;
+        }
+    }
+
+    public boolean isAtrExist() {
+        if ((mParams & ATR_MASK) > 0) {
+            return true;
+        } else {
+           return false;
+        }
+    }
+
+    public boolean isApduExist() {
+        if ((mParams & APDU_RESPONSE_MASK) > 0) {
+            return true;
+        } else {
+           return false;
+        }
+    }
+
+    /**
+     * Get Current type.
+     *
+     * @return Current type
+     *
+     * @internal
+     */
+    public int getCurType() {
+        if (isCurTypeExist()) {
+            return mCurType;
+        } else {
+            return UNKNOWN_PROTOCOL_TYPE;
+        }
+    }
+
+    /**
+     * Get support type.
+     *
+     * @return support type
+     *
+     * @internal
+     */
+    public int getSupportType() {
+        if (isSupportTypeExist()) {
+            return mSupportType;
+        } else {
+            return UNKNOWN_PROTOCOL_TYPE;
+        }
+    }
+
+    /**
+     * Get ATR String.
+     *
+     * @return ATR String
+     *
+     * @internal
+     */
+    public String getAtrString() {
+        if (isAtrExist()) {
+            return mStrATR;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Get APDU String.
+     *
+     * @return APDU String
+     *
+     * @internal
+     */
+    public String getApduString() {
+        if (isApduExist()) {
+            return mStrAPDU;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Set cuurent type.
+     *
+     * @param nType current protool type.
+     *
+     * @internal
+     */
+    public void setCurType(int nType) {
+        if (nType == 0 || nType == 1) {
+            mCurType = nType;
+            mParams |= CURTYPE_MASK;
+        }
+    }
+
+    /**
+     * Set support type.
+     *
+     * @param nType protool type.
+     *
+     * @internal
+     */
+    public void setSupportType(int nType) {
+        if (nType == 0 || nType == 1 || nType == 2) {
+            mSupportType = nType;
+            mParams |= SUPPORTTYPE_MASK;
+        }
+    }
+
+    /**
+     * Set ATR String.
+     *
+     * @param strVal ATR string
+     *
+     * @internal
+     */
+    public void setAtrString(String strVal) {
+        if (strVal != null) {
+            mStrATR = strVal;
+            mParams |= ATR_MASK;
+        }
+    }
+
+    /**
+     * Set APDU String.
+     *
+     * @param strVal APDU string
+     *
+     * @internal
+     */
+    public void setApduString(String strVal) {
+        if (strVal != null) {
+            mStrAPDU = strVal;
+            mParams |= APDU_RESPONSE_MASK;
+        }
+    }
+
+    public void readFromParcel(Parcel source) {
+        mParams = source.readInt();
+        mCurType = source.readInt();
+        mSupportType = source.readInt();
+        mStrATR = source.readString();
+        mStrAPDU = source.readString();
+    }
+
+    /**
+     * {@link Parcelable#describeContents}
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * {@link Parcelable.Creator}
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<BtSimapOperResponse> CREATOR = new Parcelable.Creator() {
+        public BtSimapOperResponse createFromParcel(Parcel in) {
+            return new BtSimapOperResponse(in);
+        }
+
+        public BtSimapOperResponse[] newArray(int size) {
+            return new BtSimapOperResponse[size];
+        }
+    };
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mParams);
+        dest.writeInt(mCurType);
+        dest.writeInt(mSupportType);
+        dest.writeString(mStrATR);
+        dest.writeString(mStrAPDU);
+    }
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/DefaultSmsSimSettings.java b/telephony/java/com/mediatek/internal/telephony/DefaultSmsSimSettings.java
new file mode 100755
index 0000000000000..7142d780197df
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/DefaultSmsSimSettings.java
@@ -0,0 +1,81 @@
+
+package com.mediatek.internal.telephony;
+
+import android.util.Log;
+import android.provider.Settings;
+import android.telephony.SubscriptionManager;
+import android.telephony.SubscriptionInfo;
+import android.os.SystemProperties;
+import java.util.List;
+import android.content.Context;
+
+public class DefaultSmsSimSettings {
+    private static final String TAG = "DefaultSmsSimSettings";
+    public static final int ASK_USER_SUB_ID = -2;
+
+    public static void setSmsTalkDefaultSim(List<SubscriptionInfo> subInfos, Context context) {
+        /*
+        if (!"1".equals(SystemProperties.get("ro.mtk_bsp_package"))) {
+            int oldSmsDefaultSIM = SubscriptionManager.getDefaultSmsSubId();
+            Log.i(TAG, "oldSmsDefaultSIM" + oldSmsDefaultSIM);
+
+            if (subInfos == null) {
+                Log.i(TAG, "subInfos == null, return");
+                //SubscriptionManager.from(context).setDefaultSmsSubId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+            } else {
+                Log.i(TAG, "subInfos size = " + subInfos.size());
+                if (subInfos.size() > 1) {
+                    if (isoldDefaultSMSSubIdActive(subInfos)) {
+                        Log.i(TAG, "subInfos size > 1 & old available, set to :"
+                                + oldSmsDefaultSIM);
+                        //SubscriptionManager.from(context).setDefaultSmsSubId(oldSmsDefaultSIM);
+                    } else {
+                        if ("OP01".equals(SystemProperties.get("ro.operator.optr"))) {
+                            Log.i(TAG, "subInfos size > 1, set to : AUTO");
+                            SubscriptionManager.from(context)
+                                .setDefaultSmsSubId((int) Settings.System.SMS_SIM_SETTING_AUTO);
+                        }else if ("OP09".equals(SystemProperties.get("ro.operator.optr"))) {
+                            int firstSubId = SubscriptionManager.from(context)
+                                   .getActiveSubscriptionInfoForSimSlotIndex(0).getSubscriptionId();
+                            SubscriptionManager.from(context).setDefaultSmsSubId(firstSubId);
+                            Log.i(TAG, "subInfos size > 1, set to " + firstSubId);
+                        } else {
+                            Log.i(TAG, "subInfos size > 1, set to : ASK_USER_SUB_ID");
+                            //SubscriptionManager.from(context).setDefaultSmsSubId(ASK_USER_SUB_ID);
+                        }
+                    }
+                } else if (subInfos.size() == 1) {
+                    if ("OP09".equals(SystemProperties.get("ro.operator.optr"))) {
+                        int defaultSubId = subInfos.get(0).getSubscriptionId();
+                        SubscriptionManager.from(context).setDefaultSmsSubId(defaultSubId);
+                        Log.i(TAG, "subInfos size = 1, set to " + defaultSubId);
+                    }
+                    //SubscriptionManager.from(context).setDefaultSmsSubId(subInfos.get(0).getSubscriptionId());
+                } else {
+                    Log.i(TAG, "setSmsTalkDefaultSim SIM not insert");
+                    //SubscriptionManager.from(context).setDefaultSmsSubId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+                }
+            }
+        }
+        */
+    }
+
+    private static boolean isoldDefaultSMSSubIdActive(List<SubscriptionInfo> subInfos) {
+        int oldSmsDefaultSIM = SubscriptionManager.getDefaultSmsSubId();
+
+        for (SubscriptionInfo subInfo : subInfos) {
+            if (subInfo.getSubscriptionId() == oldSmsDefaultSIM) {
+                return true;
+            }
+        }
+        /*
+        if ("OP01".equals(SystemProperties.get("ro.operator.optr"))) {
+            if (oldSmsDefaultSIM == ASK_USER_SUB_ID ||
+                       oldSmsDefaultSIM == (int) Settings.System.SMS_SIM_SETTING_AUTO) {
+                return true;
+            }
+        }
+        */
+        return false;
+    }
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/DefaultVoiceCallSubSettings.java b/telephony/java/com/mediatek/internal/telephony/DefaultVoiceCallSubSettings.java
new file mode 100644
index 0000000000000..0afa19beae970
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/DefaultVoiceCallSubSettings.java
@@ -0,0 +1,71 @@
+package com.mediatek.internal.telephony;
+
+import java.util.List;
+
+import android.os.SystemProperties;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+
+/**
+ * This class is define the default voice call sub setting rule.
+ * 1. If there is no Sub inserted, the default voice call sub will be DEFAULT_SIM_NOT_SET.
+ * 2. If there is only one Sub, the default voice call sub will be that one.
+ * 3. If there are more than one Sub:
+ *      a. If the old default voice call sub is still available, the settings will not change.
+ *      b. If the old default voice call sub is not available, the settings will be ALWAYS_ASK.
+ */
+public class DefaultVoiceCallSubSettings {
+
+    private static final String LOG_TAG = "DefaultVoiceCallSubSettings";
+
+    public static void setVoiceCallDefaultSub(List<SubscriptionInfo> subInfos) {
+        if (!isMTKBspSupported()) {
+            int oldDefaultVoiceSubId = SubscriptionManager.getDefaultVoiceSubId();
+            logi("oldDefaultVoiceSubId = " + oldDefaultVoiceSubId);
+
+            if (subInfos == null) {
+                logi("subInfos == null, set to : INVALID_SUBSCRIPTION_ID");
+                // TODO: Fix this
+                //SubscriptionManager.setDefaultVoiceSubId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+            } else {
+                logi("subInfos size = " + subInfos.size());
+                if (subInfos.size() > 1) {
+                    if (isoldDefaultVoiceSubIdActive(subInfos)) {
+                        logi("subInfos size > 1 & old available, set to :" + oldDefaultVoiceSubId);
+                        //SubscriptionManager.setDefaultVoiceSubId(oldDefaultVoiceSubId);
+                    } else {
+                        logi("subInfos size > 1, set to : ASK_USER");
+                        //SubscriptionManager.setDefaultVoiceSubId(SubscriptionManager.ASK_USER_SUB_ID);
+                    }
+                } else if (subInfos.size() == 1) {
+                    logi("subInfos size == 1, set to :" + subInfos.get(0).getSubscriptionId());
+                    //SubscriptionManager.setDefaultVoiceSubId(subInfos.get(0).subId);
+                } else {
+                    logi("subInfos size = 0 set of : INVALID_SUBSCRIPTION_ID");
+                    //SubscriptionManager.setDefaultVoiceSubId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+                }
+            }
+        }
+    }
+
+    private static boolean isMTKBspSupported() {
+        boolean isSupport = "1".equals(SystemProperties.get("ro.mtk_bsp_package"));
+        logi("isMTKBspSupported(): " + isSupport);
+        return isSupport;
+    }
+
+    private static boolean isoldDefaultVoiceSubIdActive(List<SubscriptionInfo> subInfos) {
+        int oldDefaultVoiceSubId = SubscriptionManager.getDefaultVoiceSubId();
+        for (SubscriptionInfo subInfo : subInfos) {
+            if (subInfo.getSubscriptionId() == oldDefaultVoiceSubId) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static void logi(String msg) {
+        Log.i(LOG_TAG, msg);
+    }
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl b/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl
new file mode 100644
index 0000000000000..51773f3fa008b
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl
@@ -0,0 +1,520 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+
+import android.net.LinkProperties;
+
+import android.os.Bundle;
+import android.os.Message;
+
+import android.telephony.RadioAccessFamily;
+
+import com.mediatek.internal.telephony.BtSimapOperResponse;
+
+/**
+ * Interface used to interact with the phone.  Mostly this is used by the
+ * TelephonyManager class.  A few places are still using this directly.
+ * Please clean them up if possible and use TelephonyManager insteadl.
+ *
+ * {@hide}
+ */
+interface ITelephonyEx {
+
+    Bundle queryNetworkLock(int subId, int category);
+
+    int supplyNetworkDepersonalization(int subId, String strPasswd);
+
+    /**
+     * Modem SML change feature.
+     * This function will query the SIM state of the given slot. And broadcast
+     * ACTION_UNLOCK_SIM_LOCK if the SIM state is in network lock.
+     *
+     * @param subId: Indicate which sub to query
+     * @param needIntent: The caller can deside to broadcast ACTION_UNLOCK_SIM_LOCK or not
+     *                    in this time, because some APs will receive this intent (eg. Keyguard).
+     *                    That can avoid this intent to effect other AP.
+     */
+    void repollIccStateForNetworkLock(int subId, boolean needIntent);
+
+    int setLine1Number(int subId, String alphaTag, String number);
+
+    boolean isFdnEnabled(int subId);
+
+    String getIccCardType(int subId);
+
+    /**
+     * Request to get UICC card type.
+     *
+     * @param slotId indicated sim id
+     *
+     * @return index for UICC card type
+     *
+     */
+    int getSvlteCardType(int slotId);
+
+    boolean isAppTypeSupported(int slotId, int appType);
+
+    boolean isTestIccCard(int slotId);
+
+    String getMvnoMatchType(int subId);
+
+    String getMvnoPattern(int subId, String type);
+
+    String getNetworkOperatorNameGemini(int slotId);
+    String getNetworkOperatorNameUsingSub(int subId);
+
+    String getNetworkOperatorGemini(int slotId);
+    String getNetworkOperatorUsingSub(int subId);
+
+    /**
+     *send BT SIM profile of Connect SIM
+     * @param simId specify which SIM to connect
+     * @param btRsp fetch the response data.
+     * @return success or error code.
+     */
+    int btSimapConnectSIM(int simId,  out BtSimapOperResponse btRsp);
+
+    /**
+     *send BT SIM profile of Disconnect SIM
+     * @param null
+     * @return success or error code.
+     */
+    int btSimapDisconnectSIM();
+
+   /**
+     *Transfer APDU data through BT SAP
+     * @param type Indicate which transport protocol is the preferred one
+     * @param cmdAPDU APDU data to transfer in hex character format
+     * @param btRsp fetch the response data.
+     * @return success or error code.
+     */
+    int btSimapApduRequest(int type, String cmdAPDU, out BtSimapOperResponse btRsp);
+
+    /**
+     *send BT SIM profile of Reset SIM
+     * @param type Indicate which transport protocol is the preferred one
+     * @param btRsp fetch the response data.
+     * @return success or error code.
+     */
+    int btSimapResetSIM(int type, out BtSimapOperResponse btRsp);
+
+   /**
+     *send BT SIM profile of Power On SIM
+     * @param type Indicate which transport protocol is the preferred onet
+     * @param btRsp fetch the response data.
+     * @return success or error code.
+     */
+    int btSimapPowerOnSIM(int type, out BtSimapOperResponse btRsp);
+
+   /**
+     *send BT SIM profile of PowerOff SIM
+     * @return success or error code.
+     */
+    int btSimapPowerOffSIM();
+
+    /**
+     * Request to run AKA authenitcation on UICC card by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteRand random challenge in byte array
+     * @param byteAutn authenication token in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    byte[] simAkaAuthentication(int slotId, int family, in byte[] byteRand, in byte[] byteAutn);
+
+    /**
+     * Request to run GBA authenitcation (Bootstrapping Mode)on UICC card
+     * by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteRand random challenge in byte array
+     * @param byteAutn authenication token in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    byte[] simGbaAuthBootStrapMode(int slotId, int family, in byte[] byteRand, in byte[] byteAutn);
+
+    /**
+     * Request to run GBA authenitcation (NAF Derivation Mode)on UICC card
+     * by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteNafId network application function id in byte array
+     * @param byteImpi IMS private user identity in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    byte[] simGbaAuthNafMode(int slotId, int family, in byte[] byteNafId, in byte[] byteImpi);
+
+    /**
+     * Since MTK keyguard has dismiss feature, we need to retrigger unlock event
+     * when user try to access the SIM card.
+     *
+     * @param subId inidicated subscription
+     *
+     * @return true represent broadcast a unlock intent to notify keyguard
+     *         false represent current state is not LOCKED state. No need to retrigger.
+     *
+     */
+    boolean broadcastIccUnlockIntent(int subId);
+
+    /**
+     * Query if the radio is turned off by user.
+     *
+     * @param subId inidicated subscription
+     *
+     * @return true radio is turned off by user.
+     *         false radio isn't turned off by user.
+     *
+     */
+    boolean isRadioOffBySimManagement(int subId);
+
+    /**
+     * Get current phone capability
+     *
+     * @return the capability of phone. (@see PhoneConstants)
+     * @internal
+     */
+    int getPhoneCapability(int phoneId);
+
+    /**
+     * Set capability to phones
+     *
+     * @param phoneId phones want to change capability
+     * @param capability new capability for each phone
+     * @internal
+     */
+    void setPhoneCapability(in int[] phoneId, in int[] capability);
+    /**
+     * To config SIM swap mode(for dsda).
+     *
+     * @return true if config SIM Swap mode successful, or return false
+     * @internal
+     */
+    boolean configSimSwap(boolean toSwapped);
+    /**
+     * To check SIM is swapped or not(for dsda).
+     *
+     * @return true if swapped, or return false
+     * @internal
+     */
+    boolean isSimSwapped();
+    /**
+     * To Check if Capability Switch Manual Control Mode Enabled.
+     *
+     * @return true if Capability Switch manual control mode is enabled, else false;
+     * @internal
+     */
+    boolean isCapSwitchManualEnabled();
+
+    /**
+     * Get item list that will be displayed on manual switch setting
+     *
+     * @return String[] contains items
+     * @internal
+     */
+    String[] getCapSwitchManualList();
+
+  /**
+     * To get located PLMN from sepcified SIM modem  protocol
+     * Returns current located PLMN string(ex: "46000") or null if not availble (ex: in flight mode or no signal area or this SIM is turned off)
+     * @param subId Indicate which SIM subscription to query
+     * @internal
+     */
+    String getLocatedPlmn(int subId);
+
+   /**
+     * Check if phone is hiding network temporary out of service state.
+     * @param subId Indicate which SIM subscription to query
+     * @return if phone is hiding network temporary out of service state.
+     * @internal
+    */
+    int getNetworkHideState(int subId);
+
+   /**
+     * get the network service state for specified SIM
+     * @param subId Indicate which SIM subscription to query
+     * @return service state.
+     * @internal
+    */
+    Bundle getServiceState(int subId);
+
+    /**
+     * This function is used to get SIM phonebook storage information
+     * by sim id.
+     *
+     * @param simId Indicate which sim(slot) to query
+     * @return int[] which incated the storage info
+     *         int[0]; // # of remaining entries
+     *         int[1]; // # of total entries
+     *         int[2]; // # max length of number
+     *         int[3]; // # max length of alpha id
+     *
+     * @internal
+     */
+    int[] getAdnStorageInfo(int subId);
+
+    /**
+     * This function is used to check if the SIM phonebook is ready
+     * by sim id.
+     *
+     * @param simId Indicate which sim(slot) to query
+     * @return true if phone book is ready.
+     * @internal
+     */
+    boolean isPhbReady(int subId);
+
+    /**
+     * Get service center address
+     *
+     * @param subId subscription identity
+     *
+     * @return bundle value with error code and service message center address
+     */
+    Bundle getScAddressUsingSubId(in int subId);
+
+    /**
+     * Set service message center address
+     *
+     * @param subId subscription identity
+     * @param service message center addressto be set
+     *
+     * @return true for success, false for failure
+     */
+    boolean setScAddressUsingSubId(in int subId, in String address);
+
+    /**
+     * This function will check if phone can enter airplane mode right now
+     *
+     * @return boolean: return phone can enter flight mode
+     *                true: phone can enter flight mode
+     *                false: phone cannot enter flight mode
+     */
+    boolean isAirplanemodeAvailableNow();
+
+    // VoLTE
+    /**
+     * This function will get DcFailCause with int format.
+     *
+     * @return int: return int failCause value
+     */
+    int getLastDataConnectionFailCause(String apnType, int phoneId);
+
+    /**
+     * This function will get link properties of input apn type.
+     *
+     * @param apnType input apn type for geting link properties
+     * @return LinkProperties: return correspondent link properties with input apn type
+     */
+    LinkProperties getLinkProperties(String apnType, int phoneId);
+
+    /**
+     * Set phone radio type and access technology.
+     *
+     * @param rafs an RadioAccessFamily array to indicate all phone's
+     *        new radio access family. The length of RadioAccessFamily
+     *        must equal to phone count.
+     * @return true if start setPhoneRat successfully.
+     */
+    boolean setRadioCapability(in RadioAccessFamily[] rafs);
+
+    /**
+     * Check if under capability switching.
+     *
+     * @return true if switching
+     */
+    boolean isCapabilitySwitching();
+
+    /// M: [C2K][SVLTE] Switch SVLTE RAT mode. @{
+    /**
+     * Switch SVLTE RAT mode.
+     * @param mode the RAT mode.
+     * @return void
+     */
+    void switchSvlteRatMode(int mode);
+
+    /**
+     * Set SVLTE RAT mode.
+     * @param mode the RAT mode.
+     * @param subId subscription ID to be queried
+     * @return void
+     */
+    void setSvlteRatMode(int mode, int subId);
+
+    /**
+     * Get the ServiceState for Svlte.
+     * @param subId for getting the current ServiceState for Svlte.
+     */
+    Bundle getSvlteServiceState(int subId);
+
+    /**
+     * Switch SVLTE RAT mode.
+     * @param mode the RAT mode.
+     */
+    void switchRadioTechnology(int networkType);
+
+    /**
+     * Set SVLTE Radio Technology.
+     * @param networkType the networktype want to switch.
+     * @param subId subscription ID to be queried
+     */
+    void setRadioTechnology(int networkType, int subId);
+    /// @}
+
+    /**
+    * Set TRM
+    *
+    * @param mode indicate which case want to set to modem
+    */
+    void setTrmForPhone(int phoneId, int mode);
+
+    /**
+     * Get subscriber Id of LTE phone.
+     * @param subId the subId of CDMAPhone
+     * @return The subscriber Id of LTE phone.
+     */
+    String getSubscriberIdForLteDcPhone(int subId);
+
+    /**
+     * Get Svlte imei.
+     * @param slotId slot id.
+     * @return String: imei.
+     */
+    String getSvlteImei(int slotId);
+
+    /**
+     * Get main capability phone id.
+     * @return The phone id with highest capability.
+     */
+    int getMainCapabilityPhoneId();
+
+    /**
+     * Return true if allow the airplane mode change.
+     */
+    boolean isAllowAirplaneModeChange();
+
+   /**
+     * Initialze external SIM service on phone process.
+     *
+     * @hide
+     */
+    void initializeService(String serviceName);
+
+   /**
+     * Finalize external SIM service on phone process.
+     *
+     * @hide
+     */
+    void finalizeService(String serviceName);
+
+    /**
+     * Return the sim card if in home network.
+     *
+     * @param subId subscription ID to be queried
+     * @return true if in home network
+     */
+    boolean isInHomeNetwork(int subId);
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    /**
+     * Set LTE access stratum urc report
+     * @param enabled the LTE AS state URC report is enable or disable
+     * @return true if enabled/disable urc report successfully.
+     */
+    boolean setLteAccessStratumReport(boolean enabled);
+
+    /**
+     * Set LTE uplink data transfer
+     * @param isOn the LTE uplink data transfer is on or off
+     * @param timeMillis the close timer
+     * @return true if enabled/disable uplink data transfer successfully.
+     */
+    boolean setLteUplinkDataTransfer(boolean isOn, int timeMillis);
+
+    /**
+     * Get LTE access stratum state
+     * @return unknown/idle/connected if abnormal mode/power saving mode candidate/normal power mode.
+     */
+    String getLteAccessStratumState();
+
+    /**
+     * Get if shared default type apn
+     * @return true if is shared default type apn occurred.
+     */
+    boolean isSharedDefaultApn();
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /**
+     * Get Svlte meid.
+     * @param slotId slot id.
+     * @return String: meid.
+     */
+    String getSvlteMeid(int slotId);
+}
+
diff --git a/telephony/java/com/mediatek/internal/telephony/IccCardType.java b/telephony/java/com/mediatek/internal/telephony/IccCardType.java
new file mode 100644
index 0000000000000..24de6f66307cd
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/IccCardType.java
@@ -0,0 +1,141 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+/**
+ * Report ICC Card Type.
+ */
+public class IccCardType {
+
+    /**
+      * This card type is report by SVLTE modems.
+      * {@hide}
+      */
+    public enum SvlteCardType {
+        INVALID_CARD(0),         //Invalid card type
+        UIM_CARD(1),             //With RUIM application
+        SIM_CARD(2),             //With only SIM application
+        UIM_SIM_CARD(3),         //With RUIM & SIM application, non CT dual mode card
+        UNKNOW_CARD(4),          //card is present, but can't detect type
+        CT_3G_UIM_CARD(5),       //With RUIM application, CT 3G UIM card
+        CT_UIM_SIM_CARD(6),      //With RUIM & SIM application, CT 3G dual mode card
+        PIN_LOCK_CARD(7),        //this card need PIN
+        CT_4G_UICC_CARD(8),      //With USIM & CSIM application, CT 4G dual mode UICC card
+        NOT_CT_UICC_CARD(9),     //With USIM & CSIM application, Non CT, 4G dual mode UICC card
+        LOCKED_CARD(18),         //card is locked
+        USIM_CARD(100),          //With USIM application only
+        CARD_NOT_INSERTED(255);  //card is not inserted
+
+        private int mValue;
+
+        public int getValue() {
+            return mValue;
+        }
+
+        /**
+         * Get CardType from integer.
+         * ASSERT: Please DON'T directly use CardType.values(), otherwise JE will occur
+         *
+         * @param cardTypeInt for cardType index.
+         * @return SvlteCardType.
+         */
+        public static SvlteCardType getCardTypeFromInt(int cardTypeInt) {
+            SvlteCardType cardType = INVALID_CARD;
+            SvlteCardType[] cardTypes = SvlteCardType.values();
+            for (int i = 0; i < cardTypes.length; i++) {
+                if (cardTypes[i].getValue() == cardTypeInt) {
+                    cardType = cardTypes[i];
+                    break;
+                }
+            }
+            return cardType;
+        }
+
+        /**
+         * Get CardType from String.
+         *
+         * @param cardType for card applications.
+         * @return SvlteCardType.
+         */
+        public static SvlteCardType transformCardTypeFromString(String cardType) {
+            if ("USIM".equals(cardType)) {
+                return USIM_CARD;
+            } else if ("SIM".equals(cardType)) {
+                return SIM_CARD;
+            } else {
+                return INVALID_CARD;
+            }
+        }
+
+        /**
+         * Check if it is 4G card.
+         *
+         * @return true if it is 4G card
+         */
+        public boolean is4GCard() {
+            return ((this == CT_4G_UICC_CARD) || (this == NOT_CT_UICC_CARD));
+        }
+
+        /**
+         * Check if it is 3G card.
+         *
+         * @return true if it is 3G card
+         */
+        public boolean is3GCard() {
+            return ((this == UIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_3G_UIM_CARD) || (this == CT_UIM_SIM_CARD));
+        }
+
+        /**
+         * Check if it is dual mode card.
+         *
+         * @return true if it is dual mode card
+         */
+        public boolean isDualModeCard() {
+            return ((this == UIM_SIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_4G_UICC_CARD) || (this == NOT_CT_UICC_CARD));
+        }
+
+        /**
+         * Check if it is OP09 card.
+         *
+         * @return true if it is OP09 card
+         */
+        public boolean isOPO9Card() {
+            return ((this == CT_3G_UIM_CARD) || (this == CT_UIM_SIM_CARD)
+            || (this == CT_4G_UICC_CARD));
+        }
+
+        /**
+         * Check if it is a valid card type.
+         *
+         * @return true if it is
+         */
+        public boolean isValidCardType() {
+            return this != INVALID_CARD;
+        }
+
+        private SvlteCardType(int value) {
+            mValue = value;
+        }
+    }
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl b/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl
new file mode 100644
index 0000000000000..ff852f739068b
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl
@@ -0,0 +1,50 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/*
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package com.mediatek.internal.telephony;
+
+parcelable IccSmsStorageStatus;
diff --git a/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.java b/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.java
new file mode 100644
index 0000000000000..66766171ea4ab
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.java
@@ -0,0 +1,130 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ *
+ * @internal
+ *
+ */
+public class IccSmsStorageStatus implements Parcelable {
+    public int mUsed;
+    public int mTotal;
+
+    public IccSmsStorageStatus() {
+        mUsed = 0;
+        mTotal = 0;
+    }
+
+    public IccSmsStorageStatus(int used, int total) {
+        mUsed = used;
+        mTotal = total;
+    }
+
+    /**
+     * Get the used count of sim sms memory.
+     *
+     * @return number of used sim sms memory
+     *
+     * @internal
+     */
+    public int getUsedCount() {
+        return mUsed;
+    }
+
+    /**
+     * Get the total count of sim sms memory.
+     *
+     * @return number of total sim sms memory
+     *
+     * @internal
+     */
+    public int getTotalCount() {
+        return mTotal;
+    }
+
+    public int getUnused() {
+        return (mTotal - mUsed);
+    }
+
+    public void reset() {
+        mUsed = 0;
+        mTotal = 0;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mUsed);
+        dest.writeInt(mTotal);
+    }
+
+    public static final Parcelable.Creator<IccSmsStorageStatus> CREATOR = new Parcelable.Creator<IccSmsStorageStatus>() {
+        public IccSmsStorageStatus createFromParcel(Parcel source) {
+            int used;
+            int total;
+
+            used = source.readInt();
+            total = source.readInt();
+            return new IccSmsStorageStatus(used, total);
+        }
+
+        public IccSmsStorageStatus[] newArray(int size) {
+            return new IccSmsStorageStatus[size];
+        }
+    };
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl b/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl
new file mode 100644
index 0000000000000..c2693af77a7c9
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl
@@ -0,0 +1,50 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/*
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package com.mediatek.internal.telephony;
+
+parcelable SmsCbConfigInfo;
diff --git a/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.java b/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.java
new file mode 100644
index 0000000000000..91240490379e5
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.java
@@ -0,0 +1,70 @@
+/*
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+
+package com.mediatek.internal.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ *  A parcelable holder class of byte[] for ISms aidl implementation
+ */
+public class SmsCbConfigInfo implements Parcelable {
+    public int mFromServiceId;
+    public int mToServiceId;
+    public int mFromCodeScheme;
+    public int mToCodeScheme;
+    public boolean mSelected;
+
+    public SmsCbConfigInfo(int fromId, int toId, int fromScheme,
+            int toScheme, boolean selected) {
+        this.mFromServiceId = fromId;
+        this.mToServiceId = toId;
+        this.mFromCodeScheme = fromScheme;
+        this.mToCodeScheme = toScheme;
+        this.mSelected = selected;
+    }
+
+    public static final Parcelable.Creator<SmsCbConfigInfo> CREATOR = new Parcelable.Creator<SmsCbConfigInfo>() {
+        public SmsCbConfigInfo createFromParcel(Parcel source) {
+            int mFromServiceId = source.readInt();
+            int mToServiceId = source.readInt();
+            int mFromCodeScheme = source.readInt();
+            int mToCodeScheme = source.readInt();
+            boolean mSelected = source.readByte() != 0;
+
+            return new SmsCbConfigInfo(mFromServiceId, mToServiceId, mFromCodeScheme, mToCodeScheme, mSelected);
+        }
+
+        public SmsCbConfigInfo[] newArray(int size) {
+            return new SmsCbConfigInfo[size];
+        }
+    };
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mFromServiceId);
+        dest.writeInt(mToServiceId);
+        dest.writeInt(mFromCodeScheme);
+        dest.writeInt(mToCodeScheme);
+        dest.writeByte((byte) (mSelected ? 1 : 0));
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl b/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl
new file mode 100644
index 0000000000000..ab6ead1892bef
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl
@@ -0,0 +1,54 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.mediatek.internal.telephony.gsm;
+
+import android.telecom.VideoProfile;
+
+/**
+ * Internal remote interface for GSM's video call provider.
+ *
+ * At least initially, this aidl mirrors telecom's {@link VideoCallCallback}. We created a
+ * separate aidl interface for invoking callbacks in Telephony from the GSM Service to without
+ * accessing internal interfaces. See {@link IGsmVideoCallProvider} for additional detail.
+ *
+ * @see android.telecom.internal.IVideoCallCallback
+ * @see android.telecom.VideoCallImpl
+ *
+ * {@hide}
+ */
+oneway interface IGsmVideoCallCallback {
+    void receiveSessionModifyRequest(in VideoProfile videoProfile);
+
+    void receiveSessionModifyResponse(int status, in VideoProfile requestedProfile,
+        in VideoProfile responseProfile);
+
+    void handleCallSessionEvent(int event);
+
+    void changePeerDimensions(int width, int height);
+
+    /* M: ViLTE part start */
+    /* Different from AOSP, additional parameter "rotation" is added. */
+    void changePeerDimensionsWithAngle(int width, int height, int rotation);
+    /* M: ViLTE part end */
+
+    void changeCallDataUsage(long dataUsage);
+
+    void changeCameraCapabilities(in VideoProfile.CameraCapabilities cameraCapabilities);
+
+    void changeVideoQuality(int videoQuality);
+}
+
diff --git a/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl b/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl
new file mode 100644
index 0000000000000..987a3dd76697a
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl
@@ -0,0 +1,69 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.mediatek.internal.telephony.gsm;
+
+import android.net.Uri;
+import android.view.Surface;
+import android.telecom.VideoProfile;
+
+import com.mediatek.internal.telephony.gsm.IGsmVideoCallCallback;
+
+/**
+ * Internal remote interface for GSM's video call provider.
+ *
+ * At least initially, this aidl mirrors telecom's {@link IVideoCallProvider}. We created a
+ * separate aidl interface even though the methods and parameters are same because the
+ * {@link IVideoCallProvider} was specifically created as a binder for inter-process communication
+ * between Telecomm and Telephony.
+ *
+ * We don't want to use the same aidl in other places for communication, namely communication
+ * between Telephony and the GSM Service, even if that communication may be for similar methods.
+ * This decouples the communication among these processes. Similarly, third parties implementing a
+ * video call provider will not have the benefit of accessing the internal
+ * {@link IVideoCallProvider} aidl for interprocess communication.
+ *
+ * @see android.telecom.internal.IVideoCallProvider
+ * @see android.telecom.VideoCallProvider
+ * @hide
+ */
+oneway interface IGsmVideoCallProvider {
+    void setCallback(IGsmVideoCallCallback callback);
+
+    void setCamera(String cameraId);
+
+    void setPreviewSurface(in Surface surface);
+
+    void setDisplaySurface(in Surface surface);
+
+    void setDeviceOrientation(int rotation);
+
+    void setZoom(float value);
+
+    void sendSessionModifyRequest(in VideoProfile fromProfile, in VideoProfile toProfile);
+
+    void sendSessionModifyResponse(in VideoProfile responseProfile);
+
+    void requestCameraCapabilities();
+
+    void requestCallDataUsage();
+
+    void setPauseImage(in Uri uri);
+
+    /* M: ViLTE part start */
+    void setUIMode(int mode);
+    /* M: ViLTE part end */
+}
