From 674628a0fe88453175c1e7c69b1d28b793d1710a Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Sun, 27 Mar 2016 18:08:31 +0800
Subject: [PATCH] mtk: add com.mediatek.telephony package

Change-Id: Ia3d0023a0b5b55198594779856101af8792a2e14
---
 .../mediatek/telephony/ExternalSimConstants.java   |  100 +
 .../com/mediatek/telephony/ExternalSimManager.java | 1272 ++++++++++
 .../telephony/PhoneNumberFormatUtilEx.java         | 2431 ++++++++++++++++++++
 .../PhoneNumberFormattingTextWatcherEx.java        |  135 ++
 .../com/mediatek/telephony/TelephonyManagerEx.java | 1368 +++++++++++
 5 files changed, 5306 insertions(+)
 create mode 100644 src/java/com/mediatek/telephony/ExternalSimConstants.java
 create mode 100644 src/java/com/mediatek/telephony/ExternalSimManager.java
 create mode 100755 src/java/com/mediatek/telephony/PhoneNumberFormatUtilEx.java
 create mode 100755 src/java/com/mediatek/telephony/PhoneNumberFormattingTextWatcherEx.java
 create mode 100644 src/java/com/mediatek/telephony/TelephonyManagerEx.java

diff --git a/src/java/com/mediatek/telephony/ExternalSimConstants.java b/src/java/com/mediatek/telephony/ExternalSimConstants.java
new file mode 100644
index 0000000000..928b67c9fb
--- /dev/null
+++ b/src/java/com/mediatek/telephony/ExternalSimConstants.java
@@ -0,0 +1,100 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.telephony;
+
+/**
+ * @hide
+ */
+public class ExternalSimConstants {
+    // External SIM to platform
+    public static final int MSG_ID_INITIALIZATION_REQUEST           = 1;
+    public static final int MSG_ID_GET_PLATFORM_CAPABILITY_REQUEST  = 2;
+    public static final int MSG_ID_EVENT_REQUEST                    = 3;
+    public static final int MSG_ID_UICC_RESET_RESPONSE              = 4;
+    public static final int MSG_ID_UICC_APDU_RESPONSE               = 5;
+    public static final int MSG_ID_UICC_POWER_DOWN_RESPONSE         = 6;
+    public static final int MSG_ID_GET_SERVICE_STATE_REQUEST        = 7;
+    public static final int MSG_ID_FINALIZATION_REQUEST             = 8;
+
+    // Type id of MSG_ID_EVENT_REQUEST event
+    public static final int REQUEST_TYPE_ENABLE_EXTERNAL_SIM        = 1;
+    public static final int REQUEST_TYPE_DISABLE_EXTERNAL_SIM       = 2;
+    public static final int REQUEST_TYPE_PLUG_OUT                   = 3;
+    public static final int REQUEST_TYPE_PLUG_IN                    = 4;
+
+    // SIM type
+    public static final int SIM_TYPE_LOCAL_SIM  = 1;
+    public static final int SIM_TYPE_REMOTE_SIM = 2;
+
+    // Response result
+    public static final int RESPONSE_RESULT_OK                  = 0;
+    public static final int RESPONSE_RESULT_GENERIC_ERROR       = -1;
+    public static final int RESPONSE_RESULT_PLATFORM_NOT_READY  = -2;
+
+    // Platform to external SIM
+    public static final int MSG_ID_INITIALIZATION_RESPONSE          = 1001;
+    public static final int MSG_ID_GET_PLATFORM_CAPABILITY_RESPONSE = 1002;
+    public static final int MSG_ID_EVENT_RESPONSE                   = 1003;
+    public static final int MSG_ID_UICC_RESET_REQUEST               = 1004;
+    public static final int MSG_ID_UICC_APDU_REQUEST                = 1005;
+    public static final int MSG_ID_UICC_POWER_DOWN_REQUEST          = 1006;
+    public static final int MSG_ID_GET_SERVICE_STATE_RESPONSE       = 1007;
+    public static final int MSG_ID_FINALIZATION_RESPONSE            = 1008;
+
+    // Platfrom capability parameters
+    public static final int MULTISIM_CONFIG_UNKNOWN = 0;
+    public static final int MULTISIM_CONFIG_DSDS = 1;
+    public static final int MULTISIM_CONFIG_DSDA = 2;
+    public static final int MULTISIM_CONFIG_TSTS = 3;
+}
+
+
diff --git a/src/java/com/mediatek/telephony/ExternalSimManager.java b/src/java/com/mediatek/telephony/ExternalSimManager.java
new file mode 100644
index 0000000000..e9e25b7788
--- /dev/null
+++ b/src/java/com/mediatek/telephony/ExternalSimManager.java
@@ -0,0 +1,1272 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.telephony;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.LocalServerSocket;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+
+import android.telephony.SubscriptionManager;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+import android.telephony.TelephonyManager.MultiSimVariants;
+
+import com.android.internal.telephony.IccUtils;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.SubscriptionController;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.internal.telephony.uicc.UiccController;
+
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+import com.mediatek.internal.telephony.RadioManager;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
+/**
+ * @hide
+ */
+public class ExternalSimManager {
+    private static final String TAG = "ExternalSimManager";
+
+    private static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
+
+    private static ExternalSimManager sInstance = null;
+    private VsimEvenHandler mEventHandler = null;
+    private VsimIoThread mRilIoThread = null;
+    private boolean isMdWaitingResponse = false;
+
+    static final String[] PROPERTY_RIL_FULL_UICC_TYPE = {
+        "gsm.ril.fulluicctype",
+        "gsm.ril.fulluicctype.2",
+        "gsm.ril.fulluicctype.3",
+        "gsm.ril.fulluicctype.4",
+    };
+
+    /*  Construction function for TelephonyManager */
+    public ExternalSimManager() {
+        Rlog.d(TAG, "construtor 0 parameter is called - done");
+    }
+
+    private ExternalSimManager(Context context) {
+        Rlog.d(TAG, "construtor 1 parameter is called - start");
+
+        mEventHandler = new VsimEvenHandler();
+
+        new Thread() {
+            public void run() {
+                ServerTask server = new ServerTask();
+                server.listenConnection(mEventHandler);
+            }
+        }.start();
+
+        // Need to reset system properties when shutdown ipo to avoid receiving unexcepted
+        // intetnt in case of IPO boot up.
+        IntentFilter intentFilter = new IntentFilter("android.intent.action.ACTION_SHUTDOWN_IPO");
+        context.registerReceiver(sReceiver, intentFilter);
+
+        Rlog.d(TAG, "construtor is called - end");
+    }
+
+    /** @hide
+     *  @return return the static instance of ExternalSimManager
+     */
+    public static ExternalSimManager getDefault(Context context) {
+        Rlog.d(TAG, "getDefault()");
+        if (sInstance == null) {
+            sInstance = new ExternalSimManager(context);
+        }
+        return sInstance;
+    }
+
+    private static ITelephonyEx getITelephonyEx() {
+        return ITelephonyEx.Stub.asInterface(
+                ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+    }
+
+    // Need to reset system properties when shutdown ipo to avoid receiving unexcepted
+    // intetnt in case of IPO boot up.
+    private final BroadcastReceiver sReceiver = new  BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Rlog.d(TAG,"[Receiver]+");
+            String action = intent.getAction();
+            Rlog.d(TAG,"Action: " + action);
+
+            if (action.equals("android.intent.action.ACTION_SHUTDOWN_IPO")) {
+                // set system property to note that sim enabled
+                SystemProperties.set(TelephonyProperties.PROPERTY_EXTERNAL_SIM_ENABLED, "");
+                SystemProperties.set(TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "");
+            }
+            Rlog.d(TAG,"[Receiver]-");
+        }
+    };
+
+    public boolean initializeService(byte[] userData) {
+        Rlog.d(TAG, "initializeService() - start");
+
+        if (SystemProperties.getInt("ro.mtk_external_sim_support", 0) == 0) {
+            Rlog.d(TAG, "initializeService() - mtk_external_sim_support didn't support");
+            return false;
+        }
+
+        try {
+            getITelephonyEx().initializeService("osi");
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+        Rlog.d(TAG, "initialize() - end");
+        return true;
+    }
+
+    public boolean finalizeService(byte[] userData) {
+        Rlog.d(TAG, "finalizeService() - start");
+
+        if (SystemProperties.getInt("ro.mtk_external_sim_support", 0) == 0) {
+            Rlog.d(TAG, "initializeService() - mtk_external_sim_support didn't support");
+            return false;
+        }
+
+        try {
+            getITelephonyEx().finalizeService("osi");
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+        Rlog.d(TAG, "finalizeService() - end");
+        return true;
+    }
+
+    /**
+     * Maintain a server task to provide extenal client to connect to do
+     * some external SIM operation.
+     *
+     */
+    public class ServerTask {
+        public static final String HOST_NAME = "vsim-adaptor";
+        private VsimIoThread ioThread = null;
+
+        public void listenConnection(VsimEvenHandler eventHandler) {
+            Rlog.d(TAG, "listenConnection() - start");
+
+            LocalServerSocket serverSocket = null;
+            ExecutorService threadExecutor = Executors.newCachedThreadPool();
+
+            try {
+                // Create server socket
+                serverSocket = new LocalServerSocket(HOST_NAME);
+
+                while(true) {
+                    // Allow multiple connection connect to server.
+                    LocalSocket socket = serverSocket.accept();
+                    Rlog.d(TAG, "There is a client is accpted: " + socket.toString());
+
+                    threadExecutor.execute(new ConnectionHandler(socket, eventHandler));
+                }
+            } catch (IOException e) {
+                Rlog.d(TAG, "listenConnection catch IOException");
+                e.printStackTrace();
+            } catch (Exception e) {
+                Rlog.d(TAG, "listenConnection catch Exception");
+                e.printStackTrace();
+            } finally {
+                Rlog.d(TAG, "listenConnection finally!!");
+                if (threadExecutor != null )
+                    threadExecutor.shutdown();
+                if (serverSocket != null) {
+                    try {
+                        serverSocket.close();
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+            Rlog.d(TAG, "listenConnection() - end");
+        }
+    }
+
+
+    /**
+     * Maintain a RIL client task to connect to ril_vsim socket to communicate with rild/modem.
+     *
+     */
+    public class RilClientTask {
+        public static final String SERVER_NAME = "rild-vsim";
+        LocalSocket mSocket = null;
+        private VsimIoThread ioThread = null;
+        private int retryCount = 0;
+
+        // Need to connect to ril_vsim socket to communicate with rild/modem
+        public void connectToServer() {
+            Rlog.d(TAG, "connectToServer() - start");
+            while (retryCount < 10) {
+                try {
+                    Rlog.d(TAG, "connectToServer() - before");
+
+                    mSocket = new LocalSocket();
+                    LocalSocketAddress addr = new LocalSocketAddress(SERVER_NAME,
+                            LocalSocketAddress.Namespace.RESERVED);
+
+                    mSocket.connect(addr);
+
+                    Rlog.d(TAG, "connectToServer() - after");
+                } catch (IOException e) {
+                    Rlog.d(TAG, "connectToServer catch IOException");
+                    e.printStackTrace();
+
+                    if (mSocket != null && !mSocket.isConnected()) {
+                        retryCount++;
+                        try {
+                            Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                        } catch (InterruptedException er) {
+                        }
+                        Rlog.d(TAG, "connectToServer retry later, retry count: " + retryCount);
+                    }
+                }
+
+                if (mSocket != null && mSocket.isConnected()) {
+                    Rlog.d(TAG, "connectToServer connected!");
+                    break;
+                }
+            }
+            Rlog.d(TAG, "connectToServer() - end");
+        }
+
+        public VsimIoThread getIoThread(VsimEvenHandler eventHandler) {
+            if (ioThread == null) {
+                try {
+                    ioThread = new VsimIoThread(
+                            SERVER_NAME,
+                            mSocket.getInputStream(),
+                            mSocket.getOutputStream(),
+                            eventHandler);
+                    ioThread.start();
+                } catch (IOException e) {
+                    Rlog.d(TAG, "getIoThread catch IOException");
+                    e.printStackTrace();
+                }
+             }
+            return ioThread;
+        }
+    }
+
+    public class ConnectionHandler implements Runnable {
+        private LocalSocket mSocket;
+        //private RilClientTask mRilSocket;
+        private VsimEvenHandler mEventHandler;
+        public static final String RILD_SERVER_NAME = "rild-vsim";
+
+        public ConnectionHandler(LocalSocket clientSocket, VsimEvenHandler eventHandler) {
+            mSocket = clientSocket;
+            mEventHandler = eventHandler;
+        }
+
+        /* (non-Javadoc)
+         * @see java.lang.Runnable#run()
+         */
+        @Override
+        public void run() {
+            Rlog.d(TAG, "New connection: " + mSocket.toString());
+
+            try {
+                //mRilSocket = new RilClientTask();
+                //mRilSocket.connectToServer();
+
+                VsimIoThread ioThread = new VsimIoThread(
+                        ServerTask.HOST_NAME,
+                        mSocket.getInputStream(),
+                        mSocket.getOutputStream(),
+                        mEventHandler);
+                ioThread.start();
+
+                if (mRilIoThread == null) {
+                    mRilIoThread = new VsimIoThread(
+                            RILD_SERVER_NAME,
+                            RILD_SERVER_NAME,
+                            mEventHandler);
+                    mRilIoThread.start();
+                }
+
+                mEventHandler.setDataStream(ioThread, mRilIoThread);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static class VsimEvent {
+        public static final int DEFAULT_MAX_DATA_LENGTH = 20480;
+        private int mTransactionId;
+        private int mMessageId;
+        private int mSlotId;
+        private int mDataLen;
+        private int mReadOffset;
+        private byte mData[];
+        private int mEventMaxDataLen = DEFAULT_MAX_DATA_LENGTH;
+
+        /**
+         * The VsimEvent constructor with specified phone Id.
+         *
+         * @param transactionId event serial number, use to determine a pair of request & response.
+         * @param messageId message event id
+         */
+        public VsimEvent(int transactionId, int messageId) {
+            this(transactionId, messageId, 0);
+        }
+
+        /**
+         * The VsimEvent constructor with specified phone Id.
+         *
+         * @param transactionId event serial number, use to determine a pair of request & response.
+         * @param messageId message event id
+         * @param slotId the indicated slotId
+         */
+        public VsimEvent(int transactionId, int messageId, int slotId) {
+            this(transactionId, messageId, DEFAULT_MAX_DATA_LENGTH, slotId);
+        }
+
+        /**
+         * The VsimEvent constructor with specified phone Id.
+         *
+         * @param transactionId event serial number, use to determine a pair of request & response.
+         * @param messageId message event id
+         * @param length the max data length of the event
+         * @param slotId the indicated slotId
+         */
+        public VsimEvent(int transactionId, int messageId, int length, int slotId) {
+            mTransactionId = transactionId;
+            mMessageId = messageId;
+            mSlotId = slotId;
+            mEventMaxDataLen = length;
+            mData = new byte[mEventMaxDataLen];
+            mDataLen = 0;
+            mReadOffset = 0;
+        }
+
+        public int putInt(int value) {
+            synchronized (this) {
+                if (mDataLen > mEventMaxDataLen - 4) {
+                    return -1;
+                }
+
+                for (int i = 0 ; i < 4 ; ++i) {
+                    mData[mDataLen] = (byte) ((value >> (8 * i)) & 0xFF);
+                    mDataLen++;
+                }
+            }
+            return 0;
+        }
+
+        public int putShort(int value) {
+            synchronized (this) {
+                if (mDataLen > mEventMaxDataLen - 2) {
+                    return -1;
+                }
+
+                for (int i = 0 ; i < 2 ; ++i) {
+                    mData[mDataLen] = (byte) ((value >> (8 * i)) & 0xFF);
+                    mDataLen++;
+                }
+            }
+            return 0;
+        }
+
+        public int putByte(int value) {
+            if (mDataLen > mEventMaxDataLen - 1) {
+                return -1;
+            }
+
+            synchronized (this) {
+                mData[mDataLen] = (byte) (value & 0xFF);
+                mDataLen++;
+            }
+            return 0;
+        }
+
+        public int putString(String str, int len) {
+            synchronized (this) {
+                if (mDataLen > mEventMaxDataLen - len) {
+                    return -1;
+                }
+
+                byte s[] = str.getBytes();
+                if (len < str.length()) {
+                    System.arraycopy(s, 0, mData, mDataLen, len);
+                    mDataLen += len;
+                } else {
+                    int remain = len - str.length();
+                    System.arraycopy(s, 0, mData, mDataLen, str.length());
+                    mDataLen += str.length();
+                    for (int i = 0 ; i < remain ; i++) {
+                        mData[mDataLen] = 0;
+                        mDataLen++;
+                    }
+                }
+            }
+            return 0;
+        }
+
+        public int putBytes(byte [] value) {
+            synchronized (this) {
+                int len = value.length;
+
+                if (len > mEventMaxDataLen) {
+                    return -1;
+                }
+
+                System.arraycopy(value, 0, mData, mDataLen, len);
+                mDataLen += len;
+            }
+            return 0;
+        }
+
+        public int putCapability(int multiSim, int vsimSupported, int allowedSlots) {
+            if (mDataLen > mEventMaxDataLen - (4 * 4)) {
+                return -1;
+            }
+
+            putInt(1);  //valid capablity
+            putInt(multiSim);
+            putInt(vsimSupported);
+            putInt(allowedSlots);
+            return 0;
+        }
+
+        public int putPaddingCapability(){
+            if (mDataLen > mEventMaxDataLen - (4 * 4)) {
+                return -1;
+            }
+
+            putInt(0);  //valid capablity
+            putInt(0);  //multi Sim
+            putInt(0);  //vsim supported flag
+            putInt(0);  //allowed sim slots
+            return 0;
+        }
+
+        public int putUiccCommand(int commandLen, byte[] command) {
+            if (mDataLen > mEventMaxDataLen - (4 * 3)) {
+                return -1;
+            }
+
+            putInt(1);  //valid uicc request command
+            putInt(commandLen);
+            putBytes(command);
+            return 0;
+        }
+
+        public int putPaddingUiccCommand(){
+            if (mDataLen > mEventMaxDataLen - (4 * 3)) {
+                return -1;
+            }
+
+            putInt(1);  //valid uicc request command
+            putInt(0);  //command len
+            //putBytes(command);
+            return 0;
+        }
+
+        public byte [] getData() {
+            byte tempData[] = new byte[mDataLen];
+            System.arraycopy(mData, 0, tempData, 0, mDataLen);
+            return tempData;
+        }
+
+        public int getDataLen() {
+            return mDataLen;
+        }
+
+        public int getMessageId() {
+            return mMessageId;
+        }
+
+        /*
+         * Return slot bit mask.
+         * 1 means slot0,
+         * 2 means slot1,
+         * 3 means slot 0 and slot 1.
+         */
+        public int getSlotBitMask() {
+            return mSlotId;
+        }
+
+        /*
+         * Return the first mapping slot of slot bit mask value.
+         */
+        public int getFirstSlotId() {
+            int simCount = TelephonyManager.getDefault().getSimCount();
+            for (int i = 0; i < simCount; i++) {
+                if ((getSlotBitMask() & (1 << i)) != 0) {
+                    Rlog.d(TAG, "getFirstSlotId, slotId = " + i
+                            + ", slot bit mapping = " + getSlotBitMask());
+                    return i;
+                }
+            }
+            return -1;
+        }
+
+        public int getTransactionId() {
+            return mTransactionId;
+        }
+
+        public int getInt() {
+            int ret = 0;
+            synchronized (this) {
+                if (mData.length >= 4) {
+                    ret = ((mData[mReadOffset + 3] & 0xff) << 24 |
+                           (mData[mReadOffset + 2] & 0xff) << 16 |
+                        (mData[mReadOffset + 1] & 0xff) << 8 |
+                        (mData[mReadOffset] & 0xff));
+                    mReadOffset += 4;
+                }
+            }
+            return ret;
+        }
+
+        public int getShort() {
+            int ret = 0;
+            synchronized (this) {
+                ret =  ((mData[mReadOffset + 1] & 0xff) << 8 | (mData[mReadOffset] & 0xff));
+                mReadOffset += 2;
+            }
+            return ret;
+        }
+
+        // Notice: getByte is to get int8 type from VA, not get one byte.
+        public int getByte() {
+            int ret = 0;
+            synchronized (this) {
+                ret = (mData[mReadOffset] & 0xff);
+                mReadOffset += 1;
+            }
+            return ret;
+        }
+
+        public byte[] getBytes(int length) {
+            synchronized (this) {
+                if (length > mDataLen - mReadOffset) {
+                    return null;
+                }
+
+                byte[] ret = new byte[length];
+
+                for (int i = 0 ; i < length ; i++) {
+                    ret[i] = mData[mReadOffset];
+                    mReadOffset++;
+                }
+                return ret;
+            }
+        }
+
+        public String getString(int len) {
+            byte buf [] = new byte[len];
+
+            synchronized (this) {
+                System.arraycopy(mData, mReadOffset, buf, 0, len);
+                mReadOffset += len;
+            }
+
+            return (new String(buf)).trim();
+        }
+    }
+
+
+    class VsimIoThread extends Thread {
+        private String mName = "";
+        private static final int MAX_DATA_LENGTH = (20 * 1024);
+        private DataInputStream mInput = null;
+        private DataOutputStream mOutput = null;
+        private VsimEvenHandler mEventHandler = null;
+        private LocalSocket mSocket = null;
+        private String mServerName = "";
+
+        private byte[] readBuffer = null;
+
+        public VsimIoThread(
+                String name,
+                InputStream inputStream,
+                OutputStream outputStream,
+                VsimEvenHandler eventHandler) {
+            mName = name;
+            mInput = new DataInputStream(inputStream);
+            mOutput = new DataOutputStream(outputStream);
+            mEventHandler = eventHandler;
+            log("VsimIoThread constructor is called.");
+        }
+
+        public VsimIoThread(String name, String serverName, VsimEvenHandler eventHandler) {
+            mServerName = serverName;
+            createClientSocket(mServerName);
+            mName = name;
+            mEventHandler = eventHandler;
+            log("VsimIoThread constructor with creating socket is called.");
+        }
+
+        private void createClientSocket(String serverName) {
+            int retryCount = 0;
+            log("createClientSocket() - start");
+            while (retryCount < 10) {
+                try {
+                    log("createClientSocket() - before, serverName: " + serverName);
+
+                    mSocket = new LocalSocket();
+                    LocalSocketAddress addr = new LocalSocketAddress(serverName,
+                            LocalSocketAddress.Namespace.RESERVED);
+
+                    mSocket.connect(addr);
+
+                    mInput = new DataInputStream(mSocket.getInputStream());
+                    mOutput = new DataOutputStream(mSocket.getOutputStream());
+
+                    log("createClientSocket() - after, mSocket:" + mSocket.toString());
+                } catch (IOException e) {
+                    log("createClientSocket catch IOException");
+                    e.printStackTrace();
+
+                    if (mSocket != null && !mSocket.isConnected()) {
+                        retryCount++;
+                        try {
+                            mSocket.close();
+                            mSocket = null;
+                            Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                        } catch (InterruptedException e1) {
+                            e1.printStackTrace();
+                        } catch (IOException e2) {
+                            e2.printStackTrace();
+                        }
+                        log("createClientSocket retry later, retry count: " + retryCount);
+                    }
+                }
+
+                if (mSocket != null && mSocket.isConnected()) {
+                    log("createClientSocket connected!");
+                    break;
+                }
+            }
+            log("createClientSocket() - end");
+        }
+
+        public void closeSocket() {
+            try {
+                if (mSocket != null) {
+                    mSocket.close();
+                    mSocket = null;
+                    log("closeSocket.");
+                }
+            } catch (IOException e) {
+                log("closeSocket IOException.");
+                e.printStackTrace();
+            }
+        }
+
+        public void run() {
+            log("VsimIoThread running.");
+            while(true) {
+                try {
+                    //if (mInput.available() > 0) {
+                        VsimEvent event = readEvent();
+                        // Need to handle the event
+                        if (event != null) {
+                            Message msg = new Message();
+                            msg.obj = event;
+                            mEventHandler.sendMessage(msg);
+                        }
+                    //} else if (!mSocket.isConnected()){
+                    //    log("VsimIoThread mSocket is disconnected!");
+                    //}
+                } catch (IOException e) {
+                    log("VsimIoThread IOException.");
+                    e.printStackTrace();
+
+                    // To avoid server socket is closed due to modem reset
+                    try {
+
+                        if (mSocket != null) {
+                            mSocket.close();
+                            mSocket = null;
+                        }
+
+                        if (!mServerName.equals("")) {
+                            createClientSocket(mServerName);
+                        } else {
+                            // Means the client socket has been disconnected.
+                            // We shall close the socket and waiting for the new connection.
+                            log("Ingore exception");
+                            return;
+                        }
+                    } catch (IOException e2) {
+                        log("VsimIoThread IOException 2.");
+                        e2.printStackTrace();
+                    }
+                } catch (Exception e) {
+                    log("VsimIoThread Exception.");
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        private void writeBytes(byte [] value, int len) throws IOException {
+            mOutput.write(value, 0, len);
+        }
+
+        private void writeInt(int value) throws IOException {
+            for (int i = 0 ; i < 4 ; ++i) {
+                mOutput.write((value >> (8 * i)) & 0xff);
+            }
+        }
+
+        public int writeEvent(VsimEvent event) {
+            return writeEvent(event, false);
+        }
+
+        public int writeEvent(VsimEvent event, boolean isBigEndian) {
+            log("writeEvent Enter, isBigEndian:" + isBigEndian);
+            int ret = -1;
+            try {
+                synchronized (this) {
+                    if (mOutput != null) {
+                        dumpEvent(event);
+
+                        writeInt(event.getTransactionId());
+                        writeInt(event.getMessageId());
+                        // Platfrom slot id start from 0, so need to add 1.
+                        writeInt(event.getSlotBitMask());
+                        writeInt(event.getDataLen());
+                        writeBytes(event.getData(), event.getDataLen());
+                        mOutput.flush();
+                        ret = 0;
+                    } else {
+                        log("mOut is null, socket is not setup");
+                    }
+                }
+            } catch (Exception e) {
+                log("writeEvent Exception");
+                e.printStackTrace();
+                return -1;
+            }
+
+            return ret;
+        }
+
+        /**
+         * DataInputStream's readInt is Big-Endian method.
+         */
+        private int readInt() throws IOException {
+            byte[] tempBuf = new byte[8];
+            int readCount = mInput.read(tempBuf, 0, 4);
+            if (readCount < 0) {
+                log("readInt(), fail to read and throw exception");
+                throw new IOException("fail to read");
+            }
+            //log("[readInt] after readFully");
+            return ((tempBuf[3]) << 24 |
+                    (tempBuf[2] & 0xff) << 16 |
+                    (tempBuf[1] & 0xff) << 8 |
+                    (tempBuf[0] & 0xff));
+        }
+
+        private VsimEvent readEvent() throws IOException {
+            log("readEvent Enter");
+
+            int transaction_id = readInt();
+            int msg_id = readInt();
+            int slot_id = readInt();
+            int data_len = readInt();
+            log("readEvent transaction_id: " + transaction_id +
+                    ", msgId: " + msg_id + ", slot_id: " + slot_id + ", len: " + data_len);
+
+            readBuffer = new byte[data_len];
+
+            int offset = 0;
+            int remaining = data_len;
+
+            do {
+                int countRead = mInput.read(readBuffer, offset, remaining);
+
+                if (countRead < 0) {
+                    log("readEvent(), fail to read and throw exception");
+                    throw new IOException("fail to read");
+                }
+
+                offset += countRead;
+                remaining -= countRead;
+            } while (remaining > 0);
+
+            VsimEvent event = new VsimEvent(transaction_id, msg_id, data_len, slot_id);
+            event.putBytes(readBuffer);
+
+            dumpEvent(event);
+            return event;
+        }
+
+        private void dumpEvent(VsimEvent event) {
+            log("dumpEvent: transaction_id: " + event.getTransactionId()
+                    + ", message_id:" + event.getMessageId()
+                    + ", slot_id:" + event.getSlotBitMask()
+                    + ", data_len:" + event.getDataLen()
+                    + ", event:" + IccUtils.bytesToHexString(event.getData()));
+        }
+
+        private void log(String s) {
+            Rlog.d(TAG, "[" + mName + "] " + s);
+        }
+    }
+
+
+    public class VsimEvenHandler extends Handler {
+        private VsimIoThread mVsimAdaptorIo = null;
+        private VsimIoThread mVsimRilIo = null;
+        private boolean mHasNotifyEnableEvnetToModem = false;
+
+        @Override
+        public void handleMessage(Message msg) {
+            dispatchCallback((VsimEvent) msg.obj);
+        }
+
+        private void setDataStream(VsimIoThread vsimAdpatorIo, VsimIoThread vsimRilIo) {
+            mVsimAdaptorIo = vsimAdpatorIo;
+            mVsimRilIo = vsimRilIo;
+            Rlog.d(TAG, "VsimEvenHandler setDataStream done.");
+        }
+
+        private void setMdWaitingFlag(boolean isWaiting) {
+            Rlog.d(TAG, "setMdWaitingFlag: " + isWaiting);
+            isMdWaitingResponse = isWaiting;
+        }
+
+        private boolean getMdWaitingFlag() {
+            Rlog.d(TAG, "getMdWaitingFlag: " + isMdWaitingResponse);
+            return isMdWaitingResponse;
+        }
+
+        private void handleEventRequest(int type, VsimEvent event) {
+            Rlog.d(TAG, "VsimEvenHandler eventHandlerByType: type[" + type + "] start");
+
+            // Get external SIM slot id
+            int slotId = event.getFirstSlotId();
+            // Get if a local SIM (local SIM mean no need to download SIM data from server)
+            int simType = event.getInt();
+            // Response result
+            int result = ExternalSimConstants.RESPONSE_RESULT_OK;
+
+            Rlog.d(TAG, "VsimEvenHandler First slotId:" + slotId + ", simType:" + simType);
+
+            switch (type) {
+                case ExternalSimConstants.REQUEST_TYPE_ENABLE_EXTERNAL_SIM: {
+                    // set result according to sub ready state
+                    if (SubscriptionController.getInstance().isReady()) {
+                        result = ExternalSimConstants.RESPONSE_RESULT_OK;
+                    } else {
+                        result = ExternalSimConstants.RESPONSE_RESULT_PLATFORM_NOT_READY;
+                    }
+
+                    // 1.set default data sub id without capablity swtich to VSIM slot
+                    int subId = SubscriptionManager.getSubIdUsingPhoneId(slotId);
+                    SubscriptionController ctrl = SubscriptionController.getInstance();
+
+                    if (simType != ExternalSimConstants.SIM_TYPE_LOCAL_SIM) {
+                        // MTK TODO
+                        // ctrl.setDefaultDataSubIdWithoutCapabilitySwitch(subId);
+
+                        Rlog.d(TAG, "VsimEvenHandler set default data to subId: " + subId);
+                    }
+                    // set system property to note that sim enabled
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_ENABLED, "1");
+                    break;
+                }
+                case ExternalSimConstants.REQUEST_TYPE_DISABLE_EXTERNAL_SIM: {
+                    // 1.set system property to note that sim enabled
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_ENABLED, "0");
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+
+                    // 2.send event to modem side, will reset in rild side
+                    // FIXME: C2K project need to reset modem on both modem, so we can't
+                    // reset modem on gsm rild.
+                    mVsimRilIo.writeEvent(event);
+
+                    // 3. set modem waiting flag to false to drop the following uncompleted APDU
+                    //    or RESET request.
+                    setMdWaitingFlag(false);
+
+                    RadioManager.getInstance().setSilentRebootPropertyForAllModem("1");
+                    // MTK TODO
+                    // UiccController.getInstance().resetRadioForVsim();
+                    break;
+                }
+                case ExternalSimConstants.REQUEST_TYPE_PLUG_IN: {
+                     // 1.write shared prefrence/system property to record vsim availble event.
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED,
+                            String.valueOf(simType));
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, "persist.radio.external.sim",
+                            String.valueOf(simType));
+                    // 2.capability switch or reset modem with set VSIM on
+                    SubscriptionController ctrl = SubscriptionController.getInstance();
+                    int mCPhoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+                    //int mCSubId = ctrl.getSubIdUsingPhoneId(mCPhoneId);
+                    //int[] mTSubId = ctrl.getSubId(slotId);
+                    if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                        if (mCPhoneId == SubscriptionManager.LTE_DC_PHONE_ID_1) {
+                            mCPhoneId = PhoneConstants.SIM_ID_1;
+                        }
+                        if (mCPhoneId == SubscriptionManager.LTE_DC_PHONE_ID_2) {
+                            mCPhoneId = PhoneConstants.SIM_ID_2;
+                        }
+                    }
+
+                    if (slotId == mCPhoneId) {
+                        // Send event to rild which will reset modem in rild side.
+                        Rlog.d(TAG, "VsimEvenHandler no need to do capablity switch");
+                        mVsimRilIo.writeEvent(event);
+                        RadioManager.getInstance().setSilentRebootPropertyForAllModem("1");
+                        // MTK TODO
+                        // UiccController.getInstance().resetRadioForVsim();
+                    } else {
+                        // set result according to sub ready state
+                        Rlog.d(TAG, "VsimEvenHandler need to do capablity switch");
+                        if (SubscriptionController.getInstance().isReady()) {
+                            // Capbility switch will reset modem
+                            int subId = SubscriptionManager.getSubIdUsingPhoneId(slotId);
+                            SubscriptionController.getInstance().setDefaultDataSubId(subId);
+                            result = ExternalSimConstants.RESPONSE_RESULT_OK;
+                        } else {
+                            result = ExternalSimConstants.RESPONSE_RESULT_PLATFORM_NOT_READY;
+                        }
+                    }
+                    break;
+                }
+                case ExternalSimConstants.REQUEST_TYPE_PLUG_OUT: {
+                    // 1.write shared prefrence/system property to record vsim unavailble event.
+                    TelephonyManager.getDefault().setTelephonyProperty(
+                            slotId, TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+                    // 2.send event to modem side
+                    mVsimRilIo.writeEvent(event);
+
+                    // 3. set modem waiting flag to false to drop the following uncompleted APDU
+                    //    or RESET request.
+                    setMdWaitingFlag(false);
+                    break;
+                }
+            }
+
+            VsimEvent eventResponse = new VsimEvent(
+                    event.getTransactionId(),
+                    ExternalSimConstants.MSG_ID_EVENT_RESPONSE, event.getSlotBitMask());
+            eventResponse.putInt(result);  //result
+            mVsimAdaptorIo.writeEvent(eventResponse);
+
+            Rlog.d(TAG, "VsimEvenHandler eventHandlerByType: type[" + type + "] end");
+        }
+
+        private void handleGetPlatformCapability(VsimEvent event) {
+            int eventId = event.getInt();   //no-used
+            int simType = event.getInt();
+
+            VsimEvent response = new VsimEvent(
+                    event.getTransactionId(),
+                    ExternalSimConstants.MSG_ID_GET_PLATFORM_CAPABILITY_RESPONSE,
+                    event.getSlotBitMask());
+            // 1. Put result value to check platform ready
+            if (SubscriptionController.getInstance().isReady()) {
+                response.putInt(ExternalSimConstants.RESPONSE_RESULT_OK);
+            } else {
+                response.putInt(ExternalSimConstants.RESPONSE_RESULT_PLATFORM_NOT_READY);
+            }
+
+            // 2.1 Return multi-phone type, such as dsds or dsda.
+            MultiSimVariants config = TelephonyManager.getDefault().getMultiSimConfiguration();
+            if (config == MultiSimVariants.DSDS) {
+                response.putInt(ExternalSimConstants.MULTISIM_CONFIG_DSDS);
+            } else if (config == MultiSimVariants.DSDA) {
+                response.putInt(ExternalSimConstants.MULTISIM_CONFIG_DSDA);
+            } else if (config == MultiSimVariants.TSTS) {
+                response.putInt(ExternalSimConstants.MULTISIM_CONFIG_TSTS);
+            } else {
+                response.putInt(ExternalSimConstants.MULTISIM_CONFIG_UNKNOWN);
+            }
+
+            // 2.2 Return external SIM support flag (refer to feature option)
+            response.putInt(SystemProperties.getInt("ro.mtk_external_sim_support", 0));
+
+            // 2.3 Return slots allow to enable external SIM.
+            // The value is bit-mask, bit X means the slot (X - 1) is allowed to use external
+            // SIM. For an example, value 3 is bit 1 and 2 is 1 means external SIM is allowed
+            // to enable on slot 1 and slot 0.
+            int simCount = TelephonyManager.getDefault().getSimCount();
+
+            Rlog.d(TAG, "handleGetPlatformCapability simType: " + simType
+                    + ", simCount: " + simCount);
+
+            if (simType == ExternalSimConstants.SIM_TYPE_LOCAL_SIM) {
+                response.putInt((1 << simCount) - 1);
+            } else {
+                if (config == MultiSimVariants.DSDA) {
+                    int isCdmaCard = 0;
+                    int isHasCard = 0;
+
+                    for (int i = 0; i < simCount; i++) {
+                        String cardType = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[i], "");
+                        if (!cardType.equals("")) {
+                            isHasCard |= (1 << i);
+                        }
+
+                        if (cardType.contains("CSIM")
+                                || cardType.contains("RUIM") || cardType.contains("UIM")) {
+                            isCdmaCard |= (1 << i);
+                        }
+                    }
+
+                    Rlog.d(TAG, "handleGetPlatformCapability isCdmaCard: " + isCdmaCard
+                            + ", isHasCard: " + isHasCard);
+
+                    if (isHasCard == 0) {
+                        // DSDA project and there is no card is inserted.
+                        response.putInt(0);
+                    } else if (isCdmaCard == 0) {
+                        // DSDA project and there is no C card is inserted.
+                        response.putInt(0);
+                    } else {
+                        // DSDA project and there is a C card is inserted.
+                        response.putInt(isCdmaCard ^ ((1 << simCount) - 1));
+                    }
+
+                } else {
+                    // Non-DSDA project and it is not local SIM.
+                    // In this case, we could enable external SIM.
+                    response.putInt(0);
+                }
+            }
+
+            // Write response event by socket
+            mVsimAdaptorIo.writeEvent(response);
+        }
+
+        private void handleServiceStateRequest(VsimEvent event) {
+            int result = ExternalSimConstants.RESPONSE_RESULT_OK;
+            int voiceRejectCause = -1;
+            int dataRejectCause = -1;
+
+            VsimEvent response = new VsimEvent(
+                    event.getTransactionId(),
+                    ExternalSimConstants.MSG_ID_GET_SERVICE_STATE_RESPONSE,
+                    event.getSlotBitMask());
+            if (SubscriptionController.getInstance().isReady()) {
+                ITelephonyEx telEx = ITelephonyEx.Stub.asInterface(
+                        ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+                if (telEx == null) {
+                    try {
+                        int subId = SubscriptionManager.getSubIdUsingPhoneId(
+                                event.getFirstSlotId());
+                        Bundle bundle = telEx.getServiceState(subId);
+                        ServiceState ss = ServiceState.newFromBundle(bundle);
+                        Rlog.d(TAG, "handleServiceStateRequest subId: " + subId +
+                                ", ss = " + ss.toString());
+                        voiceRejectCause = ss.getVoiceRejectCause();
+                        dataRejectCause = ss.getDataRejectCause();
+                    } catch (RemoteException e) {
+                        Rlog.d(TAG, "RemoteException!!");
+                        result = ExternalSimConstants.RESPONSE_RESULT_GENERIC_ERROR;
+                        e.printStackTrace();
+                    }
+                }
+            } else {
+                result = ExternalSimConstants.RESPONSE_RESULT_PLATFORM_NOT_READY;
+            }
+
+            //Put response result
+            response.putInt(result);
+            //Put voice reject cause
+            response.putInt(voiceRejectCause);
+            //Put data reject cause
+            response.putInt(dataRejectCause);
+
+            mVsimAdaptorIo.writeEvent(response);
+        }
+
+        /* dispatch Callback */
+        private void dispatchCallback(VsimEvent event) {
+            // Handler events
+            int msgId = event.getMessageId();
+
+            Rlog.d(TAG, "VsimEvenHandler handleMessage: msgId[" + msgId + "]");
+
+            switch (msgId) {
+                case ExternalSimConstants.MSG_ID_INITIALIZATION_REQUEST:
+                    // Customized: allow to do neccessary initialization related to external SIM.
+                    // For an example, start an indicated service or set some configuration.
+                    break;
+
+                case ExternalSimConstants.MSG_ID_FINALIZATION_REQUEST:
+                    // Customized: allow to do neccessary finalization related to external SIM.
+                    // For an example, stop an indicated service or set some configuration.
+                    break;
+
+                case ExternalSimConstants.MSG_ID_GET_PLATFORM_CAPABILITY_REQUEST:
+                    handleGetPlatformCapability(event);
+                    break;
+
+                case ExternalSimConstants.MSG_ID_EVENT_REQUEST:
+                    handleEventRequest(event.getInt(), event);
+                    break;
+
+                case ExternalSimConstants.MSG_ID_EVENT_RESPONSE:
+                    // Is need to return from modem???
+                    break;
+
+                case ExternalSimConstants.MSG_ID_UICC_APDU_REQUEST: {
+                    setMdWaitingFlag(true);
+                    // Reguest from modem side, just adjust format and dispatch the event
+
+                    // get system property to check if vsim started
+                    String inserted =  TelephonyManager.getDefault().getTelephonyProperty(
+                            event.getFirstSlotId(),
+                            TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+
+                    if (inserted != null && inserted.length() > 0 && !"0".equals(inserted)) {
+                        mVsimAdaptorIo.writeEvent(event);
+                    }
+                    break;
+                }
+                case ExternalSimConstants.MSG_ID_UICC_APDU_RESPONSE:
+                    if (getMdWaitingFlag()) {
+                        // If modem waiting flag is set to flag, mean that, there might
+                        // be a plug out event during waiting response.
+                        // In this case, AP should drop this event to avoid modem receive
+                        // unexcepted event.
+                        // If the waiting flag is true,
+                        // just send to modem side without parsing data.
+                        mVsimRilIo.writeEvent(event);
+                        setMdWaitingFlag(false);
+                    }
+                    break;
+
+                case ExternalSimConstants.MSG_ID_UICC_RESET_REQUEST: {
+                    setMdWaitingFlag(true);
+                    // Reguest from modem side, just adjust format and dispatch the event
+                    // get system property to check if vsim started
+                    String inserted =  TelephonyManager.getDefault().getTelephonyProperty(
+                            event.getFirstSlotId(),
+                            TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+
+                    if (inserted != null && inserted.length() > 0 && !"0".equals(inserted)) {
+                        mVsimAdaptorIo.writeEvent(event);
+                    }
+                    break;
+                }
+                case ExternalSimConstants.MSG_ID_UICC_RESET_RESPONSE:
+                    if (getMdWaitingFlag()) {
+                        // If modem waiting flag is set to flag, mean that, there might
+                        // be a plug out event during waiting response.
+                        // In this case, AP should drop this event to avoid modem receive
+                        // unexcepted event.
+                        // If the waiting flag is true,
+                        // just send to modem side without parsing data.
+                        mVsimRilIo.writeEvent(event);
+                        setMdWaitingFlag(false);
+                    }
+                    break;
+
+                case ExternalSimConstants.MSG_ID_UICC_POWER_DOWN_REQUEST: {
+                    // get system property to check if vsim started
+                    String inserted =  TelephonyManager.getDefault().getTelephonyProperty(
+                            event.getFirstSlotId(),
+                            TelephonyProperties.PROPERTY_EXTERNAL_SIM_INSERTED, "0");
+
+                    if (inserted != null && inserted.length() > 0 && !"0".equals(inserted)) {
+                        mVsimAdaptorIo.writeEvent(event);
+                    }
+                    break;
+                }
+                case ExternalSimConstants.MSG_ID_UICC_POWER_DOWN_RESPONSE:
+                    mVsimRilIo.writeEvent(event);
+                    break;
+
+                case ExternalSimConstants.MSG_ID_GET_SERVICE_STATE_REQUEST:
+                    handleServiceStateRequest(event);
+                    break;
+                default:
+                    Rlog.d(TAG, "VsimEvenHandler handleMessage: default");
+            }
+        }
+    }
+}
+
diff --git a/src/java/com/mediatek/telephony/PhoneNumberFormatUtilEx.java b/src/java/com/mediatek/telephony/PhoneNumberFormatUtilEx.java
new file mode 100755
index 0000000000..31c87e720c
--- /dev/null
+++ b/src/java/com/mediatek/telephony/PhoneNumberFormatUtilEx.java
@@ -0,0 +1,2431 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.telephony;
+
+import java.util.Arrays;
+import java.util.Locale;
+
+import android.text.Editable;
+import android.text.SpannableStringBuilder;
+import android.text.Selection;
+import android.telephony.Rlog;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.TelephonyManager;
+import com.android.internal.telephony.PhoneConstants;
+
+
+/**
+ * MediaTek Phone Number Format Tool.
+ * There are 22 country&region supported.
+ *
+ * Country&Region   Code
+ *
+ * China Mainland   +86
+ * China Taiwan     +886
+ * China Honkong    +852
+ * China Macao      +853
+ * England          +44
+ *  France          +33
+ *  Italy           +39
+ *  Germany         +39
+ *  Russian         +7
+ *  India           +91
+ *  Spain           +34
+ *  Malaysia        +60
+ *  Singapore       +65
+ *  Indonesia       +62
+ *  Thailand        +66
+ *  Vietnam         +84
+ *  Portugal        +351
+ *  Poland          +48
+ *  Australia       +61
+ *  New Zealand     +64
+ *  Brazil          +55
+ *  Turkey          +90
+ *  @hide
+ */
+public class PhoneNumberFormatUtilEx {
+
+    public static final String TAG = "PhoneNumberFormatUtilEx";
+    public static final boolean DEBUG = false;
+    /**
+     *  List of country codes for countries that use the NANP
+     *  Need to SYNC google default PhoneNumberUtils if changes
+     */
+    private static final String[] NANP_COUNTRIES = new String[] {
+        "US", // United States
+        "CA", // Canada
+        "AS", // American Samoa
+        "AI", // Anguilla
+        "AG", // Antigua and Barbuda
+        "BS", // Bahamas
+        "BB", // Barbados
+        "BM", // Bermuda
+        "VG", // British Virgin Islands
+        "KY", // Cayman Islands
+        "DM", // Dominica
+        "DO", // Dominican Republic
+        "GD", // Grenada
+        "GU", // Guam
+        "JM", // Jamaica
+        "PR", // Puerto Rico
+        "MS", // Montserrat
+        "MP", // Northern Mariana Islands
+        "KN", // Saint Kitts and Nevis
+        "LC", // Saint Lucia
+        "VC", // Saint Vincent and the Grenadines
+        "TT", // Trinidad and Tobago
+        "TC", // Turks and Caicos Islands
+        "VI", // U.S. Virgin Islands
+    };
+
+    /** The current locale is unknown, look for a country code or don't format */
+    public static final int FORMAT_UNKNOWN = 0;
+    /** NANP formatting */
+    public static final int FORMAT_NANP = 1;
+    public static final String[] NANP_INTERNATIONAL_PREFIXS = {"011"};
+    /** Japanese formatting */
+    public static final int FORMAT_JAPAN = 2;
+    public static final String[] JAPAN_INTERNATIONAL_PREFIXS = {"010", "001", "0041", "0061"};
+    /**
+     * China mainland +86 or 0086
+     */
+    public static final int FORMAT_CHINA_MAINLAND = 3;
+    /**
+     * China Hongkong +852 or 00852
+     */
+    public static final int FORMAT_CHINA_HONGKONG = 4;
+
+    /**
+     * it comes from "http://www.chahaoba.com/%E9%A6%99%E6%B8%AF"
+     */
+    public static final String[] HONGKONG_INTERNATIONAL_PREFIXS = {"001", "0080", "0082", "009"};
+
+    /**
+     * China MACAU +853 or 00853
+     */
+    public static final int FORMAT_CHINA_MACAU = 5;
+
+    /**
+     * TAIWAN +886
+     */
+    public static final int FORMAT_TAIWAN = 6;
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Taiwan"
+     */
+    public static final String[] TAIWAN_INTERNATIONAL_PREFIXS = {"002", "005", "006", "007", "009", "019"};
+
+    public static final int FORMAT_ENGLAND = 7;
+
+    public static final int FORMAT_FRANCE = 8;
+    /**
+     * it comes from "http://countrycode.org/france"
+     */
+    public static final String[] FRANCE_INTERNATIONAL_PREFIXS = {"00", "40", "50", "70", "90"};
+
+    public static final int FORMAT_ITALY = 9;
+
+    public static final int FORMAT_GERMANY = 10;
+
+    public static final int FORMAT_RUSSIAN = 11;
+    //TODO RUSSIAN INTERNATIONAL PREFIXS
+
+
+    public static final int FORMAT_INDIA = 12;
+
+    public static final int FORMAT_SPAIN = 13;
+
+    public static final int FORMAT_MALAYSIA = 14;
+
+    public static final int FORMAT_SINGAPORE = 15;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Singapore"
+     */
+    public static final String[] SINGAPORE_INTERNATIONAL_PREFIXS = {"001", "002", "008", "012", "013", "018", "019"};
+
+    public static final int FORMAT_INDONESIA = 16;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Indonesia"
+     */
+    public static final String[] INDONESIA_INTERNATIONAL_PREFIXS = {"001", "007", "008", "009"};
+
+    public static final int FORMAT_THAILAND = 17;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Thailand"
+     */
+    public static final String[] THAILAND_INTERNATIONAL_PREFIXS = {"001", "004", "005", "006", "007", "008", "009"};
+
+    public static final int FORMAT_VIETNAM = 18;
+
+    public static final int FORMAT_PORTUGAL = 19;
+
+    public static final int FORMAT_POLAND = 20;
+
+    public static final int FORMAT_AUSTRALIA = 21;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Australia"
+     */
+    public static final String[] AUSTRALIA_INTERNATIONAL_PREFIXS = {"0011", "0014", "0015", "0016", "0018", "0019"};
+
+    public static final int FORMAT_NEW_ZEALAND = 22;
+
+
+    public static final int FORMAT_BRAZIL = 23;
+
+    /**
+     * it comes from "http://en.wikipedia.org/wiki/Telephone_numbers_in_Brazil"
+     */
+    public static final String[] BRAZIL_INTERNATIONAL_PREFIXS = {"0012", "0014", "0015", "0021", "0023", "0025", "0031", "0041"};
+
+    public static final int FORMAT_TURKEY = 24;
+
+    /**
+     * ***Warning****
+     * this country code array index matches FORMAT_XXXXX - 1.
+     * so if you add value, you must add new FORMAT_XXXXX, and the index still matches it.
+     */
+    public static String[] FORMAT_COUNTRY_CODES = {
+        "1",    "81",   "86",   "852",  "853",  "886", "44",
+        "33",   "39",   "49",   "7",    "91",   "34",  "60",
+        "65",   "62",   "66",   "84",   "351",  "48",  "61",
+        "64",   "55",   "90",
+    };
+
+    /**
+     * the country Alpha-2.
+     * reference: "http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2"
+     * ****Warning****
+     * this names match FORMAT_COUNTRY_CODES, and the index is also FORMAT_XXXXX - 1.
+     * so if you add value, you must add new FORMAT_XXXXX, and the index still matches it.
+     */
+    public static final String[] FORMAT_COUNTRY_NAMES = {
+        "US",   "JP",   "CN",   "HK",   "MO",   "TW",   "GB",
+        "FR",   "IT",   "DE",   "RU",   "IN",   "ES",   "MY",
+        "SG",   "ID",   "TH",   "VN",   "PT",   "PL",   "AU",
+        "NZ",   "BR",   "TR",
+    };
+
+    /**
+     * Returns the phone number formatting type for the given locale.
+     *
+     * @param locale The locale of interest, usually {@link Locale#getDefault()}
+     * @return The formatting type for the given locale, or FORMAT_UNKNOWN if the formatting
+     * rules are not known for the given locale
+     * @hide
+     */
+    public static int getFormatTypeForLocale(Locale locale) {
+//        String country = locale.getCountry();
+        String simIso = getDefaultSimCountryIso();
+        log("getFormatTypeForLocale Get sim sio:" + simIso);
+        return getFormatTypeFromCountryCode(simIso);
+    }
+
+    /**
+     * Get default sim country ISO.
+     * If the system is GEMINI System, the sim card is default sim, else the sim card is sim1; if the default sim is not inserted, select other sim.
+     *
+     * Returns the ISO country code equivalent for the SIM provider's country code.
+     * @return
+     */
+    /*package*/static String getDefaultSimCountryIso() {
+       int simId;
+       String iso = null;
+       if ("1".equals(SystemProperties.get("ro.mtk_gemini_support"))) {
+            simId = -1; //SystemProperties.getInt(PhoneConstants.GEMINI_DEFAULT_SIM_PROP, -1);
+             if (simId == -1) { // No default sim setting
+                 simId = PhoneConstants.SIM_ID_1;
+             }
+             if (!TelephonyManagerEx.getDefault().hasIccCard(simId)) {
+                 //simId = Phone.GEMINI_SIM_2 ^ simId;
+                 if (TelephonyManagerEx.getDefault().hasIccCard(PhoneConstants.SIM_ID_1)) {
+                     simId = PhoneConstants.SIM_ID_1;
+                 } else if (TelephonyManagerEx.getDefault().hasIccCard(PhoneConstants.SIM_ID_2)) {
+                     simId = PhoneConstants.SIM_ID_2;
+                 } else if (TelephonyManager.getDefault().getPhoneCount() >= 3 && TelephonyManagerEx.getDefault().hasIccCard(PhoneConstants.SIM_ID_3)) {
+                     simId = PhoneConstants.SIM_ID_3;
+                 } else if (TelephonyManager.getDefault().getPhoneCount() >= 4 && TelephonyManagerEx.getDefault().hasIccCard(PhoneConstants.SIM_ID_4)) {
+                     simId = PhoneConstants.SIM_ID_4;
+                 }
+             }
+             iso = TelephonyManagerEx.getDefault().getSimCountryIso(simId);
+       } else {
+           iso = TelephonyManager.getDefault().getSimCountryIso();
+       }
+       return iso;
+    }
+
+
+   private static int getFormatTypeFromCountryCodeInternal(String country) {
+        // Check for the NANP countries
+        int length = NANP_COUNTRIES.length;
+        for (int i = 0; i < length; i++) {
+            if (NANP_COUNTRIES[i].compareToIgnoreCase(country) == 0) {
+                return FORMAT_NANP;
+            }
+        }
+        if ("jp".compareToIgnoreCase(country) == 0) {
+            return FORMAT_JAPAN;
+        }
+        return FORMAT_UNKNOWN;
+    }
+    /**
+     * MediaTek extension for getting format type from country code.
+     * @param  country Country code.
+     * @return Return format type according to country parameter.
+     * @hide
+     */
+    public static int getFormatTypeFromCountryCode(String country) {
+        int type = FORMAT_UNKNOWN;
+        if (country != null && country.length() != 0) {
+            type = getFormatTypeFromCountryCodeInternal(country);
+//          type = PhoneNumberUtils.getFormatTypeFromCountryCode(country);
+            if (type == FORMAT_UNKNOWN) {
+                int index = 0;
+                for (String name : FORMAT_COUNTRY_NAMES) {
+                    index++;
+                    if (name.compareToIgnoreCase(country) == 0) {
+                        type = index;
+                        break;
+                    }
+                }
+                //for UK. which has two iso code
+                if (type == FORMAT_UNKNOWN && "UK".compareToIgnoreCase(country) == 0) {
+                    type = FORMAT_ENGLAND;
+                }
+            }
+        }
+        log("Get Format Type:" + type);
+        return type;
+    }
+
+    /**
+     * MediaTek format phone number.
+     * @param text
+     * @hide
+     */
+    public static String formatNumber(String source) {
+        Locale sCachedLocale;
+        sCachedLocale = Locale.getDefault();
+        return formatNumber(source, getFormatTypeForLocale(sCachedLocale));
+    }
+
+    /**
+     * MediaTek format phone number.
+     * @param text
+     * @param defaultFormattingType
+     * @hide
+     */
+//   public static void formatNumber(Editable text, int defaultFormattingType){
+//      String result = formatNumber(text.toString(),defaultFormattingType);
+//      //text.append(result);
+//      text.replace(0,text.length(),result);
+//    }
+    public static void formatNumber(Editable text, int defaultFormattingType) {
+        String result = formatNumber(text.toString(), defaultFormattingType);
+        if (result != null && !result.equals(text.toString())) {
+            //record the old cursor.
+            int oldIndex = Selection.getSelectionStart(text);
+            int digitCount = oldIndex;
+            int i = 0;
+            char c;
+            for (i = 0; i < oldIndex; i++) {
+                c = text.charAt(i);
+                if (c == ' ' || c == '-') {
+                        digitCount -- ;
+                }
+            }
+
+            text.replace(0, text.length(), result);
+
+            //update the cursor to old cursor
+            int count = 0;
+            for (i = 0; i < text.length() && count < digitCount ; i++) {
+                c = text.charAt(i);
+                if (!(c == ' ' || c == '-')) {
+                        count ++ ;
+                }
+            }
+            Selection.setSelection(text, i);
+            //Rlog.d(TAG,"OldIndex: "+oldIndex+", digitCount: "+digitCount + ", newCursor: "+i);
+        }
+
+    }
+
+    /**
+     * check the input number is '0-9','-','*','#',' ','+'
+     * warning: now we don't support WILD,PAUSE,WAIT.
+     * @param text
+     * @return
+     */
+    /*package*/static boolean checkInputNormalNumber(CharSequence text) {
+        boolean result = true;
+        char c;
+        for (int index = 0; index < text.length(); index++) {
+            c = text.charAt(index);
+            if (!((c >= '0' && c <= '9') || c == '*' || c == '#' || c == '+' || c == ' ' || c == '-')) {
+                result  = false;
+                break;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * MediaTek format phone number.
+     * @param text
+     * @param defaultFormattingType
+     * @return
+     */
+    public static String formatNumber(String text, int defaultFormattingType) {
+        log("MTK Format Number:" + text + " " + defaultFormattingType);
+        if (!checkInputNormalNumber(text)) {
+            log("Abnormal Number:" + text + ", do nothing.");
+            return text;
+        }
+        text = removeAllDash(new StringBuilder(text));
+        int formatType = (defaultFormattingType == FORMAT_UNKNOWN) ? FORMAT_NANP : defaultFormattingType;
+        String result = text;
+        if (text.length() > 2 && text.charAt(0) == '+') {
+            if (text.charAt(1) == '1') {
+                formatType = FORMAT_NANP;
+            } else if (text.length() >= 3 && text.charAt(1) == '8' && text.charAt(2) == '1') {
+                formatType = FORMAT_JAPAN;
+            } else if (formatType == FORMAT_NANP || formatType == FORMAT_JAPAN) {
+                result = mtkFormatNumber(text, formatType);
+                return result;
+            }
+         }
+        log("formatNumber:" + formatType);
+         switch (formatType) {
+         case FORMAT_NANP:
+         case FORMAT_JAPAN:
+             result = PhoneNumberUtils.formatNumber(text, formatType);
+             break;
+         default:
+             result = mtkFormatNumber(text, formatType);
+         }
+
+        return result;
+    }
+
+    /**
+     * MediaTek Extension to format phone number.
+     *
+     * @param text
+     * @param defaultFormatType
+     * @return
+     */
+    /*package*/static String mtkFormatNumber(String text, int defaultFormatType) {
+        log("MTK Format Number:" + text + " " + defaultFormatType);
+        int length = text.length();
+        if (length < 6) {
+            // The string is either a shortcode or too short to be formatted
+            return text;
+        }
+
+      //check there are '*' or '#' in the number,remove all ' ' and '-', then return.
+      //alps00036166 also check sip number '@'
+        if (text.contains("*") || text.contains("#") || text.contains("@")) {
+            return removeAllDash(new StringBuilder(text));
+        }
+
+        int formatType = defaultFormatType;
+        //Update format type from number.
+        int[] match = getFormatTypeFromNumber(text, defaultFormatType);
+        int startIndex = 0;
+        if (match != null && match[1] != FORMAT_UNKNOWN) {
+            formatType = match[1];
+            startIndex = match[0];
+        }
+        //only input more 4 code and less 16 code follow country code.
+        //the longest length of mobile phone brazil is 12, and maybe three '-'.
+        if (length < startIndex + 4) {
+            return text;
+        } else if (length > startIndex + 15) {
+            return text;
+        }
+        String result = text;
+        StringBuilder sb = new StringBuilder(text);
+        int blankPosition = -1;
+        // Strip the dashes first and add format blank, as we're going to add them back
+        blankPosition = removeAllDashAndFormatBlank(sb, startIndex);
+        //there are may +886 9-11 ,delete 1, +886 9-1. so check again.
+        if (sb.length() < startIndex + 4 || sb.length() == startIndex + 4 && sb.charAt(blankPosition + 1) == '0') {
+            return sb.toString();
+        }
+
+        switch(formatType) {
+        case FORMAT_CHINA_MAINLAND:
+            result = formatChinaNumber(sb, blankPosition);
+            break;
+        case FORMAT_CHINA_HONGKONG:
+        case FORMAT_SINGAPORE:
+            result = formatHeightLengthWithoutRegionCodeNumber(sb, blankPosition);
+            break;
+        case FORMAT_CHINA_MACAU:
+            result = formatMacauNumber(sb, blankPosition);
+            break;
+        case FORMAT_NANP:
+            SpannableStringBuilder ssb = null;
+            if (blankPosition >= 0) {
+                ssb = new SpannableStringBuilder(sb.substring(startIndex + 1));
+                PhoneNumberUtils.formatNanpNumber(ssb);
+                result = sb.substring(0, startIndex + 1).concat(ssb.toString());
+            } else {
+                ssb = new SpannableStringBuilder(sb);
+                PhoneNumberUtils.formatNanpNumber(ssb);
+                result = ssb.toString();
+            }
+            break;
+        case FORMAT_JAPAN:
+            SpannableStringBuilder ssb2 = null;
+            if (blankPosition >= 0) {
+                ssb2 = new SpannableStringBuilder(sb.substring(startIndex + 1));
+                PhoneNumberUtils.formatJapaneseNumber(ssb2);
+                result = sb.substring(0, startIndex + 1).concat(ssb2.toString());
+            } else {
+                ssb2 = new SpannableStringBuilder(sb);
+                PhoneNumberUtils.formatJapaneseNumber(ssb2);
+                result = ssb2.toString();
+            }
+            break;
+        case FORMAT_TAIWAN:
+            result = formatTaiwanNumber(sb, blankPosition);
+            break;
+        case FORMAT_VIETNAM:
+            result = formatVietnamNubmer(sb, blankPosition);
+            break;
+        case FORMAT_PORTUGAL:
+            result = formatPortugalNumber(sb, blankPosition);
+            break;
+        case FORMAT_POLAND:
+            result = formatPolandNumber(sb, blankPosition);
+            break;
+        case FORMAT_AUSTRALIA:
+            result = formatAustraliaNumber(sb, blankPosition);
+            break;
+        case FORMAT_NEW_ZEALAND:
+            result = formatNewZealandNumber(sb, blankPosition);
+            break;
+        case FORMAT_THAILAND:
+            result = formatThailandNumber(sb, blankPosition);
+            break;
+        case FORMAT_INDONESIA:
+            result = formatIndonesiaNumber(sb, blankPosition);
+            break;
+        case FORMAT_MALAYSIA:
+            result = formatMalaysiaNumber(sb, blankPosition);
+            break;
+        case FORMAT_SPAIN:
+            result = formatSpainNumber(sb, blankPosition);
+            break;
+        case FORMAT_RUSSIAN:
+            result = formatRussianNumber(sb, blankPosition);
+            break;
+        case FORMAT_GERMANY:
+            result = formatGermanyNumber(sb, blankPosition);
+            break;
+        case FORMAT_INDIA:
+            result = formatIndiaNumber(sb, blankPosition);
+            break;
+        case FORMAT_ITALY:
+            result = formatItalyNumber(sb, blankPosition);
+            break;
+        case FORMAT_FRANCE:
+            result = formatFranceNumber(sb, blankPosition);
+            break;
+        case FORMAT_ENGLAND:
+            result = formatEnglandNumber(sb, blankPosition);
+            break;
+        case FORMAT_BRAZIL:
+            result = formatBrazilNumber(sb, blankPosition);
+            break;
+        case FORMAT_TURKEY:
+            result = formatTurkeyNumber(sb, blankPosition);
+            break;
+        default:
+            //move all ' ' and '-'
+            result = removeAllDash(sb);
+        }
+        return result;
+    }
+
+    /**
+     * get the format from common number, the now country international prefix is STD '00' or '+'
+     * return a integer array, the length is 2, the first element is the internal number start index
+     * the second element is format value. if the format is unknown, the start index set 0.
+     * @param text the length of text must more or equals 5
+     * @return
+     */
+    private static int[] getFormatTypeByCommonPrefix(String text) {
+        int result = FORMAT_UNKNOWN;
+        int index = 0;
+        int startIndex = 0;
+        int[] match = new int[2];
+        //is start with '00' or '+'
+        if (text.length() > 0 && text.charAt(0) == '+') {
+            startIndex = 1;
+        } else if (text.length() > 1 && text.charAt(0) == '0' && text.charAt(1) == '0') {
+            startIndex = 2;
+        }
+        if (startIndex != 0) {
+            for (String pattern : FORMAT_COUNTRY_CODES) {
+                index++;
+                if (text.startsWith(pattern, startIndex)) {
+                    result = index;
+                    startIndex = startIndex + pattern.length();
+                    break;
+                }
+            }
+        }
+        if (result == FORMAT_UNKNOWN) {
+            startIndex = 0;
+        }
+        match[0] = startIndex;
+        match[1] = result;
+        return match;
+    }
+
+    /**
+     * get the format from number, the now country international prefix is special in prefixs.
+     * return a integer array, the length is 2, the first element is the internal number start index
+     * the second element is format value. if the format is unknown, the start index set 0.
+     * @param text
+     * @param prefixs
+     * @return
+     */
+    private static int[] getFormatNumberBySpecialPrefix(String text, String[] prefixs) {
+        int result = FORMAT_UNKNOWN;
+        int index = 0;
+        int startIndex = 0;
+        int[] match = new int[2];
+        //is start with '+'
+        if (text.charAt(0) == '+') {
+            startIndex = 1;
+        } else {
+            // is start with special prefix
+            for (String prefix : prefixs) {
+                if (text.startsWith(prefix)) {
+                    startIndex = prefix.length();
+                    break;
+                }
+            }
+        }
+        //is start with '+' or special prefix
+        if (startIndex > 0) {
+            for (String pattern : FORMAT_COUNTRY_CODES) {
+                index++;
+                if (text.startsWith(pattern, startIndex)) {
+                    result = index;
+                    startIndex = startIndex + pattern.length();
+                    break;
+                }
+            }
+        }
+        if (result == FORMAT_UNKNOWN) {
+            startIndex = 0;
+        }
+        match[0] = startIndex;
+        match[1] = result;
+        return match;
+    }
+
+    /**
+     * get the format from number
+     * China mainland, China macao, England, Italy, Germany, India, Spain, Malaysia, Vietnam, Portugal, Poland, New Zealand is common prefix: '00' or '+'
+     * return a integer array, the length is 2, the first element is the internal number start index
+     * the second element is format value. if the format is unknown, the start index set 0.
+     * @param text
+     * @param defaultFormatType
+     * @param FORMAT_CHIAN_HONGKONG
+     * @return
+     */
+    private static int[] getFormatTypeFromNumber(String text, int defaultFormatType) {
+        int[] match = null;
+        switch(defaultFormatType) {
+        case FORMAT_CHINA_MAINLAND:
+        case FORMAT_CHINA_MACAU:
+        case FORMAT_ENGLAND:
+        case FORMAT_ITALY:
+        case FORMAT_GERMANY:
+        case FORMAT_INDIA:
+        case FORMAT_SPAIN:
+        case FORMAT_MALAYSIA:
+        case FORMAT_VIETNAM:
+        case FORMAT_PORTUGAL:
+        case FORMAT_POLAND:
+        case FORMAT_NEW_ZEALAND:
+        case FORMAT_TURKEY:
+        //just '+' for Russian.
+        case FORMAT_RUSSIAN:
+            match = getFormatTypeByCommonPrefix(text);
+            break;
+        case FORMAT_TAIWAN:
+            match = getFormatNumberBySpecialPrefix(text, TAIWAN_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_CHINA_HONGKONG:
+            match = getFormatNumberBySpecialPrefix(text, HONGKONG_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_NANP:
+            match = getFormatNumberBySpecialPrefix(text, NANP_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_JAPAN:
+            match = getFormatNumberBySpecialPrefix(text, JAPAN_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_FRANCE:
+            match = getFormatNumberBySpecialPrefix(text, FRANCE_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_SINGAPORE:
+            match = getFormatNumberBySpecialPrefix(text, SINGAPORE_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_INDONESIA:
+            match = getFormatNumberBySpecialPrefix(text, INDONESIA_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_THAILAND:
+            match = getFormatNumberBySpecialPrefix(text, THAILAND_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_AUSTRALIA:
+            match = getFormatNumberBySpecialPrefix(text, AUSTRALIA_INTERNATIONAL_PREFIXS);
+            break;
+        case FORMAT_BRAZIL:
+            match = getFormatNumberBySpecialPrefix(text, BRAZIL_INTERNATIONAL_PREFIXS);
+            break;
+        }
+        return match;
+    }
+
+    /**
+     * remove all dash.
+     * @param sb
+     * @return
+     */
+    private static String removeAllDash(StringBuilder sb) {
+        int p = 0;
+        while (p < sb.length()) {
+            if (sb.charAt(p) == '-' || sb.charAt(p) == ' ') {
+                sb.deleteCharAt(p);
+            } else {
+                p++;
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * remove all dash and add format blank, if stated with international code.
+     * @param sb
+     * @param startIndex
+     * @return
+     */
+    private static int removeAllDashAndFormatBlank(StringBuilder sb, int startIndex) {
+        int p = 0;
+        int index = -1;
+        while (p < sb.length()) {
+            if (sb.charAt(p) == '-' || sb.charAt(p) == ' ') {
+                sb.deleteCharAt(p);
+            } else {
+                p++;
+            }
+        }
+        if (startIndex > 0) {
+            //add blank follow country code
+            index = startIndex;
+            sb.replace(index, index, " ");
+        }
+        return index;
+    }
+
+    /**
+     * remove trailing dashes.
+     * @param sb
+     * @return
+     */
+    private static String removeTrailingDashes(StringBuilder sb) {
+        // Remove trailing dashes
+        int len = sb.length();
+        while (len > 0) {
+            if (sb.charAt(len - 1) == '-') {
+                sb.delete(len - 1, len);
+                len--;
+            } else {
+                break;
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format China Mianland Call number
+     *
+     * reference "http://www.ct10000.com/main/services/05/"
+     *           "http://en.wikipedia.org/wiki/Telephone_numbers_in_China"
+     *
+     * +86 10-NNNNNNNN    International Beijing Telephone
+     * +86 2N-NNNNNNNN    International Super city Telephone
+     * +86 NNN-NNNNNNNN   International Common region Telephone
+     * +86 NNN-NNNN-NNNN  International mobile phone
+     *
+     * 010-NNNNNNNN      Beijing Telephone
+     * 02N-NNNNNNNN      Super city Telephone
+     * 0NNN-NNNNNNN
+     * 10-NNNNNNNN
+     * 2N-NNNNNNNN
+     * NNN-NNNNNNNN     Common region Telephone
+     * NNN-NNNN-NNNN     mobile phone
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatChinaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            //for beijing or other super city.
+            //+86 10NNN -> +86 10-NNN
+            if (c1 == '1' && c2 == '0' || c1 == '2') {
+                dashPositions[numDashes++] = index + 2;
+            } else if (c1 == '1') {
+                //for mobile phone
+                //+86 1NNNN - > +86 1NN-NN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+86 1NN-NNNNNN -> +86 1NN-NNNN-NN
+                if (length > index + 8) {
+                    dashPositions[numDashes++] = index + 7;
+                }
+            } else { //for other common region code.
+                dashPositions[numDashes++] = index + 3;
+            }
+        } else {
+            char c1 = sb.charAt(phoneNumPosition);
+            char c2 = sb.charAt(phoneNumPosition + 1);
+            if (c1 == '1' && c2 != '0') {
+                //for mobile phone
+                //1NNNN - > 1NN-NN
+                if (length > phoneNumPosition + 4) {
+                    dashPositions[numDashes++] = phoneNumPosition + 3;
+                }
+                //1NN-NNNNNN -> 1NN-NNNN-NN
+                if (length > phoneNumPosition + 8) {
+                    dashPositions[numDashes++] = phoneNumPosition + 7;
+                }
+            } else if (c1 == '1' && c2 == '0') {
+                //1NNNN - > 1NN-NN
+                if (length > phoneNumPosition + 3) {
+                    dashPositions[numDashes++] = phoneNumPosition + 2;
+                }
+            } else {
+                //No we don't know the code has region code(ignored 0), only when then length of number is more than 8
+                if (length > phoneNumPosition + 8) {
+                    if (c1 == '2') {
+                        dashPositions[numDashes++] = phoneNumPosition + 2;
+                    } else {
+                        dashPositions[numDashes++] = phoneNumPosition + 3;
+                    }
+                }
+            }
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Taiwan Call Number
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Taiwan"
+     *
+     * +886 9-NNNN-NNNN
+     * +886 N-NNNN-NNNN
+     * +886 N-NNN-NNNN
+     * +886 NN-NNNN-NNNN
+     * +886 NN-NNN-NNNN
+     * +886 NNN-NNN-NNN
+     *
+     *  0N-NNNN-NNNN
+     *  0N-NNN-NNNN
+     *  0NN-NNNN-NNNN
+     *  0NN-NNN-NNNN
+     *  0NNN-NNN-NNN
+     *  09-NNNN-NNNN     mobile phone
+     *
+     *  NNN-NNNN
+     *  NNNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatTaiwanNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            //for mobile phone
+            if (c1 == '9') {
+//              dashPositions[numDashes++] = index + 1;
+//              //+886 9-NNNNNN -> +886 9-NNNN-NN
+//              if(length > index + 6){
+//                  dashPositions[numDashes++] = index + 5;
+//              }
+                if (length > index + 4)
+                dashPositions[numDashes++] = index + 3;
+                //+886 9NN-NNNN -> +886 9NN-NNN-NNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else if ((c1 == '8' && c2 == '2' && c3 == '6') || (c1 == '8' && c2 == '3' && c3 == '6')) {
+                //for 0826, 0836
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+886 NNN-NNN-NNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else if ((c1 == '3' && c2 == '7') || (c1 == '4' && c2 == '9') || (c1 == '8' && c2 == '9') || (c1 == '8' && c2 == '2')) {
+                //for 037, 049, 089, 082
+                dashPositions[numDashes++] = index + 2;
+                //+886 NN-NNN-NNNN
+                if (length > index + 6 && length < index + 10) {
+                    dashPositions[numDashes++] = index + 5;
+                } else if (length >= index + 10) { //+886 NN-NNNN-NNNN
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //for 02 04 05 06 07 08 ......
+                dashPositions[numDashes++] = index + 1;
+                //+886 N-NNN-NNNN
+                if (length > index + 6 && length < index + 9) {
+                    dashPositions[numDashes++] = index + 4;
+                } else if (length >= index + 9) { //+886 N-NNNN-NNNN
+                    dashPositions[numDashes++] = index + 5;
+                }
+            }
+        } else {
+            if (length > phoneNumPosition + 4 && length < phoneNumPosition + 8) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            } else if (length >= phoneNumPosition + 8) { //NNNN-NNNN....
+                dashPositions[numDashes++] = phoneNumPosition + 4;
+            }
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format China Macau Call number.
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Macau"
+     *
+     * +853 NNNN-NNNN
+     * NNNN-NNNN
+     * 01 NNNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatMacauNumber(StringBuilder sb, int blankPosition) {
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //01 for Hongkong
+        if (sb.charAt(phoneNumPosition) == '0' && sb.charAt(phoneNumPosition + 1) == '1') {
+            sb.replace(phoneNumPosition + 2, phoneNumPosition + 2, " ");
+            return formatHeightLengthWithoutRegionCodeNumber(sb, blankPosition + 3);
+        } else {
+            return formatHeightLengthWithoutRegionCodeNumber(sb, blankPosition);
+        }
+    }
+
+    /**
+     * format number which length is 8, insert a hyphen to index 4.
+     * it is used for Hongkong, Macau, Singapore
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Hong_Kong"
+     *            "http://en.wikipedia.org/wiki/Telephone_numbers_in_Macau"
+     *            "http://en.wikipedia.org/wiki/Telephone_numbers_in_Singapore"
+     *
+     * +NNN NNNN-NNNN
+     * NNNN-NNNN
+     * @param text
+     * @param startIndex
+     * @return
+     */
+    private static String formatHeightLengthWithoutRegionCodeNumber(StringBuilder sb, int blankPosition) {
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+
+        if (sb.length() >= phoneNumPosition + 6) {
+            dashPositions[numDashes++] = phoneNumPosition + 4;
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return removeTrailingDashes(sb);
+    }
+
+    /**
+     * format Vietnam call number.
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Vietnam"
+     *
+     * +84 4|8-XXXXXXXX
+     * +84 XX-XXXXXXX
+     * +84 YYY-XXXXXX
+     * 09Y-NNN-NNNN
+     * 01YY-NNN-NNNN
+     *
+     * 04-NNNNNNNN
+     * 08-NNNNNNNN
+     * 0NN-NNNNNNN
+     * 0NNN-NNNNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatVietnamNubmer(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            //for 02,04
+            if (c1 == '4' || c1 == '8') {
+                dashPositions[numDashes++] = index + 1;
+            } else if (c1 == '2' && (c2 == '1' || c2 == '3' || c2 == '4' || c2 == '8')
+                    || (c1 == '3' && (c2 == '2' || c2 == '5'))
+                    || (c1 == '6' && c2 == '5')
+                    || (c1 == '7' && (c2 == '1' || c2 == '8'))) {
+                //for 021X,023X,024X,028X, 032X,035X, 065X, 071X,078X
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+            } else if (c1 == '9') { //for mobile phone 09N
+                //+84 9NNN -> +84 9N-NN
+                dashPositions[numDashes++] = index + 2;
+                //+84 9N-NNNNN -> +84 9N-NNN-NN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else if (c1 == '1') { //for mobile phone 01NN
+                //+84 1NNNN -> +84 1NN-NN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+84 1NN-NNNNN - > +84 1NN-NNN-NN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //for XX
+                dashPositions[numDashes++] = index + 2;
+            }
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+
+    /**
+     * format Portugal Number
+     *
+     * +351 9T-NNN-NNNN
+     * +351 NN-NNN-NNNN
+     * 9T-NNN-NNNN
+     * NN-NNN-NNNN
+     *
+     * @param text
+     * @param startIndex
+     * @return
+     */
+    private static String formatPortugalNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        if (length > phoneNumPosition + 4) {
+            dashPositions[numDashes++] = phoneNumPosition + 2;
+        }
+        if (length > phoneNumPosition + 8) {
+            dashPositions[numDashes++] = phoneNumPosition + 5;
+        }
+        for (int i = 0; i < numDashes; i++) {
+            int pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Brazil Phone Number
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Brazil"
+     *
+     * +55-aa-nnnn-nnnn
+     *
+     * 0-xx-aa-nnnn-nnnn
+     * 0-aa-nnnn-nnnn
+     *
+     * nnnn-nnnn
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatBrazilNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[5];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                dashPositions[numDashes++] = phoneNumPosition + 1;
+                index ++;
+            }
+            if (length > index + 3) {
+                dashPositions[numDashes++] = index + 2;
+            }
+            if (length > index + 7 && length <= index + 10) {
+                dashPositions[numDashes++] = index + 6;
+            } else if (length > index + 10) {
+                dashPositions[numDashes++] = index + 4;
+                dashPositions[numDashes++] = index + 8;
+            }
+        } else if (length > phoneNumPosition + 5) {
+            dashPositions[numDashes++] = phoneNumPosition + 4;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Poland call number
+     *
+     * +48 NN-NNN-NN-NN mobile phone(started with 5,6,7,8)
+     * +48 NNN-NNN-NNN  fixed phone
+     * NN-NNN-NN-NN
+     * NNN-NNN-NNN
+     * reference site: http://en.wikipedia.org/wiki/Telephone_numbers_in_Poland
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatPolandNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[3];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //for mobile phone(started with 5,6,7,8)
+        if (sb.charAt(phoneNumPosition) >= '5' && sb.charAt(phoneNumPosition) <= '8') {
+            if (length > phoneNumPosition + 4) {
+                dashPositions[numDashes++] = phoneNumPosition + 2;
+            }
+            if (length > phoneNumPosition + 6) {
+                dashPositions[numDashes++] = phoneNumPosition + 5;
+            }
+            if (length > phoneNumPosition + 8) {
+                dashPositions[numDashes++] = phoneNumPosition + 7;
+            }
+        } else {
+            if (length > phoneNumPosition + 5) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            }
+            if (length > phoneNumPosition + 8) {
+                dashPositions[numDashes++] = phoneNumPosition + 6;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Australia Number
+     *
+     * +61 4NN-NNN-NNN
+     * +61 X-XXXX-XXXX
+     * 04XX-NNN-NNN mobile phone
+     * 0X-XXXX-XXXX landline phone
+     * XXXX-XXXX
+     *
+     * reference site: http://en.wikipedia.org/wiki/Telephone_numbers_in_Australia
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatAustraliaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            //mobile phone
+            if (sb.charAt(index) == '4') {
+                //+61 4NNNNN -> +61 4NN-NNN or 04NNNNN -> 04NN-NNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+61 4NN-NNNNNN->+61 4NN-NNN-NNN or 04NN NNNNNN - > 04NN-NNN-NNN
+                if (length > index + 8) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //+61 XNNNN -> +61 X-NNNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+                //+61 X-NNNNNNNN -> +61 X-NNNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            }
+        } else {
+            //only do when the length of local number is 8
+            //XXXXXXXX->XXXX-XXXX
+            System.out.println(length);
+            if (length == phoneNumPosition + 8) {
+                dashPositions[numDashes++] = phoneNumPosition + 4;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format New Zealand call number
+     *
+     * +64 N-NNN-NNNN
+     * +64 2X-NNN-NNNN
+     * 02N-NNN-NNNN mobile phone
+     * 0N-NNN-NNNN landline phone
+     * NNN-NNNN landline phone
+     *
+     * reference site: http://en.wikipedia.org/wiki/Telephone_numbers_in_New_Zealand
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatNewZealandNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            //mobile phone. start 2X but not 24.
+            if (sb.charAt(index) == '2' && sb.charAt(index + 1) != '4') {
+                //+64 2XNNN -> +64 2X-NNN or 02XNNN -> 02X-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+64 2X-NNNNNNN->+61 2X-NNN-NNNN or 02X-NNNNNNN - > 02X-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else {
+                //+64 XNNN -> +64 X-NNN
+                if (length > index + 3) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+                //+64 X-NNNNNNN -> +61 X-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            }
+        } else {
+            //only do when the length of local number is 7
+            //NNNNNNN->NNN-NNNN
+            System.out.println(length);
+            if (length == phoneNumPosition + 7) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Tailand call number
+     *
+     * +66 2-NNN-NNNN
+     * +66 NN-NNN-NNN
+     * +66 8N-NNN-NNNN
+     * 02-NNN-NNNN
+     * 0XX-NNN-NNN
+     * 08X-NNN-NNNN
+     *
+     * reference "http://www.wtng.info/wtng-66-th.html"
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Thailand"
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatThailandNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            //mobile phone. started with 8 or 08
+            if (sb.charAt(index) == '8') {
+                //+66 8XNNN -> +66 8X-NNN or 08XNNN -> 08X-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+66 8X-NNNNNN->+61 8X-NNN-NNN or 08X-NNNNNNN - > 08X-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else if (sb.charAt(index) == '2') { //for Bangkok started with 2 or 02.
+                //+66 2NNN -> +64 2-NNN
+                if (length > index + 3) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+                //+66 2-NNNNNNN -> +66 2-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            } else { //for other region code with NN or 0NN
+                //+66 XXNNN -> +66 XX-NNN or 0XXNNN -> 0XX-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+66 XX-NNNNNN->+61 XX-NNN-NNN or 0XX-NNNNNNN - > 0XX-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            }
+        } else {
+            //To dial a land line in Thailand all over the country, the format is Area Code + Phone Number.
+            //Even through dial local phone, must add area code.
+            //only do when the length of local number is 7
+            //NNNNNNN->NNN-NNNN
+            //System.out.println(length);
+            //if(length == phoneNumPosition + 7 ){
+            //  dashPositions[numDashes++] = phoneNumPosition + 3;
+            //}
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Indonesia call number.
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Indonesia"
+     *
+     * +62 8NN-NNN-NNN
+     * +62 8NN-NNN-NNNN
+     * +62 8NN-NNNN-NNNN
+     * +62 NN-NNNN-NNNN
+     * +62 NNN-NNN-NNNN
+     * 08NN-NNN-NNN
+     * 08NN-NNN-NNNN
+     * 08NN-NNNN-NNNN
+     * 0NN-NNNN-NNNN
+     * 0NNN-NNN-NNNN
+     * 8NN-NNNN-NNNN
+     * 8NN-NNN-NNNN
+     * 8NN-NNN-NNN
+     * NNNN-NNNN
+     * NNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatIndonesiaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            //mobile phone started with +62 8 or 08
+            if (c1 == '8') {
+                //+62 8NNNNN -> +62 8NN-NNN or 08NNNNN -> 08NN-NNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+62 8NN-NNNNN.. -> +62 8NN-NNN-NN.., when the length of mobile phone number is less then 11
+                if (length >= index + 8 && length <= index + 10) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+                //+62 8NN-NNNNNNNN -> +62 8NN-NNNN-NNNN, when the length of mobile phone number is more then 10.
+                if (length > index + 10) {
+                    dashPositions[numDashes++] = index + 7;
+                }
+            } else if ((c1 == '2' && (c2 == '1' || c2 == '2' || c2 == '4'))
+                    || (c1 == '3' && c2 == '1')
+                    || (c1 == '6' && c2 == '1' && c3 != '9')) {
+                //region code 21,22,24,31,61(not 619)
+                //+62 XXNNN -> +62 XX-NNN or 0XXNNN -> 0XX-NNN
+                if (length > index + 3) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+62 XX-NNNNNNNN -> +62 XX-NNNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //region code YYY
+                //+62 YYYNNN -> +62 YYY-NNN or 0YYYNNN -> 0YYY-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+62 YYY-NNNNNNN -> +62 YYY-NNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            }
+        } else {
+            //NNNNNNN->NNN-NNNN
+            if (length == phoneNumPosition + 7) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            } else if (length == phoneNumPosition + 8) {
+                //NNNNNNNN->NNNN-NNNN
+                dashPositions[numDashes++] = phoneNumPosition + 4;
+            } else if (sb.charAt(phoneNumPosition) == '8') { //FOR 8NNNNNNNNNN...
+                if (length > phoneNumPosition + 8 && length <= phoneNumPosition + 10) {
+                    dashPositions[numDashes++] = phoneNumPosition + 3;
+                    dashPositions[numDashes++] = phoneNumPosition + 6;
+                } else if (length > phoneNumPosition + 10) {
+                    dashPositions[numDashes++] = phoneNumPosition + 3;
+                    dashPositions[numDashes++] = phoneNumPosition + 7;
+                }
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Malaysia call number
+     *
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Malaysia"
+     *
+     * +60 3-NNNNNNNN
+     * +60 X-NNNNNNN
+     * +60 8X-NNNNNN
+     * +60 1X-NNN-NNNN
+     *
+     * 2-NNNN-NNNN (to Singapore)
+     * 03-NNNNNNNN
+     * 0X-NNNNNNN
+     * 08X-NNNNNN
+     * 01X-NNN-NNNN
+     *
+     * 1X-NNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatMalaysiaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            //+60 X-NNNNNNN or +60 3-NNNNNNNN or 03-NNNNNNNN or 0X-NNNNNNN
+            if (c1 >= '3' && c1 <= '7' || c1 == '9') {
+                //+60 XNNNN -> +60 X-NNNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+            } else if (c1 == '8') {
+                //+60 8XNNN -> +60 8X-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+            } else if (c1 == '1') {
+                //mobile phone
+                //+60 1XNNN -> +60 1X-NNN or 01XNNN -> 01X-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+60 1X-NNNNNN->+60 1X-NNN-NNN or 01X-NNNNNNN - > 01X-NNN-NNNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else if (c1 == '2') { //to Singapore
+                //+60 2NNNN -> +60 2-NNNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 1;
+                }
+                //+60 2NNNNNNN -> +60 2-NNNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            }
+        } else if (sb.charAt(phoneNumPosition) == '2' && length > phoneNumPosition + 8) { //to Singapore
+            // 2NNNN -> 2-NNNN
+            dashPositions[numDashes++] = phoneNumPosition + 1;
+            // 2NNNNNNN -> 2-NNNN-NNNN
+            dashPositions[numDashes++] = phoneNumPosition + 5;
+        } else if (sb.charAt(phoneNumPosition) == '1' && length > phoneNumPosition + 8) {
+            //for mobile phone.
+            dashPositions[numDashes++] = phoneNumPosition + 2;
+            dashPositions[numDashes++] = phoneNumPosition + 5;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Spain Number
+     *
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Spain"
+     *
+     * +34 NNN-NNN-NNN
+     *
+     * NNN-NNN-NNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatSpainNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //+34 NNNNNN - > +34 NNN-NNNN
+        if (length > phoneNumPosition + 5) {
+            dashPositions[numDashes++] = phoneNumPosition + 3;
+        }
+        //+34 NNNNNNNN-> +34 NNN-NNN-NN
+        if (length > phoneNumPosition + 7) {
+            dashPositions[numDashes++] = phoneNumPosition + 6;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+    private static int[] INDIA_7_MOBILE_AREA_CODE = {
+
+    };
+    //TODO maybe use table, and binary search is better.
+    */
+
+    /**
+     * India Three digits area codes
+     *
+     * reference: "http://www.bsnl.co.in/stdsearch.php"
+     *
+     */
+    private static final int[] INDIA_THREE_DIGIG_AREA_CODES = {
+        120, 121, 122, 124, 129, 130, 131, 132, 135, 141, 144, 145, 151, 154, 160, 161, 164, 171, 172, 175, 177, 180, 181, 183, 184, 186, 191, 194,
+        212, 215, 217, 230, 231, 233, 240, 241, 250, 251, 253, 257, 260, 261, 265, 268, 278, 281, 285, 286, 288, 291, 294, 326, 341, 342, 343, 353,
+        354, 360, 361, 364, 368, 369, 370, 372, 373, 374, 376, 381, 385, 389, 413, 416, 421, 422, 423, 424, 427, 431, 435, 451, 452, 461, 462, 468,
+        469, 470, 471, 474, 475, 476, 477, 478, 479, 480, 481, 483, 484, 485, 487, 490, 491, 494, 495, 496, 497, 512, 515, 522, 532, 535, 542, 548,
+        551, 562, 565, 571, 581, 591, 595, 612, 621, 631, 641, 651, 657, 661, 663, 671, 674, 680, 712, 721, 724, 731, 733, 734, 744, 747, 751, 755,
+        761, 771, 788, 816, 820, 821, 824, 831, 832, 836, 861, 863, 866, 870, 877, 878, 883, 884, 891
+    };
+
+    /**
+     * check 8NNN,7NNN is moble phone number, or is fixed number.
+     * if is mobile phone number,return 0.
+     * if is two digits region code, return 2;
+     * if is three digits region code, return 3;
+     * if is four digits region code, reutrn 4;
+     *
+     * Waring: we are now using the strategy that mobile phones to expend,
+     *         when the number is not used, it is the mobile phone number by default, but the statistics are not complete.
+     *
+     * reference: "http://en.wikipedia.org/wiki/Mobile_telephone_numbering_in_India"
+     * reference: "http://www.bsnl.co.in/stdsearch.php"
+     *
+     * @param c1 c1 != '0'
+     * @param c2
+     * @param c3
+     * @param c4
+     * @return
+     */
+    private static int checkIndiaNumber(char c1, char c2, char c3, char c4) {
+        int result = -1;
+        int temp = (c3 - '0') * 10 + (c4 - '0');
+        if (c1 == '9') {
+            result = 0;
+        } else if (c1 == '8') {
+            if ((c2 == '0' && (temp < 20 || temp >= 50 && temp <= 60 || temp >= 80))
+                    || (c2 == '1' && (temp < 10 || temp >= 20 && temp <= 29 || temp >= 40 && temp <= 49))
+                    || (c2 == '7' && (temp >= 90 || temp == 69))
+                    || (c2 == '8' && (temp < 10 || temp == 17 || temp >= 25 && temp <= 28 || temp == 44 || temp == 53 || temp >= 90))
+                    || (c3 == '9' && (temp < 10 || temp == 23 || temp == 39 || temp >= 50 && temp <= 62 || temp == 67 || temp == 68 || temp >= 70))) {
+                result = 0;
+            }
+        } else if (c1 == '7') {
+            //TODO maybe use table, and binary search is better.
+            if (c2 == '0' //expend to mobile phone number
+                || (c2 == '2' && (temp == 0 || temp >= 4 && temp <= 9 || temp == 50 || temp == 59 || temp >= 75 && temp <= 78 || temp == 93 || temp == 9))
+                || (c2 == '3' && (temp == 73 || temp == 76 || temp == 77 || temp == 96 || temp == 98 || temp == 99))
+                || (c2 == '4' && (temp < 10 || temp == 11 || temp >= 15 && temp <= 19 || temp == 28 || temp == 29 || temp == 39 || temp == 83 || temp == 88 || temp == 89 || temp == 98 || temp == 99))
+                || (c2 == '5' && (temp <= 4 || temp == 49 || temp == 50 || temp >= 66 && temp <= 69 || temp == 79 || temp >= 87 && temp <= 89 || temp >= 97))
+                || (c2 == '6' && (temp == 0 || temp == 2 || temp == 7 || temp == 20 || temp == 31 || temp == 39 || temp == 54 || temp == 55 || temp >= 65 && temp <= 69 || temp >= 76 && temp <= 79 || temp >= 96))
+                || (c2 == '7' && (temp == 2 || temp == 8 ||  temp == 9 || temp >= 35 && temp <= 39 || temp == 42 || temp == 60 || temp == 77 || temp >= 95))
+                || (c2 == '8' && temp <= 39 && (temp == 0 || temp >= 7 && temp <= 9 || temp == 14 || temp >= 27 && temp <= 30 || temp >= 37 && temp <= 39))
+                || (c2 == '8' && temp > 39 && (temp == 42 || temp == 45 || temp == 60 || temp >= 69 && temp <= 79 || temp >= 90))) {
+                result = 0;
+            }
+        }
+        if (result == 0) {
+            return result;
+        }
+        if ((c1 == '1' && c2 == '1')
+                || (c1 == '2' && (c2 == '0' || c2 == '2'))
+                || (c1 == '3' && c2 == '3')
+                || (c1 == '4' && (c2 == '0' || c2 == '4'))
+                || (c1 == '7' && c2 == '9')
+                || (c1 == '8' && c2 == '0')) {
+            result = 2;
+        } else {
+            int key = (c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0');
+            if (Arrays.binarySearch(INDIA_THREE_DIGIG_AREA_CODES, key) >= 0) {
+                result = 3;
+            } else {
+                result = 4;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * format India call number
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_India"
+     *
+     * +91 XX-YY-NNNNNN
+     * +91 NN-NNNNNNNN
+     * +91 NNN-NNNNNNN
+     * +91 NNNN-NNNNNN
+     *
+     * 0XX-YY-NNNNNN
+     * 0NN-NNNNNNNN
+     * 0NNN-NNNNNNN
+     * 0NNNN-NNNNNN
+     *
+     * XX-YY-NNNNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatIndiaNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+
+        //has country code. or started with '0'
+        char c = sb.charAt(phoneNumPosition);
+        if ((phoneNumPosition > 0 && c != '0') ||
+                (c == '0' && length > phoneNumPosition + 4)) {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            char c4 = sb.charAt(index + 3);
+            //check the india number type.
+            int type = checkIndiaNumber(c1, c2, c3, c4);
+            //for mobile phone
+            if (type == 0) {
+                dashPositions[numDashes++] = index + 2;
+                //+91 9X-YYNNNN -> +91 9X-YY-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            } else if (type == 2) {
+                //+91 NNNN -> + 91 NN-NN
+                dashPositions[numDashes++] = index + 2;
+            } else if (type == 3) {
+                //+91 NNNNN -> + 91 NNN-NN
+                dashPositions[numDashes++] = index + 3;
+            } else {
+                //+91 NNNNNN -> +91 NNNN-NN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            }
+        } else if (length > phoneNumPosition + 8) {
+            //XXYYNNNNNN -> XX-YY-NNNNNN
+            dashPositions[numDashes++] = phoneNumPosition + 2;
+            dashPositions[numDashes++] = phoneNumPosition + 4;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Russian Number
+     *
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Russia"
+     *
+     * Because in Russian, when dialing Long Distance or International Call, the prefix is 8~ or 8~10, it come to DTMF.
+     * There are plans to change those prefixes to '0' for national and '00' for international dialing, but they are not yet implemented.
+     * So, we don't check any Long Distance or International Call prefix, all number format as follow:
+     *
+     * +7 NNN-NNN-NN-NN
+     * +7 9NN-NNN-NN-NN
+     * YYY-NNN-NN-NN only in same country, so YYY can be ignored.
+     * NNN-NN-NN
+     * NN-NN-NN
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatRussianNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[3];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code.
+        if (phoneNumPosition > 0) {
+            //+7 NNNNNN -> +7 NNN-NNN
+            if (length > phoneNumPosition + 5) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            }
+            //+7 NNN-NNNNNN-> +7 NNN-NNN-NN
+            if (length > phoneNumPosition + 7) {
+                dashPositions[numDashes++] = phoneNumPosition + 6;
+            }
+            //+7 NNN-NNN-NNNN-> +7 NNN-NNN-NN-NN
+            if (length > phoneNumPosition + 9) {
+                dashPositions[numDashes++] = phoneNumPosition + 8;
+            }
+        } else if (length == phoneNumPosition + 6) {
+            //NNNNNN -> NN-NN-NN
+            dashPositions[numDashes++] = phoneNumPosition + 2;
+            dashPositions[numDashes++] = phoneNumPosition + 4;
+        } else if (length == phoneNumPosition + 7) {
+            //NNNNNNN -> NNN-NN-NN
+            dashPositions[numDashes++] = phoneNumPosition + 3;
+            dashPositions[numDashes++] = phoneNumPosition + 5;
+        } else if (length >= phoneNumPosition + 8) {
+            //NNNNNNNN - > NNN-NNN-NN
+            dashPositions[numDashes++] = phoneNumPosition + 3;
+            dashPositions[numDashes++] = phoneNumPosition + 6;
+            //NNN-NNN-NNNN -> NNN-NNN-NN-NN
+            if (length > phoneNumPosition + 9) {
+                dashPositions[numDashes++] = phoneNumPosition + 8;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Germany region codes: three digits, exclude XX1.
+     *
+     * Warning: 212 must don't follow 9.
+     * reference: "http://en.wikipedia.org/wiki/Area_codes_in_Germany"
+     *
+     */
+    private static final int[] Germany_THREE_PART_REGION_CODES = {
+            202, 203, 208, 209, 212, 214, 221, 228, 234, 249, 310, 335, 340, 345, 365, 375, 385, 395,
+            457, 458, 459, 700, 709, 710, 728, 729, 749, 759, 769, 778, 779, 786, 787, 788, 789, 792,
+            798, 799, 800, 872, 875, 879, 900, 902, 903, 906
+    };
+
+    /**
+     * Germany region codes: four digits, and started with 3.
+     * reference: "http://en.wikipedia.org/wiki/Area_codes_in_Germany"
+     */
+    private static final int[] Germany_FOUR_PART_REGION_CODES = {
+            3301, 3302, 3303, 3304, 3306, 3307, 3321, 3322, 3327, 3328, 3329, 3331, 3332, 3334,
+            3335, 3337, 3338, 3341, 3342, 3344, 3346, 3361, 3362, 3364, 3366, 3371, 3372, 3375,
+            3377, 3378, 3379, 3381, 3382, 3385, 3386, 3391, 3394, 3395, 3421, 3423, 3425, 3431,
+            3433, 3435, 3437, 3441, 3443, 3445, 3447, 3448, 3461, 3462, 3464, 3466, 3471, 3473,
+            3475, 3476, 3491, 3493, 3494, 3496, 3501, 3504, 3521, 3522, 3523, 3525, 3528, 3529,
+            3531, 3533, 3537, 3541, 3542, 3544, 3546, 3561, 3562, 3563, 3564, 3571, 3573, 3574,
+            3576, 3578, 3581, 3583, 3585, 3586, 3588, 3591, 3592, 3594, 3596, 3601, 3603, 3605,
+            3606, 3621, 3622, 3623, 3624, 3626, 3627, 3628, 3629, 3631, 3632, 3634, 3635, 3636,
+            3641, 3643, 3644, 3647, 3661, 3663, 3671, 3672, 3675, 3677, 3679, 3680, 3681, 3682,
+            3683, 3685, 3686, 3691, 3693, 3695, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3731,
+            3733, 3735, 3737, 3741, 3744, 3745, 3761, 3762, 3763, 3764, 3765, 3771, 3772, 3773,
+            3774, 3821, 3831, 3834, 3838, 3841, 3843, 3844, 3847, 3871, 3874, 3876, 3877, 3881,
+            3883, 3886, 3901, 3921, 3923, 3925, 3928, 3931, 3933, 3935, 3937, 3941, 3942, 3943,
+            3944, 3946, 3947, 3949, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3971,
+            3973, 3976, 3981, 3984, 3991, 3994, 3996, 3997
+    };
+
+    /**
+     * format Germany call Number
+     *
+     * Prefix   Service type
+     *  01  Non-geographic area codes
+     *  02  Geographic area codes around Dusseldorf
+     *  03  Geographic area codes around Berlin, except 031 and 032
+     *  04  Geographic area codes around Hamburg
+     *  05  Geographic area codes around Hannover
+     *  06  Geographic area codes around Frankfurt am Main
+     *  07  Geographic area codes around Stuttgart, except 0700
+     *  08  Geographic area codes around Munich, except 0800
+     *  09  Geographic area codes around Nuremberg, except 0900
+     *  11  Network services
+     *
+     * Reference: "http://en.wikipedia.org/wiki/%2B49"
+     *
+     * WARNING: Geographic area codes have a length of two to five digits (not including the 0 trunk code).
+     * Two Digits:      Berlin (030), Hamburg (040), Frankfurt (069) and Munich (089).
+     * Three Digits:    as 0XX1 or in Germany_THREE_PART_REGION_CODES, and is not previous case.
+     * Four Digits:     it is not previous case, if don't start with 03, and , or in Germany_FOUR_PART_REGION_CODES, is four digits.
+     * Five Digits:     start with 03, and is not previous case, is five digits.
+     *
+     * +49 NN-NNN-NNNNN
+     * +49 NNN-NNN-NNNNN
+     * +49 NNNN-NNN-NNNN
+     * +49 3NNNN-NNN-NNN
+     * +49 1NN-NNNNNN-NN
+     *
+     * 0NN-NNN-NNNNN
+     * 0NNN-NNN-NNNNN
+     * 0NNNN-NNN-NNNN
+     * 03NNNN-NNN-NNN
+     * 01NN-NNNNNN-NN
+     *
+     * NNN-NNNNN
+     * NNN-NNNN
+     * NNN-NNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatGermanyNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        //has country code. or started with '0'
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            //for +49 1X
+            if (c1 == '1') {
+                //+49 1XXNNN -> +49 1XX-NNN or 01XXNNN -> 01XX-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //mobile phone 015X, 016X, 017X
+                if (c2 == '5' || c2 == '6' || c2 == '7') {
+                    //+49 1XX-NNNNNNNN->+49 1XX-NNNNNN-NN or 01XX-NNNNNNNN - > 01XX-NNNNNN-NN
+                    if (length > index + 10) {
+                        dashPositions[numDashes++] = index + 9;
+                    }
+                }
+            } else //Berlin (030), Hamburg (040), Frankfurt (069) and Munich (089).
+                if ((c1 == '3' && c2 == '0') || (c1 == '4' && c2 == '0')
+                    || (c1 == '6' && c2 == '9') || (c1 == '8' && c2 == '9')) {
+                //+49 NNNNN -> +49 NN-NNN or 0NNNNN -> 0NN-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+                //+49 NN-NNNNNN -> +49 NN-NNN-NNN
+                if (length > index + 6) {
+                    dashPositions[numDashes++] = index + 5;
+                }
+            } else if (length > index + 3) {
+                char c3 = sb.charAt(index + 2);
+                char c4 = sb.charAt(index + 3);
+                int key3 = (c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0');
+                int key4 = key3 * 10 + (c4 - '0');
+                //0XX1 or in Germany_THREE_PART_REGION_CODES is 0NNN region code.
+                if (c3 == '1' || (Arrays.binarySearch(Germany_THREE_PART_REGION_CODES, key3) >= 0 && (key3 != 212 || key3 == 212 && c4 != '9'))) {
+                    //+49 NNNNNN -> +49 NNN-NNN
+                    if (length > index + 4) {
+                        dashPositions[numDashes++] = index + 3;
+                    }
+                    //+49 NNN-NNNNNN -> +49 NNN-NNN-NNN
+                    if (length > index + 7) {
+                        dashPositions[numDashes++] = index + 6;
+                    }
+                } else //if don't start with 03, and is not previous case or in Germany_FOUR_PART_REGION_CODES, is four digits.
+                    if (c1 != '3' || c1 == '3' && Arrays.binarySearch(Germany_FOUR_PART_REGION_CODES, key4) >= 0) {
+                        //+49 NNNNNNN -> +49 NNNN-NNN
+                        if (length > index + 5) {
+                            dashPositions[numDashes++] = index + 4;
+                        }
+                        //+49 NNNN-NNNNNN -> +49 NNNN-NNN-NNN
+                        if (length > index + 8) {
+                            dashPositions[numDashes++] = index + 7;
+                        }
+                } else {
+                    //start with 03, and is not previous case, is five digits.
+                    //+49 NNNNNNNN -> +49 NNNNN-NNN
+                    if (length > index + 6) {
+                        dashPositions[numDashes++] = index + 5;
+                    }
+                    //+49 NNNNN-NNNNNN -> +49 NNNNN-NNN-NNN
+                    if (length > index + 9) {
+                        dashPositions[numDashes++] = index + 8;
+                    }
+                }
+            }
+        } else if (length >= phoneNumPosition + 6 && length <= phoneNumPosition + 8) {
+            dashPositions[numDashes++] = phoneNumPosition + 3;
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Italy Mobile Phone Number Prefixs
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Italy"
+     *
+     */
+    private static final int[] ITALY_MOBILE_PREFIXS = {
+        328, 329, 330, 333, 334, 335, 336, 337, 338,
+        339, 347, 348, 349, 360, 368, 380, 388, 389
+    };
+
+    /**
+     * format Italy Number
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_Italy"
+     *
+     * Land line numbers (area code+exchange+number) are generally 9 or 10 digits long,
+     * although they can be as little as 6 or as many as 11 digits.
+     * Mobile numbers are always 10 digits long, with the only exception of very old TIM numbers,
+     * which are 9 digits long (though those are now extremely rare).
+     * Mobile phone number in Italy: without a zero, started with a 3.
+     *
+     * +39 3NN-NNN-NNNN
+     * +39 N-NNNNNNNN
+     * +39 NN-NNNNNNNN
+     * +39 NNN-NNNNNNN
+     *
+     * 3NN-NNN-NNNN
+     * 0N-NNNNNNNN
+     * 0NN-NNNNNNNN
+     * 0NNN-NNNNNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatItalyNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            int key = (c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0');
+            //mobile phone number
+            if (Arrays.binarySearch(ITALY_MOBILE_PREFIXS, key) >= 0) {
+                //+39 3NNNNN -> +39 3NN-NNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+39 NNN-NNNNNN -> +49 NNN-NNN-NNN
+                if (length > index + 8) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else if (c1 == '2' || c1 == '6') {
+                //for Milan(02)
+                //    Rome (including State of Vatican City) and Aprilia 06
+                dashPositions[numDashes++] = index + 1;
+            } else if (c2 == '0' || c2 == '1' || c2 == '5' || c2 == '9') {
+                //10,11,15,19
+                //30,31,35,39
+                //40,41,45,49
+                //50,51,55,59
+                //70,71,75,79
+                //80,81,85,89
+                //90,91,95,99
+                //+39 NNNNN - > +39 NN-NNN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 2;
+                }
+            } else {
+                //+39 NNNNNN-> + 39 NNN-NNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+            }
+        } else {
+            char c1 = sb.charAt(phoneNumPosition);
+            char c2 = sb.charAt(phoneNumPosition + 1);
+            char c3 = sb.charAt(phoneNumPosition + 2);
+            int key = (c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0');
+            if (Arrays.binarySearch(ITALY_MOBILE_PREFIXS, key) >= 0) {
+                //+39 3NNNNN -> +39 3NN-NNN
+                if (length > phoneNumPosition + 5) {
+                    dashPositions[numDashes++] = phoneNumPosition + 3;
+                }
+                //+39 NNN-NNNNNN -> +49 NNN-NNN-NNN
+                if (length > phoneNumPosition + 7) {
+                    dashPositions[numDashes++] = phoneNumPosition + 6;
+                }
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format France Call Number
+     *
+     * refernce "http://en.wikipedia.org/wiki/Telephone_numbers_in_France"
+     *
+     * All geographic numbers had to be dialed in the ten-digit format, even for local calls.
+     * The international access code also changed from 19 to 00.
+     * Following liberalisation in 1998, subscribers could access different carriers by
+     * replacing the '0' (omitted from numbers when called from outside France) with another digit.
+     * For example Cegetel required subscribers to dial '7', e.g: Paris 71 xx xx xx xx, instead of 01 xx xx xx xx.
+     * Similarly, the international access code using Cegetel would be '70', instead of '00'.
+     * 00 (France Telecom)
+     * 40 (TELE 2)
+     * 50 (OMNICOM)
+     * 70 (LE 7 CEGETEL)
+     * 90 (9 TELECOM)
+     *
+     * +33 N-NN-NN-NN-NN
+     *
+     * TN-NN-NN-NN-NN, T = 0,4,5,7,9
+     *
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatFranceNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[4];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        int c = sb.charAt(phoneNumPosition);
+        if (phoneNumPosition > 0 || c == '0' || c == '4' || c == '5' || c == '7' || c == '9') {
+            int index = phoneNumPosition;
+            if (phoneNumPosition == 0 && (c == '0' || c == '4' || c == '5' || c == '7' || c == '9') || phoneNumPosition > 0 && c == '0') {
+                index ++;
+            }
+            //+33 NNNN-> +33 N-NNN
+            dashPositions[numDashes++] = index + 1;
+            //+33 N-NNNN-> +33 N-NN-NN
+            if (length > index + 4) {
+                dashPositions[numDashes++] = index + 3;
+            }
+            //+33 N-NN-NNNN -> +33 N-NN-NN-NN
+            if (length > index + 6) {
+                dashPositions[numDashes++] = index + 5;
+            }
+            //+33 N-NN-NN-NNNN -> +33 N-NN-NN-NN-NN
+            if (length > index + 8) {
+                dashPositions[numDashes++] = index + 7;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format United Kingdom call number
+     *
+     * All mobile telephone numbers have 10 national (significant) numbers after the "0" trunk code.
+     * In the United Kingdom, area codes are two, three, four, or, rarely, five digits long (after the initial zero).
+     * Regions with shorter area codes, typically large cities, permit the allocation of more telephone numbers
+     * as the local number portion has more digits. Local customer numbers are four to eight figures long.
+     * The total number of digits is ten, but in a very few areas the total may be nine digits (after the initial zero).
+     *
+     * reference: "http://en.wikipedia.org/wiki/Telephone_numbers_in_the_United_Kingdom"
+     *            "http://en.wikipedia.org/wiki/List_of_United_Kingdom_dialling_codes"
+     *            "http://www.ofcom.org.uk/static/archive/oftel/publications/numbering/2003/num_guide.htm"
+     *
+     * +44 2N-NNNN-NNNN
+     * +44 1NN-NNN-NNNN
+     * +44 1NNN-NNNNN(N)
+     * +44 1NNNN-NNNNN(N)
+     * +44 3NN-NNN-NNNN
+     * +44 5N-NNNN-NNNN
+     * +44 7NNN-NNNNNN
+     * +44 8NN-NNN-NNNN
+     * +44 9NN-NNN-NNNN
+     *
+     * 02N-NNNN-NNNN
+     * 01NN-NNN-NNNN
+     * 01NNN-NNNNN(N)
+     * 01NNNN-NNNNN(N)
+     * 03NN-NNN-NNNN
+     * 05N-NNNN-NNNN
+     * 07NNN-NNNNNN
+     * 08NN-NNN-NNNN
+     * 09NN-NNN-NNNN
+     *
+     * NNNN-NNNN
+     * NNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatEnglandNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            char c1 = sb.charAt(index);
+            char c2 = sb.charAt(index + 1);
+            char c3 = sb.charAt(index + 2);
+            //for mobile phone
+            if (c1 == '7') {
+                //+44 7NNNNNNNNN -> +44 7NNN-NNNNNN
+                if (length > index + 5) {
+                    dashPositions[numDashes++] = index + 4;
+                }
+            } else if (c1 == '2') {
+                //+44 2NNN - > +44 2N-NN
+                dashPositions[numDashes++] = index + 2;
+                //+44 2N-NNNNNNNN -> +44 2N-NNNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else if (c1 == '1') { //for region code.
+                char c4 = sb.charAt(index + 2);
+                int key = (c1 - '0') * 1000 + (c2 - '0') * 100 + (c3 - '0') * 10 + c4;
+                if (c2 == '1' || c3 == '1') {
+                    //+44 1NN-NN -> +44 1NN-NN
+                    if (length > index + 4) {
+                        dashPositions[numDashes++] = index + 3;
+                    }
+                    //+44 1NN-NNNNN -> 1NN-NNN-NN
+                    if (length > index + 7) {
+                        dashPositions[numDashes++] = index + 6;
+                    }
+                } else if (key != 1387 && key != 1539 && key != 1697 && key != 1768 && key != 1946) {
+                    // don't started with 01387, 01539, 01697, 01524, 01768, 01946
+                    //+44 1NNNNN -> +44 1NNN-NN
+                    if (length > index + 5) {
+                        dashPositions[numDashes++] = index + 4;
+                    }
+                } else {
+                    //+44 1NNNNNN -> +44 1NNNN-NN
+                    if (length > index + 6) {
+                        dashPositions[numDashes++] = index + 5;
+                    }
+                }
+            } else if (c1 == '3' || c1 == '8' || c1 == '9') {
+                //+44 NNNNN-> +44 NNN-NN
+                if (length > index + 4) {
+                    dashPositions[numDashes++] = index + 3;
+                }
+                //+44 NNN-NNNNN -> NNN-NNN-NN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            } else {
+                //other as 0NN-NNNN-NNNN
+                //+44 NNNN - > +44 NN-NN
+                dashPositions[numDashes++] = index + 2;
+                //+44 NN-NNNNNNNN -> +44 NN-NNNN-NNNN
+                if (length > index + 7) {
+                    dashPositions[numDashes++] = index + 6;
+                }
+            }
+        } else {
+            if (length > phoneNumPosition + 4 && length < phoneNumPosition + 8) { //NNN-NNNN
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            } else if (length >= phoneNumPosition + 8) { //NNNN-NNNN
+                dashPositions[numDashes++] = phoneNumPosition + 4;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * format Turkey Phone Number.
+     *
+     * reference "http://en.wikipedia.org/wiki/Telephone_numbers_in_Turkey"
+     *
+     * +90 NNN-NNN-NNNN
+     * 0NNN-NNN-NNNN
+     * NNN-NNNN
+     *
+     * @param sb
+     * @param blankPosition
+     * @return
+     */
+    private static String formatTurkeyNumber(StringBuilder sb, int blankPosition) {
+        int length = sb.length();
+        // When scanning the number we record where dashes need to be added,
+        // if they're non-0 at the end of the scan the dashes will be added in
+        // the proper places.
+        int dashPositions[] = new int[2];
+        int numDashes = 0;
+        int phoneNumPosition = (blankPosition == -1) ? 0 : blankPosition + 1;
+        if (phoneNumPosition > 0 || sb.charAt(phoneNumPosition) == '0') {
+            int index = phoneNumPosition;
+            if (sb.charAt(phoneNumPosition) == '0') {
+                index ++;
+            }
+            //+90 NNNNN -> +90 NNN-NN
+            if (length > index + 4) {
+                dashPositions[numDashes++] = index + 3;
+            }
+            //+90 NNN-NNNNN - > +90 NNN-NNN-NN
+            if (length > index + 7) {
+                dashPositions[numDashes++] = index + 6;
+            }
+        } else {
+            //NNNNNNN -> NNN-NNNN
+            if (length > phoneNumPosition + 4) {
+                dashPositions[numDashes++] = phoneNumPosition + 3;
+            }
+        }
+        int pos;
+        for (int i = 0; i < numDashes; i++) {
+            pos = dashPositions[i];
+            sb.replace(pos + i, pos + i, "-");
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Dump log information.
+     * @param info Log information.
+     * @hide
+     */
+    public static void log(String info) {
+        if (DEBUG) Rlog.d(TAG, info);
+        }
+}
diff --git a/src/java/com/mediatek/telephony/PhoneNumberFormattingTextWatcherEx.java b/src/java/com/mediatek/telephony/PhoneNumberFormattingTextWatcherEx.java
new file mode 100755
index 0000000000..62b6e2b3ee
--- /dev/null
+++ b/src/java/com/mediatek/telephony/PhoneNumberFormattingTextWatcherEx.java
@@ -0,0 +1,135 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+package com.mediatek.telephony;
+
+import android.text.Editable;
+import android.text.Selection;
+import android.text.TextWatcher;
+
+
+/**
+ * Watches a TextView and if a phone number is entered will format it. The formatting
+ * is based on the current system default sim iso. when this object is created and future
+ * sim changes may not take effect on this instance.
+ * @hide
+ */
+public class PhoneNumberFormattingTextWatcherEx implements TextWatcher {
+
+    static private int sFormatType;
+    //static private Locale sCachedLocale;
+    private String sCachedSimIso;
+    private boolean mFormatting;
+    private boolean mDeletingHyphen;
+    private int mHyphenStart;
+    private boolean mDeletingBackward;
+
+
+    public PhoneNumberFormattingTextWatcherEx() {
+        /*
+        if (sCachedLocale == null || sCachedLocale != Locale.getDefault()) {
+            sCachedLocale = Locale.getDefault();
+            sFormatType = PhoneNumberFormatUtilEx.getFormatTypeForLocale(sCachedLocale);
+        }
+        */
+        if (sCachedSimIso == null) {
+            sCachedSimIso = PhoneNumberFormatUtilEx.getDefaultSimCountryIso();
+            sFormatType = PhoneNumberFormatUtilEx.getFormatTypeFromCountryCode(sCachedSimIso);
+        }
+    }
+
+    /**
+     * Format the input string after the text is changed.
+     * @param text The text editor to be formatted.
+     * @hide
+     */
+    public synchronized void afterTextChanged(Editable text) {
+        // Make sure to ignore calls to afterTextChanged caused by the work done below
+        if (!mFormatting) {
+            mFormatting = true;
+
+            // If deleting the hyphen, also delete the char before or after that
+            if (mDeletingHyphen && mHyphenStart > 0) {
+                if (mDeletingBackward) {
+                    if (mHyphenStart - 1 < text.length()) {
+                        text.delete(mHyphenStart - 1, mHyphenStart);
+                    }
+                } else if (mHyphenStart < text.length()) {
+                    text.delete(mHyphenStart, mHyphenStart + 1);
+                }
+            }
+
+            PhoneNumberFormatUtilEx.formatNumber(text, sFormatType);
+            mFormatting = false;
+        }
+    }
+
+    /**
+     * Check if the user is deleting a hyphen.
+     * @param s The string to be checked.
+     * @param start start value of selection
+     * @param count The count of character to be deleted
+     * @param after Check if for deleting
+     * @hide
+     */
+    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+        // Check if the user is deleting a hyphen
+        if (!mFormatting) {
+            // Make sure user is deleting one char, without a selection
+            final int selStart = Selection.getSelectionStart(s);
+            final int selEnd = Selection.getSelectionEnd(s);
+            if (s.length() > 1 // Can delete another character
+                    && count == 1 // Deleting only one character
+                    && after == 0 // Deleting
+                    && s.charAt(start) == '-' // a hyphen
+                    && selStart == selEnd) { // no selection
+                mDeletingHyphen = true;
+                mHyphenStart = start;
+                // Check if the user is deleting forward or backward
+                if (selStart == start + 1) {
+                    mDeletingBackward = true;
+                } else {
+                    mDeletingBackward = false;
+                }
+            } else {
+                mDeletingHyphen = false;
+            }
+        }
+    }
+
+    /**
+     * Not used.
+     * @hide
+     */
+    public void onTextChanged(CharSequence s, int start, int before, int count) {
+        // Does nothing
+    }
+}
+
diff --git a/src/java/com/mediatek/telephony/TelephonyManagerEx.java b/src/java/com/mediatek/telephony/TelephonyManagerEx.java
new file mode 100644
index 0000000000..0375ade908
--- /dev/null
+++ b/src/java/com/mediatek/telephony/TelephonyManagerEx.java
@@ -0,0 +1,1368 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.telephony;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+
+import com.android.internal.telephony.IPhoneSubInfo;
+import com.android.internal.telephony.ITelephony;
+import com.android.internal.telephony.ITelephonyRegistry;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyProperties;
+
+import android.os.Message;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+import java.util.List;
+
+import android.telephony.SubscriptionManager;
+import com.mediatek.internal.telephony.ITelephonyEx;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
+
+/**
+ * Provides access to information about the telephony services on
+ * the device, especially for multiple SIM cards device.
+ *
+ * Applications can use the methods in this class to
+ * determine telephony services and states, as well as to access some
+ * types of subscriber information. Applications can also register
+ * a listener to receive notification of telephony state changes.
+ *
+ * Note that access to some telephony information is
+ * permission-protected. Your application cannot access the protected
+ * information unless it has the appropriate permissions declared in
+ * its manifest file. Where permissions apply, they are noted in the
+ * the methods through which you access the protected information.
+ */
+public class TelephonyManagerEx {
+    private static final String TAG = "TelephonyManagerEx";
+
+    private Context mContext = null;
+    private ITelephonyRegistry mRegistry;
+
+
+    /* Add for  Phone2 */
+    private static int defaultSimId = PhoneConstants.SIM_ID_1;
+
+   /**
+    * The property record the card's ICC ID.
+    * @hide
+    */
+    private String[] PROPERTY_ICCID_SIM = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+
+    /**
+     * Construction function for TelephonyManager
+     * @param context a context
+     */
+    public TelephonyManagerEx(Context context) {
+
+        Rlog.d(TAG, "getSubscriberInfo");
+        mContext = context;
+        mRegistry = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService(
+                    "telephony.registry"));
+
+    }
+
+    /*  Construction function for TelephonyManager */
+    private TelephonyManagerEx() {
+
+        mRegistry = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService(
+                   "telephony.registry"));
+    }
+
+    private  static TelephonyManagerEx sInstance = new TelephonyManagerEx();
+
+    /** @hide
+     *  @return return the static instance of TelephonyManagerEx
+     */
+    public static TelephonyManagerEx getDefault() {
+        return sInstance;
+    }
+
+    /**
+     * @param simId Indicates which SIM(slot) to query
+     * @return The software version number for the device
+     * @hide
+     */
+    public String getDeviceSoftwareVersion(int simId) {
+        Rlog.d(TAG, "getDeviceSoftwareVersion simId=" + simId);
+        try {
+            return TelephonyManager.getDefault().getDeviceSoftwareVersion(simId);
+        } catch (NullPointerException ex) {
+            Rlog.e(TAG, "getDeviceSoftwareVersion error, return null. (" + ex.toString() + ")");
+            return null;
+        }
+    }
+
+    //
+    //
+    // Device Info
+    //
+    //
+
+    /**
+     * Returns the unique device identifier e.g. IMEI for GSM phones. MEID or ESN for CDMA phones.
+     * For GSM phone with multiple SIM support , there is IMEI for each SIM.
+     * Required Permission:
+     *  android.Manifest.permission READ_PHONE_STATE READ_PHONE_STATE
+     *
+     * @param simId Indicates which SIM(slot) to query
+     * @return Unique device ID. For GSM phones,a string of IMEI
+     * returns null if the device ID is not available.
+     */
+    public String getDeviceId(int simId) {
+        Rlog.d(TAG, "getDeviceId simId=" + simId);
+        try {
+            return TelephonyManager.getDefault().getDeviceId(simId);
+        } catch (NullPointerException ex) {
+            Rlog.e(TAG, "getDeviceId error, return null. (" + ex.toString() + ")");
+            return null;
+        }
+    }
+
+    /**
+     * Returns the current cell location of the device.
+     * <p>
+     * Required Permission:
+     *  android.Manifest.permission#ACCESS_COARSE_LOCATION ACCESS_COARSE_LOCATION or
+     *  android.Manifest.permission#ACCESS_COARSE_LOCATION ACCESS_FINE_LOCATION.
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return current cell location of the device. A CellLocation object
+     * returns null if the current location is not available.
+     *
+     */
+    public CellLocation getCellLocation(int simId) {
+        Rlog.e(TAG, "Deprecated! getCellLocation with simId " + simId);
+
+
+        try {
+            return TelephonyManager.getDefault().getCellLocation();
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return null;
+        }
+    }
+
+    /**
+     * Returns the neighboring cell information of the device. The getAllCellInfo is preferred
+     * and use this only if getAllCellInfo return nulls or an empty list.
+     *<p>
+     * In the future this call will be deprecated.
+     *<p>
+     * @return List of NeighboringCellInfo or null if info unavailable.
+     *
+     * Required Permission:
+     *   "android.Manifest.permission#ACCESS_COARSE_UPDATES"
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return list of NeighboringCellInfo, java.util.List<android.telephony.NeighboringCellInfo>, or null if info is unavailable
+     *
+     */
+    public List<NeighboringCellInfo> getNeighboringCellInfo(int simId) {
+        Rlog.e(TAG, "Deprecated! getNeighboringCellInfo with simId " + simId);
+
+        try {
+            return TelephonyManager.getDefault().getNeighboringCellInfo();
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return null;
+        }
+    }
+
+    /**
+     * Returns a constant indicating the device phone type.  This
+     * indicates the type of radio used to transmit voice calls.
+     *
+     * @param simId Indicates which SIM(slot) to query
+     * @return  a constant indicating the device phone type
+     *
+     * @see #PHONE_TYPE_NONE
+     * @see #PHONE_TYPE_GSM
+     * @see #PHONE_TYPE_CDMA
+     */
+    public int getPhoneType(int simId) {
+        int subIds[] = SubscriptionManager.getSubId(simId);
+        Rlog.e(TAG, "Deprecated! getPhoneType with simId " + simId + ", subId " + subIds[0]);
+        return TelephonyManager.getDefault().getCurrentPhoneType(subIds[0]);
+    }
+
+    //
+    // Current Network
+    //
+
+    /**
+     * Returns the alphabetic name of current registered operator.
+     * Please call TelephonyManager.getNetworkOperatorName(int subId) instead
+     * <p>
+     * Availability: Only when the user is registered to a network. Result may be
+     * unreliable on CDMA networks (use getPhoneType(int simId)) to determine if
+     * it is on a CDMA network).
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return alphabetic name of the current registered operator, e.g. "Vodafone"
+     */
+    public String getNetworkOperatorName(int simId) {
+        try {
+            int subId = getSubIdBySlot(simId);
+            Rlog.e(TAG, "Deprecated! getNetworkOperatorName with simId " + simId + " ,subId " + subId);
+            return TelephonyManager.getDefault().getNetworkOperatorName(subId);
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return "";
+        }
+    }
+
+    /**
+     * Returns the numeric name (MCC+MNC) of the current registered operator.
+     * Please call TelephonyManager.getNetworkOperator(int subId) instead
+     * <p>
+     * Availability: Only when the user is registered to a network. Result may be
+     * unreliable on CDMA networks (use getPhoneType(int simId)) to determine if
+     * it is on a CDMA network).
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return numeric name (MCC+MNC) of current registered operator, e.g. "46000".
+     */
+    public String getNetworkOperator(int simId) {
+        try {
+            int subId = getSubIdBySlot(simId);
+            Rlog.e(TAG, "Deprecated! getNetworkOperator with simId " + simId + " ,subId " + subId);
+            return TelephonyManager.getDefault().getNetworkOperatorForSubscription(subId);
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return "";
+        }
+    }
+
+    /**
+     * Indicates whether the device is considered roaming on the current  network, for GSM purposes.
+     * Please call TelephonyManager.isNetworkRoaming(int subId) instead
+     * <p>
+     * Availability: Only when the user is registered to a network.
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return Returns True if the device is considered roaming on the current network; otherwise false.
+     *
+     */
+    public boolean isNetworkRoaming(int simId) {
+        try {
+            int subId = getSubIdBySlot(simId);
+            Rlog.e(TAG, "Deprecated! isNetworkRoaming with simId " + simId + " ,subId " + subId);
+            return TelephonyManager.getDefault().isNetworkRoaming(subId);
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return false;
+        }
+    }
+
+    /**
+     * Returns the ISO country code of the current registered operator's MCC(Mobile Country Code).
+     * Please call TelephonyManager.getNetworkCountryIso(int subId) instead
+     * <p>
+     * Availability: Only when the user is registered to a network. Result may be
+     * unreliable on CDMA networks (use getPhoneType(int simId)) to determine if
+     * it is on a CDMA network).
+     *
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return ISO country code equivilent of the current registered
+     * operator's MCC (Mobile Country Code), e.g. "en","fr"
+     */
+    public String getNetworkCountryIso(int simId) {
+        try {
+            int subId = getSubIdBySlot(simId);
+            Rlog.e(TAG, "Deprecated! getNetworkCountryIso with simId " + simId + " ,subId " + subId);
+            return TelephonyManager.getDefault().getNetworkCountryIsoForSubscription(subId);
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+            return "";
+        }
+    }
+
+    /**
+     * Returns a constant indicating the radio technology (network type)
+     * currently used on the device for data transmission.
+     * Please  call TelephonyManager.getNetworkType(int subId) instead
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * @return constant indicating the radio technology (network type)
+     * currently used on the device. Constant may be one of the following items.
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_GPRS
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EDGE
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_UMTS
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_HSPA
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_CDMA
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EVDO_0
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EVDO_A
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EVDO_B
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_1xRTT
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_IDEN
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_LTE
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_EHRPD
+     * <p>
+     * android.telephony.TelephonyManager.NETWORK_TYPE_HSPAP
+     */
+    public int getNetworkType(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "Deprecated! getNetworkType with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getNetworkType(subId);
+    }
+
+
+    //
+    //
+    // SIM Card
+    //
+    //
+
+    /**
+     * Gets true if a ICC card is present
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Returns True if a ICC card is present.
+     */
+    public boolean hasIccCard(int simId) {
+        Rlog.d(TAG, "hasIccCard simId=" + simId);
+        int slot = simId;
+        return TelephonyManager.getDefault().hasIccCard(slot);
+    }
+
+    private int getSubIdBySlot(int slot) {
+        int [] subId = SubscriptionManager.getSubId(slot);
+        Rlog.d(TAG, "getSubIdBySlot, simId " + slot +
+                "subId " + ((subId != null) ? subId[0] : "invalid!"));
+        return (subId != null) ? subId[0] : SubscriptionManager.getDefaultSubId();
+    }
+
+    /**
+     * Get Icc Card Type
+     * @param subId which subId to query
+     * @return "SIM" for SIM card or "USIM" for USIM card.
+     * @hide
+     * @internal
+     */
+    public String getIccCardType(int subId) {
+        String type = null;
+        try {
+            ITelephonyEx telephony = getITelephonyEx();
+            if (telephony != null) {
+                type = telephony.getIccCardType(subId);
+            }
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            ex.printStackTrace();
+        }
+        Rlog.d(TAG, "getIccCardType sub " + subId + " ,icc type " + ((type != null) ? type : "null"));
+        return type;
+    }
+
+    /**
+     * Request to get UICC card type.
+     *
+     * @param slotId indicated sim id
+     *
+     * @return index for UICC card type
+     * @hide
+    */
+   public int getSvlteCardType(int slotId) {
+       int type = 0;
+       try {
+           ITelephonyEx telephony = getITelephonyEx();
+           if (telephony != null && CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+               type = telephony.getSvlteCardType(slotId);
+           }
+       } catch (RemoteException ex) {
+           ex.printStackTrace();
+       } catch (NullPointerException ex) {
+           // This could happen before phone restarts due to crashing
+           ex.printStackTrace();
+       }
+       Rlog.d(TAG, "getSvlteCardType(): slotId " + slotId + " ,icc type " + type);
+       return type;
+   }
+
+    /**
+     * Query is indicated app type is support of indicated Uicc Card.
+     * @param slotId which slotId to query
+     * @return "true" for supported case or "boolean" for non-supported case.
+     * @hide
+     */
+    public boolean isAppTypeSupported(int slotId, int appType) {
+        boolean isSupported = false;
+        try {
+            ITelephonyEx telephony = getITelephonyEx();
+            if (telephony != null) {
+                isSupported = telephony.isAppTypeSupported(slotId, appType);
+            }
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            ex.printStackTrace();
+        }
+        Rlog.d(TAG, "isAppTypeSupported slotId: " + slotId + ", appType: " + appType +
+                ", isSupported: " + isSupported);
+        return isSupported;
+    }
+
+    /**
+     * Get Icc Card is a test card or not.
+     * @param simId Indicate which sim(slot) to query
+     * @return ture if the ICC card is a test card.
+     * @hide
+     */
+    public boolean isTestIccCard(int simId) {
+        boolean result = false;
+        Rlog.d(TAG, "isTestIccCard simId=" + simId);
+        try {
+            ITelephonyEx telephony = getITelephonyEx();
+            if (telephony != null) {
+                result = telephony.isTestIccCard(simId);
+            }
+        } catch (RemoteException ex) {
+            ex.printStackTrace();
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            ex.printStackTrace();
+        }
+        Rlog.d(TAG, "isTestIccCard sim " + simId + " ,result " + result);
+        return result;
+    }
+
+    /**
+     * Gets a constant indicating the state of the device SIM card.
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Constant indicating the state of the device SIM card.
+     * Constant may be one of the following items.
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_UNKNOWN
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_ABSENT
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_PIN_REQUIRED
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_PUK_REQUIRED
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_NETWORK_LOCKED
+     * <p>
+     * android.telephony.TelephonyManager.SIM_STATE_READY
+     *
+     */
+    public int getSimState(int simId) {
+        Rlog.d(TAG, "getSimState simId=" + simId);
+        return TelephonyManager.getDefault().getSimState(simId);
+    }
+
+    /**
+     * Gets the MCC+MNC (mobile country code + mobile network code) of the provider of the SIM. 5 or 6 decimal digits.
+     * <p>
+     * Availability: The result of calling getSimState() must be android.telephony.TelephonyManager.SIM_STATE_READY.
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       MCC+MNC (mobile country code + mobile network code) of the provider of the SIM. 5 or 6 decimal digits.
+     *
+     */
+    public String getSimOperator(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getSimOperator with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getSimOperator(subId);
+    }
+
+    /**
+     * Gets the Service Provider Name (SPN).
+     * <p>
+     * Availability: The result of calling getSimState() must be android.telephony.TelephonyManager.SIM_STATE_READY.
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Service Provider Name (SPN)
+     *
+     */
+    public String getSimOperatorName(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getSimOperatorName with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getSimOperatorNameForSubscription(subId);
+    }
+
+    /**
+     * Gets the ISO country code equivalent for the SIM provider's country code.
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Gets the ISO country code equivalent for the SIM provider's country code.
+     *
+     */
+    public String getSimCountryIso(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getSimCountryIso with simId " + simId + " ,subId " + subId);
+
+        return TelephonyManager.getDefault().getSimCountryIso(subId);
+    }
+
+
+    /**
+     * Returns the serial number for the given subscription, if applicable. Return null if it is
+     * unavailable.
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       serial number of the SIM, if applicable. Null is returned if it is unavailable.
+     *
+     */
+    public String getSimSerialNumber(int simId) {
+        if (simId < 0 || simId >= TelephonyManager.getDefault().getSimCount()) {
+            Rlog.e(TAG, "getSimSerialNumber with invalid simId " + simId);
+            return null;
+        }
+
+        String iccId = SystemProperties.get(PROPERTY_ICCID_SIM[simId], "");
+
+        if (iccId != null && (iccId.equals("N/A") || iccId.equals(""))) {
+            iccId = null;
+        }
+
+        return iccId;
+    }
+
+    //
+    //
+    // Subscriber Info
+    //
+    //
+
+    /**
+     * Gets the unique subscriber ID, for example, the IMSI for a GSM phone.
+     * <p>
+     * Required Permission:
+     *   "android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE"
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       unique subscriber ID, for example, the IMSI for a GSM phone. Null is returned if it is unavailable.
+     *
+     */
+    public String getSubscriberId(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getSubscriberId with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getSubscriberId(subId);
+    }
+
+    /**
+     * Gets the phone number string for line 1, for example, the MSISDN for a GSM phone
+     * <p>
+     * Required Permission:
+     *   "android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE"
+     * <p>
+     * @param simId  Indicates which SIM to quer
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Phone number string for line 1, for example, the MSISDN for a GSM phone. Returns null if it is unavailable.
+     *
+     */
+
+    public String getLine1Number(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getLine1Number with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getLine1NumberForSubscriber(subId);
+    }
+
+
+    /**
+     * Gets the voice mail number.
+     * <p>
+     * Required Permission:
+     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
+     * <p>
+     * @param simId  Indicates which SIM (slot) to query
+     * <p>
+     * @return       Voice mail number. Null is returned if it is unavailable.
+     *
+     */
+    public String getVoiceMailNumber(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getVoiceMailNumber with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getVoiceMailNumber(subId);
+    }
+
+    /**
+     * Retrieves the alphabetic identifier associated with the voice mail number.
+     * <p>
+     * Required Permission:
+     *   "android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE"
+     * <p>
+     * @param simId  Indicates which SIM to query.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     * <p>
+     * @return       Alphabetic identifier associated with the voice mail number
+     *
+     */
+    public String getVoiceMailAlphaTag(int simId) {
+        int subId = getSubIdBySlot(simId);
+        Rlog.e(TAG, "getVoiceMailAlphaTag with simId " + simId + " ,subId " + subId);
+        return TelephonyManager.getDefault().getVoiceMailAlphaTag(subId);
+    }
+
+      /**
+     * Gets the current call state according to the specific SIM ID.
+     * The call state can be one of the following states:
+     * 1) android.telephony.TelephonyManager.CALL_STATE_IDLE;
+     * 2) android.telephony.TelephonyManager.CALL_STATE_RINGING;
+     * 3) android.telephony.TelephonyManager.CALL_STATE_OFFHOOK
+     * @param  simId SIM ID for getting call state.
+     *         Value of simId:
+     *         0 for SIM1;
+     *         1 for SIM2
+     * @return Constant indicating the call state (cellular) on the device.
+     * @internal
+     */
+    public int getCallState(int simId) {
+        Rlog.d(TAG, "getCallState simId=" + simId);
+        return TelephonyManager.getDefault().getCallState(getSubIdBySlot(simId));
+    }
+
+    /**
+     * Returns a constant indicating the type of activity on a data connection
+     * (cellular).
+     *
+     * The data activity can be one of the following:
+     * 1) DATA_ACTIVITY_NONE;
+     * 2) DATA_ACTIVITY_IN;
+     * 3) DATA_ACTIVITY_OUT;
+     * 4) DATA_ACTIVITY_INOUT;
+     * 5) DATA_ACTIVITY_DORMANT
+     *
+     * @param simId Indicates which SIM(slot) to query
+     * @return Constant indicating the type of activity on specific SIM's data connection
+     * (cellular).
+     * @internal
+     */
+    public int getDataActivity(int simId) {
+        Rlog.d(TAG, "getDataActivity simId=" + simId);
+        // MTK TODO
+        return TelephonyManager.getDefault().getDataActivity(/* getSubIdBySlot(simId) */);
+    }
+
+    /**
+     * Returns a constant indicating the specific SIM's data connection state
+     * (cellular).
+     *
+     * The data connection state can be one of the following states:
+     * 1) DATA_DISCONNECTED;
+     * 2) DATA_CONNECTING;
+     * 3) DATA_CONNECTED;
+     * 4) DATA_SUSPENDED
+     *
+     * @param simId Indicates which SIM(slot) to query
+     * @return Constant indicating specific SIM's data connection state
+     * (cellular).
+     * @internal
+     */
+    public int getDataState(int simId) {
+        Rlog.d(TAG, "getDataState simId=" + simId);
+        // MTK TODO
+        return TelephonyManager.getDefault().getDataState(/* getSubIdBySlot(simId) */);
+    }
+
+
+    //
+    //
+    // PhoneStateListener
+    //
+    //
+
+
+    /**
+     *
+     * Registers a listener object to receive notification of changes
+     * in specified telephony states.
+     *
+     * To register a listener, pass a PhoneStateListener
+     * and specify at least one telephony state of interest in
+     * the events argument.
+     *
+     * At registration, and when a specified telephony state
+     * changes, the telephony manager invokes the appropriate
+     * callback method on the listener object and passes the
+     * current (udpated) values.
+     *
+     * To unregister a listener, pass the listener object and set the
+     * events argument to PhoneStateListener LISTEN_NONE LISTEN_NONE.
+     *
+     * @param listener  the android.telephony.PhoneStateListener object
+     *                  to register or unregister
+     * @param events  the telephony state(s) of interest to the listener,
+     *               as a bitwise-OR combination of PhoneStateListener
+     *               LISTEN_ flags.
+     * @param simId  Indicates which SIM to regisrer or unregister.
+     *               Value of simId:
+     *                 0 for SIM1
+     *                 1 for SIM2
+     */
+    public void listen(PhoneStateListener listener, int events, int simId) {
+        Rlog.d(TAG, "deprecated api, listen simId=" + simId + ",events=" + events);
+        String pkgForDebug = mContext != null ? mContext.getPackageName() : "<unknown>";
+        TelephonyManager.getDefault().listen(listener, events);
+    }
+
+
+    private ITelephony getITelephony() {
+        return ITelephony.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE));
+    }
+
+    private ITelephonyEx getITelephonyEx() {
+        return ITelephonyEx.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+    }
+
+    /* Get current active phone type by system property, GsmPhone or CdmaPhone */
+    private int getPhoneTypeFromProperty() {
+        int type =
+            SystemProperties.getInt(TelephonyProperties.CURRENT_ACTIVE_PHONE,
+                    getPhoneTypeFromNetworkType());
+        return type;
+    }
+
+    /* Get phone type by network type, GsmPhone or CdmaPhone */
+    private int getPhoneTypeFromNetworkType() {
+    	int phoneId = SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultSubId());    	
+        String mode = TelephonyManager.getTelephonyProperty(
+                phoneId, "ro.telephony.default_network", null);
+        if (mode != null) {
+            return TelephonyManager.getDefault().getPhoneType(Integer.parseInt(mode));
+        }
+        return TelephonyManager.PHONE_TYPE_NONE;
+    }
+
+
+    /**
+     * Get service center address
+     *
+     * @param subId subscripiton identity
+     *
+     * @return Current service center address
+     * @hide
+     * @internal
+     */
+    public String getScAddress(int subId) {
+        Bundle result = getScAddressWithErroCode(subId);
+        if (result != null) {
+            return (String) result.getCharSequence(GET_SC_ADDRESS_KEY_ADDRESS);
+        }
+        return null;
+    }
+
+    /**
+     * Get SC address bundle key: result.
+     *
+     * @internal
+     * @hide
+     */
+    public static final String GET_SC_ADDRESS_KEY_RESULT = "errorCode";
+
+    /**
+     * Get SC address bundle key: scAddress.
+     *
+     * @internal
+     * @hide
+     */
+    public static final String GET_SC_ADDRESS_KEY_ADDRESS = "scAddress";
+
+    /**
+     * Error Code: success.
+     * Now, it is only used by {@link #getScAddressWithErroCode(subId)}.
+     *
+     * @internal
+     * @hide
+     */
+    public static final byte ERROR_CODE_NO_ERROR = 0x00;
+
+    /**
+     * Error Code: generic error.
+     * Now, it is only used by {@link #getScAddressWithErroCode(subId)}.
+     *
+     * @internal
+     * @hide
+     */
+    public static final byte ERROR_CODE_GENERIC_ERROR = 0x01;
+
+    /**
+     * Get service center address with error code.
+     *
+     * @param subId subscripiton identity
+     *
+     * @return Current service center address and error code by Bundle
+     * The error code will be
+     *     {@link #ERROR_CODE_NO_ERROR}
+     *     {@link #ERROR_CODE_GENERIC_ERROR}
+     *
+     * @internal
+     * @hide
+     */
+    public Bundle getScAddressWithErroCode(int subId) {
+        try {
+            return getITelephonyEx().getScAddressUsingSubId(subId);
+        } catch (RemoteException e1) {
+            e1.printStackTrace();
+            return null;
+        } catch (NullPointerException e2) {
+            e2.printStackTrace();
+            return null;
+        }
+    }
+
+    /**
+     * Set service center address
+     *
+     * @param subId subscripiton identity
+     * @param address Address to be set
+     *
+     * @return True for success, false for failure
+     * @hide
+     * @internal
+     */
+    public boolean setScAddress(int subId, String address) {
+        try {
+            return getITelephonyEx().setScAddressUsingSubId(subId, address);
+        } catch (RemoteException e1) {
+            e1.printStackTrace();
+            return false;
+        } catch (NullPointerException e2) {
+            e2.printStackTrace();
+            return false;
+        }
+    }
+
+    private IPhoneSubInfo getSubscriberInfo() {
+        // get it each time because that process crashes a lot
+        return IPhoneSubInfo.Stub.asInterface(ServiceManager.getService("iphonesubinfo"));
+    }
+
+
+    /**
+     * Returns the IMS private user identity (IMPI) that was loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return the IMPI, or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimImpi(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimImpiForSubscriber(subId);
+            return getSubscriberInfo().getIsimImpi();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the IMS home network domain name that was loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return the IMS domain name, or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimDomain(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimDomainForSubscriber(subId);
+            return getSubscriberInfo().getIsimDomain();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the IMS public user identities (IMPU) that were loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return an array of IMPU strings, with one IMPU per string, or null if
+     *      not present or not loaded
+     * @hide
+     */
+    public String[] getIsimImpu(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimImpuForSubscriber(subId);
+            return getSubscriberInfo().getIsimImpu();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the IMS Service Table (IST) that was loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return IMS Service Table or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimIst(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimIstForSubscriber(subId);
+            return getSubscriberInfo().getIsimIst();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the IMS Proxy Call Session Control Function(PCSCF) that were loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return an array of PCSCF strings with one PCSCF per string, or null if
+     *         not present or not loaded
+     * @hide
+     */
+    public String[] getIsimPcscf(int subId) {
+        try {
+            // MTK TODO
+            // return getSubscriberInfo().getIsimPcscfForSubscriber(subId);
+            return getSubscriberInfo().getIsimPcscf();
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+    }
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the ISIM.
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimGbabp() {
+        return getIsimGbabp(SubscriptionManager.getDefaultSubId());
+    }
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the ISIM.
+     * @param subId subscription ID to be queried
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     * @hide
+     */
+    public String getIsimGbabp(int subId) {
+        // MTK TODO
+        /*
+        try {
+            return getSubscriberInfo().getIsimGbabpForSubscriber(subId);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+        */
+        return null;
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the ISIM.
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     * @hide
+     */
+    public void setIsimGbabp(String gbabp, Message onComplete) {
+        setIsimGbabp(SubscriptionManager.getDefaultSubId(), gbabp, onComplete);
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the ISIM.
+     * @param subId subscription ID to be queried
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     * @hide
+     */
+    public void setIsimGbabp(int subId, String gbabp, Message onComplete) {
+        // MTK TODO
+        /*
+        try {
+            getSubscriberInfo().setIsimGbabpForSubscriber(subId, gbabp, onComplete);
+        } catch (RemoteException ex) {
+            return;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return;
+        }
+        */
+    }
+
+    /**
+     * Returns the USIM Service Table (UST) that was loaded from the USIM.
+     * @param service service index on UST
+     * @return the indicated service is supported or not
+     * @hide
+     */
+    public boolean getUsimService(int service) {
+        return getUsimService(SubscriptionManager.getDefaultSubId(), service);
+    }
+
+    /**
+     * Returns the USIM Service Table (UST) that was loaded from the USIM.
+     * @param subId subscription ID to be queried
+     * @param service service index on UST
+     * @return the indicated service is supported or not
+     * @hide
+     */
+    public boolean getUsimService(int subId, int service) {
+        // MTK TODO
+        /*
+        try {
+            return getSubscriberInfo().getUsimServiceForSubscriber(subId, service);
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return false;
+        }
+        */
+        return false;
+    }
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the USIM.
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     * @hide
+     */
+    public String getUsimGbabp() {
+        return getUsimGbabp(SubscriptionManager.getDefaultSubId());
+    }
+
+    /**
+     * Returns the GBA bootstrapping parameters (GBABP) that was loaded from the USIM.
+     * @param subId subscription ID to be queried
+     * @return GBA bootstrapping parameters or null if not present or not loaded
+     * @hide
+     */
+    public String getUsimGbabp(int subId) {
+        // MTK TODO
+        /*
+        try {
+            return getSubscriberInfo().getUsimGbabpForSubscriber(subId);
+        } catch (RemoteException ex) {
+            return null;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return null;
+        }
+        */
+        return null;
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the USIM.
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     * @hide
+     */
+    public void setUsimGbabp(String gbabp, Message onComplete) {
+        setUsimGbabp(SubscriptionManager.getDefaultSubId(), gbabp, onComplete);
+    }
+
+    /**
+     * Set the GBA bootstrapping parameters (GBABP) value into the USIM.
+     * @param subId subscription ID to be queried
+     * @param gbabp a GBA bootstrapping parameters value in String type
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     * @hide
+     */
+    public void setUsimGbabp(int subId, String gbabp, Message onComplete) {
+        // MTK TODO
+        /*
+        try {
+            getSubscriberInfo().setUsimGbabpForSubscriber(subId, gbabp, onComplete);
+        } catch (RemoteException ex) {
+            return;
+        } catch (NullPointerException ex) {
+            // This could happen before phone restarts due to crashing
+            return;
+        }
+        */
+    }
+
+    /**
+     * Get subscriber Id of LTE phone.
+     * @param subId the subId of CDMAPhone
+     * @return The subscriber Id of LTE phone.
+     *
+     * @hide
+     */
+    public String getSubscriberIdForLteDcPhone(int subId) {
+        try {
+            return getITelephonyEx().getSubscriberIdForLteDcPhone(subId);
+        } catch (RemoteException e1) {
+            e1.printStackTrace();
+            return null;
+        } catch (NullPointerException e2) {
+            e2.printStackTrace();
+            return null;
+        }
+    }
+
+    /// M: [C2K][SVLTE] Define SVLTE RAT mode. @{
+    /**
+     * For C2K SVLTE RAT controll, LTE preferred mode.
+     * @hide
+     */
+    public static final int SVLTE_RAT_MODE_4G = 0;
+
+    /**
+     * For C2K SVLTE RAT controll, EVDO preferred mode, will disable LTE.
+     * @hide
+     */
+    public static final int SVLTE_RAT_MODE_3G = 1;
+
+    /**
+     * For C2K SVLTE RAT controll, LTE Data only mode, will disable CDMA and only allow LTE PS.
+     * @hide
+     */
+    public static final int SVLTE_RAT_MODE_4G_DATA_ONLY = 2;
+    /// @}
+
+    /**
+     * It used to get whether the device is in dual standby dual connection.
+     * For example, call application will be able to support dual connection
+     * if the device mode is in DSDA.
+     *
+     * @return true if the device is in DSDA mode, false for others
+     * @hide
+     */
+    public boolean isInDsdaMode() {
+        if (SystemProperties.get("ro.mtk_switch_antenna", "0").equals("1")) {
+            return false;
+        }
+        String mSimConfig =
+                SystemProperties.get(TelephonyProperties.PROPERTY_MULTI_SIM_CONFIG);
+        String svlteMode =
+                SystemProperties.get(TelephonyProperties.PROPERTY_RADIO_SVLTE_MODE);
+
+        if (mSimConfig.equals("dsda")) {
+            if (!CdmaFeatureOptionUtils.isCdmaLteDcSupport() ||
+                    (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && svlteMode.equals("svlte"))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * @return true if a ICC card is present for a subscription
+     *
+     */
+    /** {@hide} */
+    public boolean isAllowAirplaneModeChange() {
+        try {
+            return getITelephonyEx().isAllowAirplaneModeChange();
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Get whether allow the airplane mode change.
+     *
+     * @return true if allow the airplane mode change.
+     * @hide
+     */
+    public boolean isAirplanemodeAvailableNow() {
+        try {
+            return getITelephonyEx().isAirplanemodeAvailableNow();
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Get cdma rat mode key for the different load.
+     *
+     * @param subId The subId to get cdma rat mode.
+     * @return the rat mode key of the specific subId.
+     * @hide
+     */
+    public String getCdmaRatModeKey(int subId) {
+        // MTK TODO
+        /*
+        if (("OP09").equals(SystemProperties.get("ro.operator.optr", "OM"))) {
+            return Settings.Global.LTE_ON_CDMA_RAT_MODE;
+        } else {
+            return Settings.Global.LTE_ON_CDMA_RAT_MODE + subId;
+        }
+        */
+        return null;
+    }
+
+    /**
+     * Return the sim card if in home network.
+     *
+     * @param subId subscription ID to be queried.
+     * @return true if in home network.
+     * @hide
+     */
+    public boolean isInHomeNetwork(int subId) {
+        try {
+            return getITelephonyEx().isInHomeNetwork(subId);
+        } catch (RemoteException ex) {
+            return false;
+        } catch (NullPointerException ex) {
+            return false;
+        }
+    }
+}
