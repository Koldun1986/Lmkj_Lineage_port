From f34108b5bcb45ad4ce1a2084cd2230157273e6b7 Mon Sep 17 00:00:00 2001
From: vgdn1942 <vgdn1942@gmail.com>
Date: Thu, 14 Dec 2017 23:15:44 +0300
Subject: [PATCH] mtk: add org.gsma.joyn package

Change-Id: I7cbca28368335161624dfc81dd4c889cf86f87c6
---
 Android.mk                                         |  48 ++
 src/java/org/gsma/joyn/Build.java                  |  79 ++
 src/java/org/gsma/joyn/H264Config.java             | 148 ++++
 src/java/org/gsma/joyn/ICoreServiceWrapper.aidl    |  73 ++
 .../joyn/IJoynServiceRegistrationListener.aidl     |  10 +
 src/java/org/gsma/joyn/Intents.java                | 143 ++++
 .../org/gsma/joyn/JoynContactFormatException.java  |  40 +
 src/java/org/gsma/joyn/JoynService.java            | 245 ++++++
 .../org/gsma/joyn/JoynServiceConfiguration.java    | 684 +++++++++++++++++
 src/java/org/gsma/joyn/JoynServiceException.java   |  36 +
 src/java/org/gsma/joyn/JoynServiceListener.java    |  41 +
 .../joyn/JoynServiceNotAvailableException.java     |  34 +
 .../joyn/JoynServiceNotRegisteredException.java    |  34 +
 .../gsma/joyn/JoynServiceRegistrationListener.java |  36 +
 src/java/org/gsma/joyn/JoynUtils.java              |  86 +++
 src/java/org/gsma/joyn/Logger.java                 | 209 +++++
 src/java/org/gsma/joyn/Permissions.java            | 133 ++++
 .../org/gsma/joyn/capability/Capabilities.aidl     |   6 +
 .../org/gsma/joyn/capability/Capabilities.java     | 405 ++++++++++
 .../gsma/joyn/capability/CapabilitiesListener.java |  34 +
 .../org/gsma/joyn/capability/CapabilitiesLog.java  | 109 +++
 .../gsma/joyn/capability/CapabilityService.java    | 452 +++++++++++
 .../joyn/capability/ICapabilitiesListener.aidl     |  10 +
 .../gsma/joyn/capability/ICapabilityService.aidl   |  34 +
 .../org/gsma/joyn/capability/package-info.java     |  20 +
 src/java/org/gsma/joyn/chat/Chat.java              | 482 ++++++++++++
 src/java/org/gsma/joyn/chat/ChatIntent.java        |  71 ++
 src/java/org/gsma/joyn/chat/ChatListener.java      | 111 +++
 src/java/org/gsma/joyn/chat/ChatLog.java           | 702 +++++++++++++++++
 src/java/org/gsma/joyn/chat/ChatMessage.aidl       |   6 +
 src/java/org/gsma/joyn/chat/ChatMessage.java       | 275 +++++++
 src/java/org/gsma/joyn/chat/ChatService.java       | 843 +++++++++++++++++++++
 .../gsma/joyn/chat/ChatServiceConfiguration.aidl   |   6 +
 .../gsma/joyn/chat/ChatServiceConfiguration.java   | 357 +++++++++
 .../org/gsma/joyn/chat/ConferenceEventData.aidl    |   6 +
 .../org/gsma/joyn/chat/ConferenceEventData.java    | 352 +++++++++
 .../chat/ConferenceEventData/ConferenceUser.aidl   |   6 +
 src/java/org/gsma/joyn/chat/Geoloc.aidl            |   6 +
 src/java/org/gsma/joyn/chat/Geoloc.java            | 239 ++++++
 src/java/org/gsma/joyn/chat/GeolocMessage.aidl     |   6 +
 src/java/org/gsma/joyn/chat/GeolocMessage.java     | 123 +++
 src/java/org/gsma/joyn/chat/GroupChat.java         | 696 +++++++++++++++++
 src/java/org/gsma/joyn/chat/GroupChatIntent.java   |  74 ++
 src/java/org/gsma/joyn/chat/GroupChatListener.java | 301 ++++++++
 .../gsma/joyn/chat/GroupChatSyncingListener.java   |  21 +
 src/java/org/gsma/joyn/chat/IChat.aidl             |  60 ++
 src/java/org/gsma/joyn/chat/IChatListener.aidl     |  30 +
 src/java/org/gsma/joyn/chat/IChatService.aidl      |  73 ++
 src/java/org/gsma/joyn/chat/IGroupChat.aidl        |  72 ++
 .../org/gsma/joyn/chat/IGroupChatListener.aidl     |  76 ++
 .../gsma/joyn/chat/IGroupChatSyncingListener.aidl  |  12 +
 src/java/org/gsma/joyn/chat/INewChatListener.aidl  |  12 +
 .../org/gsma/joyn/chat/IPublicAccountChat.aidl     |  11 +
 .../org/gsma/joyn/chat/ISpamReportListener.aidl    |  10 +
 src/java/org/gsma/joyn/chat/NewChatListener.java   |  51 ++
 src/java/org/gsma/joyn/chat/PublicAccountChat.java |  50 ++
 .../org/gsma/joyn/chat/SpamReportListener.java     |  44 ++
 src/java/org/gsma/joyn/chat/package-info.java      |   5 +
 .../org/gsma/joyn/contacts/ContactsProvider.java   |  75 ++
 .../org/gsma/joyn/contacts/ContactsService.java    | 447 +++++++++++
 .../org/gsma/joyn/contacts/IContactsService.aidl   |  37 +
 src/java/org/gsma/joyn/contacts/JoynContact.aidl   |   6 +
 src/java/org/gsma/joyn/contacts/JoynContact.java   | 153 ++++
 src/java/org/gsma/joyn/contacts/package-info.java  |   5 +
 .../org/gsma/joyn/ft/FileSpamReportListener.java   |  44 ++
 src/java/org/gsma/joyn/ft/FileTransfer.java        | 393 ++++++++++
 src/java/org/gsma/joyn/ft/FileTransferIntent.java  |  98 +++
 .../org/gsma/joyn/ft/FileTransferListener.java     |  74 ++
 src/java/org/gsma/joyn/ft/FileTransferLog.java     | 150 ++++
 src/java/org/gsma/joyn/ft/FileTransferService.java | 739 ++++++++++++++++++
 .../joyn/ft/FileTransferServiceConfiguration.aidl  |   6 +
 .../joyn/ft/FileTransferServiceConfiguration.java  | 197 +++++
 .../org/gsma/joyn/ft/IFileSpamReportListener.aidl  |  10 +
 src/java/org/gsma/joyn/ft/IFileTransfer.aidl       |  43 ++
 .../org/gsma/joyn/ft/IFileTransferListener.aidl    |  20 +
 .../org/gsma/joyn/ft/IFileTransferService.aidl     |  64 ++
 .../org/gsma/joyn/ft/INewFileTransferListener.aidl |  24 +
 .../org/gsma/joyn/ft/MultiFileTransferLog.java     | 134 ++++
 .../org/gsma/joyn/ft/NewFileTransferListener.java  |  97 +++
 src/java/org/gsma/joyn/ft/package-info.java        |   5 +
 src/java/org/gsma/joyn/gsh/GeolocSharing.java      | 272 +++++++
 .../org/gsma/joyn/gsh/GeolocSharingIntent.java     |  53 ++
 .../org/gsma/joyn/gsh/GeolocSharingListener.java   |  60 ++
 .../org/gsma/joyn/gsh/GeolocSharingService.java    | 286 +++++++
 src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl     |  30 +
 .../org/gsma/joyn/gsh/IGeolocSharingListener.aidl  |  18 +
 .../org/gsma/joyn/gsh/IGeolocSharingService.aidl   |  30 +
 .../gsma/joyn/gsh/INewGeolocSharingListener.aidl   |   8 +
 .../gsma/joyn/gsh/NewGeolocSharingListener.java    |  33 +
 src/java/org/gsma/joyn/gsh/package-info.java       |   6 +
 src/java/org/gsma/joyn/ipcall/AudioCodec.aidl      |   6 +
 src/java/org/gsma/joyn/ipcall/AudioCodec.java      | 202 +++++
 src/java/org/gsma/joyn/ipcall/IIPCall.aidl         |  41 +
 src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl |  17 +
 src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl   |  34 +
 .../gsma/joyn/ipcall/IIPCallPlayerListener.aidl    |  16 +
 src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl |  34 +
 .../gsma/joyn/ipcall/IIPCallRendererListener.aidl  |  16 +
 src/java/org/gsma/joyn/ipcall/IIPCallService.aidl  |  36 +
 .../org/gsma/joyn/ipcall/INewIPCallListener.aidl   |   8 +
 src/java/org/gsma/joyn/ipcall/IPCall.java          | 361 +++++++++
 src/java/org/gsma/joyn/ipcall/IPCallIntent.java    |  71 ++
 src/java/org/gsma/joyn/ipcall/IPCallListener.java  |  56 ++
 src/java/org/gsma/joyn/ipcall/IPCallLog.java       |  77 ++
 src/java/org/gsma/joyn/ipcall/IPCallPlayer.java    | 167 ++++
 .../org/gsma/joyn/ipcall/IPCallPlayerListener.java |  53 ++
 src/java/org/gsma/joyn/ipcall/IPCallRenderer.java  | 163 ++++
 .../gsma/joyn/ipcall/IPCallRendererListener.java   |  53 ++
 src/java/org/gsma/joyn/ipcall/IPCallService.java   | 415 ++++++++++
 .../joyn/ipcall/IPCallServiceConfiguration.aidl    |   6 +
 .../joyn/ipcall/IPCallServiceConfiguration.java    | 108 +++
 .../org/gsma/joyn/ipcall/NewIPCallListener.java    |  33 +
 src/java/org/gsma/joyn/ipcall/VideoCodec.aidl      |   6 +
 src/java/org/gsma/joyn/ipcall/VideoCodec.java      | 291 +++++++
 src/java/org/gsma/joyn/ipcall/package-info.java    |   5 +
 src/java/org/gsma/joyn/ish/IImageSharing.aidl      |  33 +
 .../org/gsma/joyn/ish/IImageSharingListener.aidl   |  16 +
 .../org/gsma/joyn/ish/IImageSharingService.aidl    |  34 +
 .../gsma/joyn/ish/INewImageSharingListener.aidl    |   8 +
 src/java/org/gsma/joyn/ish/ImageSharing.java       | 290 +++++++
 src/java/org/gsma/joyn/ish/ImageSharingIntent.java |  71 ++
 .../org/gsma/joyn/ish/ImageSharingListener.java    |  59 ++
 src/java/org/gsma/joyn/ish/ImageSharingLog.java    |  94 +++
 .../org/gsma/joyn/ish/ImageSharingService.java     | 398 ++++++++++
 .../joyn/ish/ImageSharingServiceConfiguration.aidl |   6 +
 .../joyn/ish/ImageSharingServiceConfiguration.java | 121 +++
 .../org/gsma/joyn/ish/NewImageSharingListener.java |  33 +
 src/java/org/gsma/joyn/ish/package-info.java       |   6 +
 src/java/org/gsma/joyn/package-info.java           |  41 +
 .../org/gsma/joyn/session/IMultimediaSession.aidl  |  31 +
 .../joyn/session/IMultimediaSessionListener.aidl   |  16 +
 .../joyn/session/IMultimediaSessionService.aidl    |  28 +
 .../gsma/joyn/session/MultimediaMessageIntent.java |  56 ++
 .../org/gsma/joyn/session/MultimediaSession.java   | 278 +++++++
 .../gsma/joyn/session/MultimediaSessionIntent.java |  56 ++
 .../joyn/session/MultimediaSessionListener.java    |  57 ++
 .../joyn/session/MultimediaSessionService.java     | 250 ++++++
 src/java/org/gsma/joyn/session/package-info.java   |   4 +
 .../gsma/joyn/vsh/INewVideoSharingListener.aidl    |   8 +
 src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl       |  28 +
 .../org/gsma/joyn/vsh/IVideoPlayerListener.aidl    |  16 +
 src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl     |  29 +
 .../org/gsma/joyn/vsh/IVideoRendererListener.aidl  |  17 +
 src/java/org/gsma/joyn/vsh/IVideoSharing.aidl      |  35 +
 .../org/gsma/joyn/vsh/IVideoSharingListener.aidl   |  12 +
 .../org/gsma/joyn/vsh/IVideoSharingService.aidl    |  33 +
 .../org/gsma/joyn/vsh/NewVideoSharingListener.java |  34 +
 src/java/org/gsma/joyn/vsh/VideoCodec.aidl         |   6 +
 src/java/org/gsma/joyn/vsh/VideoCodec.java         | 276 +++++++
 src/java/org/gsma/joyn/vsh/VideoPlayer.java        | 145 ++++
 .../org/gsma/joyn/vsh/VideoPlayerListener.java     |  53 ++
 src/java/org/gsma/joyn/vsh/VideoRenderer.java      | 140 ++++
 .../org/gsma/joyn/vsh/VideoRendererListener.java   |  53 ++
 src/java/org/gsma/joyn/vsh/VideoSharing.java       | 300 ++++++++
 src/java/org/gsma/joyn/vsh/VideoSharingIntent.java |  77 ++
 .../org/gsma/joyn/vsh/VideoSharingListener.java    |  44 ++
 src/java/org/gsma/joyn/vsh/VideoSharingLog.java    |  77 ++
 .../org/gsma/joyn/vsh/VideoSharingService.java     | 397 ++++++++++
 .../joyn/vsh/VideoSharingServiceConfiguration.aidl |   6 +
 .../joyn/vsh/VideoSharingServiceConfiguration.java | 101 +++
 src/java/org/gsma/joyn/vsh/package-info.java       |   6 +
 161 files changed, 18109 insertions(+)
 create mode 100644 src/java/org/gsma/joyn/Build.java
 create mode 100644 src/java/org/gsma/joyn/H264Config.java
 create mode 100644 src/java/org/gsma/joyn/ICoreServiceWrapper.aidl
 create mode 100644 src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl
 create mode 100644 src/java/org/gsma/joyn/Intents.java
 create mode 100644 src/java/org/gsma/joyn/JoynContactFormatException.java
 create mode 100644 src/java/org/gsma/joyn/JoynService.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceException.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceListener.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceNotAvailableException.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceNotRegisteredException.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceRegistrationListener.java
 create mode 100644 src/java/org/gsma/joyn/JoynUtils.java
 create mode 100644 src/java/org/gsma/joyn/Logger.java
 create mode 100644 src/java/org/gsma/joyn/Permissions.java
 create mode 100644 src/java/org/gsma/joyn/capability/Capabilities.aidl
 create mode 100644 src/java/org/gsma/joyn/capability/Capabilities.java
 create mode 100644 src/java/org/gsma/joyn/capability/CapabilitiesListener.java
 create mode 100644 src/java/org/gsma/joyn/capability/CapabilitiesLog.java
 create mode 100644 src/java/org/gsma/joyn/capability/CapabilityService.java
 create mode 100644 src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl
 create mode 100644 src/java/org/gsma/joyn/capability/ICapabilityService.aidl
 create mode 100644 src/java/org/gsma/joyn/capability/package-info.java
 create mode 100644 src/java/org/gsma/joyn/chat/Chat.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatIntent.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatLog.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatMessage.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/ChatMessage.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatService.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/ChatServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/chat/ConferenceEventData.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/ConferenceEventData.java
 create mode 100644 src/java/org/gsma/joyn/chat/ConferenceEventData/ConferenceUser.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/Geoloc.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/Geoloc.java
 create mode 100644 src/java/org/gsma/joyn/chat/GeolocMessage.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/GeolocMessage.java
 create mode 100644 src/java/org/gsma/joyn/chat/GroupChat.java
 create mode 100644 src/java/org/gsma/joyn/chat/GroupChatIntent.java
 create mode 100644 src/java/org/gsma/joyn/chat/GroupChatListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/GroupChatSyncingListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/IChat.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IChatListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IChatService.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IGroupChat.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IGroupChatListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/INewChatListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IPublicAccountChat.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/ISpamReportListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/NewChatListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/PublicAccountChat.java
 create mode 100644 src/java/org/gsma/joyn/chat/SpamReportListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/package-info.java
 create mode 100644 src/java/org/gsma/joyn/contacts/ContactsProvider.java
 create mode 100644 src/java/org/gsma/joyn/contacts/ContactsService.java
 create mode 100644 src/java/org/gsma/joyn/contacts/IContactsService.aidl
 create mode 100644 src/java/org/gsma/joyn/contacts/JoynContact.aidl
 create mode 100644 src/java/org/gsma/joyn/contacts/JoynContact.java
 create mode 100644 src/java/org/gsma/joyn/contacts/package-info.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileSpamReportListener.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransfer.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferIntent.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferListener.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferLog.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferService.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/IFileTransfer.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/IFileTransferListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/IFileTransferService.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/MultiFileTransferLog.java
 create mode 100644 src/java/org/gsma/joyn/ft/NewFileTransferListener.java
 create mode 100644 src/java/org/gsma/joyn/ft/package-info.java
 create mode 100644 src/java/org/gsma/joyn/gsh/GeolocSharing.java
 create mode 100644 src/java/org/gsma/joyn/gsh/GeolocSharingIntent.java
 create mode 100644 src/java/org/gsma/joyn/gsh/GeolocSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/gsh/GeolocSharingService.java
 create mode 100644 src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl
 create mode 100644 src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl
 create mode 100644 src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/gsh/NewGeolocSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/gsh/package-info.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/AudioCodec.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/AudioCodec.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCall.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallService.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCall.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallIntent.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallListener.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallLog.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallPlayer.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallPlayerListener.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallRenderer.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallRendererListener.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallService.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/NewIPCallListener.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/VideoCodec.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/VideoCodec.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/package-info.java
 create mode 100644 src/java/org/gsma/joyn/ish/IImageSharing.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/IImageSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/IImageSharingService.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharing.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingIntent.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingLog.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingService.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/ish/NewImageSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/ish/package-info.java
 create mode 100644 src/java/org/gsma/joyn/package-info.java
 create mode 100644 src/java/org/gsma/joyn/session/IMultimediaSession.aidl
 create mode 100644 src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl
 create mode 100644 src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaMessageIntent.java
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaSession.java
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaSessionIntent.java
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaSessionListener.java
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaSessionService.java
 create mode 100644 src/java/org/gsma/joyn/session/package-info.java
 create mode 100644 src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoSharing.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/NewVideoSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoCodec.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoCodec.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoPlayer.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoPlayerListener.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoRenderer.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoRendererListener.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharing.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingIntent.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingLog.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingService.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/vsh/package-info.java

diff --git a/Android.mk b/Android.mk
index 2242958..9a56eb2 100644
--- a/Android.mk
+++ b/Android.mk
@@ -20,6 +20,54 @@ LOCAL_AIDL_INCLUDES := $(LOCAL_PATH)/src/java
 LOCAL_SRC_FILES := \
     $(call all-java-files-under, src/java)
 
+# MTK
+LOCAL_SRC_FILES += \
+    src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl\
+    src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl\
+    src/java/org/gsma/joyn/capability/ICapabilityService.aidl\
+    src/java/org/gsma/joyn/chat/IChat.aidl\
+    src/java/org/gsma/joyn/chat/IChatListener.aidl\
+    src/java/org/gsma/joyn/chat/IChatService.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChatListener.aidl\
+    src/java/org/gsma/joyn/chat/INewChatListener.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChat.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl\
+    src/java/org/gsma/joyn/chat/ISpamReportListener.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl\
+    src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCall.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallService.aidl\
+    src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharing.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharingListener.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharingService.aidl\
+    src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharing.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSession.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransfer.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransferService.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransferListener.aidl\
+    src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl\
+    src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl\
+    src/java/org/gsma/joyn/contacts/IContactsService.aidl\
+    src/java/org/gsma/joyn/ICoreServiceWrapper.aidl \
+
 #LOCAL_JAVA_LIBRARIES := telephony-common
 
 LOCAL_MODULE_TAGS := optional
diff --git a/src/java/org/gsma/joyn/Build.java b/src/java/org/gsma/joyn/Build.java
new file mode 100644
index 0000000..d16b065
--- /dev/null
+++ b/src/java/org/gsma/joyn/Build.java
@@ -0,0 +1,79 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+
+
+/**
+ * This class offers information related to the build version of the API
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Build {
+    /**
+     * List of version codes
+     */
+    public static class VERSION_CODES {
+        /**
+         * The original first version of joyn API
+         */
+        public final static int BASE = 1;
+
+    }
+
+    /**
+     * List of GSMA codes
+     */
+    public static class GSMA_CODES {
+        /**
+         * joyn hotfixes version
+         */
+        public final static int RCSE_HOTFIXES_1_2 = 1;
+        /**
+         * joyn Blackbird version
+         */
+        public final static int RCSE_BLACKBIRD = 2;
+
+    }
+
+    /**
+     * API release implementor name
+     */
+    public static final String API_CODENAME = "GSMA";
+
+    /**
+     * API version number
+     *
+     * @see Build.GSMA_CODES
+     */
+    public final static int GSMA_VERSION = GSMA_CODES.RCSE_BLACKBIRD;
+
+    /**
+     * GSMA version number from class Build.VERSION_CODES
+     */
+    public static final int API_VERSION = VERSION_CODES.BASE;
+
+    /**
+     * Internal number used by the underlying source control to represent this
+     * build
+     */
+    public static final int API_INCREMENTAL = 0;
+
+    private Build() {
+    }
+}
diff --git a/src/java/org/gsma/joyn/H264Config.java b/src/java/org/gsma/joyn/H264Config.java
new file mode 100644
index 0000000..3bbdf6e
--- /dev/null
+++ b/src/java/org/gsma/joyn/H264Config.java
@@ -0,0 +1,148 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+
+/**
+ * Default H264 Settings
+ *
+ * @author hlxn7157
+ * @author Deutsche Telekom AG
+ */
+public class H264Config {
+
+    /** Constant values */
+    public static final int QCIF_WIDTH = 176;
+    public static final int QCIF_HEIGHT = 144;
+
+    public static final int CIF_WIDTH = 352;
+    public static final int CIF_HEIGHT = 288;
+
+    public static final int QVGA_WIDTH = 320;
+    public static final int QVGA_HEIGHT = 240;
+
+    public static final int VGA_WIDTH = 640;
+    public static final int VGA_HEIGHT = 480;
+
+    /**
+     * Codec name
+     */
+    public final static String CODEC_NAME = "H264";
+
+    /**
+     * Default clock rate
+     */
+    public final static int CLOCK_RATE = 90000;
+
+    /**
+     * H264 OPTIONAL payload format parameter "profile-level-id" - RFC 3984
+     */
+    public static final String CODEC_PARAM_PROFILEID = "profile-level-id";
+
+    /**
+     * H264 OPTIONAL payload format parameter "packetization-mode" - RFC 3984
+     */
+    public static final String CODEC_PARAM_PACKETIZATIONMODE = "packetization-mode";
+
+    /**
+     * H264 OPTIONAL payload format parameter "sprop-parameter-sets" - RFC 3984
+     */
+    public static final String CODEC_PARAM_SPROP_PARAMETER_SETS = "sprop-parameter-sets";
+
+    /**
+     * Default codec params
+     */
+    public final static String CODEC_PARAMS = "profile-level-id=42900b;packetization-mode=1";
+
+    /**
+     * Default video width
+     */
+    public final static int VIDEO_WIDTH = QCIF_WIDTH;
+
+    /**
+     * Default video height
+     */
+    public final static int VIDEO_HEIGHT = QCIF_HEIGHT;
+
+    /**
+     * Default video frame rate
+     */
+    public final static int FRAME_RATE = 15;
+
+    /**
+     * Default video bit rate
+     */
+    public final static int BIT_RATE = 64000;
+
+    /**
+     * Get value of packetization mode
+     *
+     * @param codecParams
+     * @return
+     */
+    public static int getCodecPacketizationMode(String codecParams) {
+        int packetization_mode = 0;
+        String valPackMode = getParameterValue(CODEC_PARAM_PACKETIZATIONMODE, codecParams);
+        if (valPackMode != null) {
+            try {
+                packetization_mode = Integer.parseInt(valPackMode);
+            } catch (Exception e) {
+            }
+        }
+        return packetization_mode;
+    }
+
+    /**
+     * Get value of profile level ID
+     *
+     * @param codecParams
+     * @return
+     */
+    public static String getCodecProfileLevelId(String codecParams) {
+        return getParameterValue(CODEC_PARAM_PROFILEID, codecParams);
+    }
+
+    /**
+     * Get parameter value from SDP parameters string with parameter-value
+     * format 'key1=value1; ... keyN=valueN'
+     *
+     * @param paramKey parameter name
+     * @param params parameters string
+     * @return if parameter exists return {@link String} with value, otherwise
+     *         return <code>null</code>
+     */
+    private static String getParameterValue(String paramKey, String params) {
+        String value = null;
+        if (params != null && params.length() > 0) {
+            try {
+                Pattern p = Pattern.compile("(?<=" + paramKey + "=).*?(?=;|$)");
+                Matcher m = p.matcher(params);
+                if (m.find()) {
+                    value = m.group(0);
+                }
+            } catch (PatternSyntaxException e) {
+                // Nothing to do
+            }
+        }
+        return value;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ICoreServiceWrapper.aidl b/src/java/org/gsma/joyn/ICoreServiceWrapper.aidl
new file mode 100644
index 0000000..c5032e0
--- /dev/null
+++ b/src/java/org/gsma/joyn/ICoreServiceWrapper.aidl
@@ -0,0 +1,73 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2011. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package org.gsma.joyn;
+
+
+/**
+ * This interface will handle remote calling about Registration status.
+  */
+interface ICoreServiceWrapper {
+    /**
+     * Get Window Binder. 
+     */
+	IBinder getChatServiceBinder();
+	
+	 /**
+     * Get Window Binder. 
+     */
+	IBinder getFileTransferServiceBinder();
+	
+	 /**
+     * Get Window Binder. 
+     */
+	IBinder getCapabilitiesServiceBinder();
+	
+	 /**
+     * Get Window Binder. 
+     */
+	IBinder getContactsServiceBinder();
+	
+	IBinder getGeolocServiceBinder();
+	
+	IBinder getVideoSharingServiceBinder();
+	
+	IBinder getImageSharingServiceBinder();
+	
+	IBinder getIPCallServiceBinder();
+	
+	IBinder getMultimediaSessionServiceBinder();
+	
+	IBinder getNetworkConnectivityApiBinder();
+}
diff --git a/src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl b/src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl
new file mode 100644
index 0000000..61763f9
--- /dev/null
+++ b/src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl
@@ -0,0 +1,10 @@
+package org.gsma.joyn;
+
+/**
+ * Joyn service registration events listener
+ */
+interface IJoynServiceRegistrationListener {
+	void onServiceRegistered();
+	
+	void onServiceUnregistered();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/Intents.java b/src/java/org/gsma/joyn/Intents.java
new file mode 100644
index 0000000..0e784b9
--- /dev/null
+++ b/src/java/org/gsma/joyn/Intents.java
@@ -0,0 +1,143 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Intents related to joyn service activities
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Intents {
+    /**
+     * Intents for joyn client
+     */
+    public static class Client {
+        /**
+         * Intent to load the settings activity to enable or disable the client
+         */
+        public static final String ACTION_VIEW_SETTINGS = "org.gsma.joyn.action.VIEW_SETTINGS";
+
+        /**
+         * Intent to request the client status. The result is received via an Intent
+         * having the following extras:
+         * <ul>
+         * <li> {@link #EXTRA_CLIENT} containing the client package name.
+         * <li> {@link #EXTRA_STATUS} containing the boolean status of the client. True
+         *  means that the client is activated, else the client is not activated.
+         */
+        public static final String ACTION_CLIENT_GET_STATUS = ".client.action.GET_STATUS";
+
+        /**
+         * Client package name
+         */
+        public final static String EXTRA_CLIENT = "client";
+
+        /**
+         * Client status
+         */
+        public final static String EXTRA_STATUS = "status";
+
+        public final static String SERVICE_UP = "org.gsma.joyn.action.SERVICE_UP";
+
+        private Client() {
+        }
+    }
+
+    /**
+     * Intents for chat service
+     */
+    public static class Chat {
+        /**
+         * Load the chat application to view a chat conversation. This
+         * Intent takes into parameter an URI on the chat conversation
+         * (i.e. content://chats/chat_ID). If no parameter found the main
+         * entry of the chat application is displayed.
+         */
+        public static final String ACTION_VIEW_CHAT = "org.gsma.joyn.action.VIEW_CHAT";
+
+        /**
+         * Load the chat application to start a new conversation with a
+         * given contact. This Intent takes into parameter a contact URI
+         * (i.e. content://contacts/people/contact_ID). If no parameter the
+         * main entry of the chat application is displayed.
+         */
+        public static final String ACTION_INITIATE_CHAT = "org.gsma.joyn.action.INITIATE_CHAT";
+
+        /**
+         * Load the group chat application. This Intent takes into parameter an
+         * URI on the group chat conversation (i.e. content://chats/chat_ID). If
+         * no parameter found the main entry of the group chat application is displayed.
+         */
+        public static final String ACTION_VIEW_GROUP_CHAT = "org.gsma.joyn.action.VIEW_GROUP_CHAT";
+
+        /**
+         * Load the group chat application to start a new conversation with a
+         * group of contacts. This Intent takes into parameter a list of contact
+         * URIs. If no parameter the main entry of the group chat application is displayed.
+         */
+        public static final String ACTION_INITIATE_GROUP_CHAT = "org.gsma.joyn.action.INITIATE_GROUP_CHAT";
+
+        private Chat() {
+        }
+    }
+
+    /**
+     * Intents for file transfer service
+     */
+    public static class FileTransfer {
+        /**
+         * Load the file transfer application to view a file transfer. This Intent
+         * takes into parameter an URI on the file transfer (i.e. content://filetransfers/ft_ID).
+         * If no parameter found the main entry of the file transfer application is displayed.
+         */
+        public static final String ACTION_VIEW_FT = "org.gsma.joyn.action.VIEW_FT";
+
+        /**
+         * Load the file transfer application to start a new file transfer to a given
+         * contact. This Intent takes into parameter a contact URI (i.e. content://contacts/people/contact_ID).
+         * If no parameter the main entry of the file transfer application is displayed.
+         */
+        public static final String ACTION_INITIATE_FT = "org.gsma.joyn.action.INITIATE_FT";
+
+        private FileTransfer() {
+        }
+    }
+
+    /**
+     * Intents for IP call service
+     */
+    public static class IPCall {
+        /**
+         * Load the IP call application to view a call. This Intent takes into parameter an URI on
+         * the call (i.e. content://ipcalls/ipcall_ID). If no parameter found the main entry of the
+         * IP call application is displayed.
+         */
+        public static final String ACTION_VIEW_IPCALL = "org.gsma.joyn.action.VIEW_IPCALL";
+
+        /**
+         * Load the IP call application to start a new call to a given contact. This Intent takes
+         * into parameter a contact URI (i.e. content://contacts/people/contact_ID). If no parameter
+         * the main entry of the IP call application is displayed.
+         */
+        public static final String ACTION_INITIATE_IPCALL = "org.gsma.joyn.action.INITIATE_IPCALL";
+
+        private IPCall() {
+        }
+    }
+}
+
diff --git a/src/java/org/gsma/joyn/JoynContactFormatException.java b/src/java/org/gsma/joyn/JoynContactFormatException.java
new file mode 100644
index 0000000..37d8174
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynContactFormatException.java
@@ -0,0 +1,40 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn contact format exception. This exception is thrown when the
+ * contact format is not supported or not well formatted. The supported
+ * formats are:<br>
+ * - Phone number in national or international format (e.g. +33xxx).<br>
+ * - SIP address (eg. "John" <sip:+33xxx@domain.com>).<br>
+ * - SIP-URI (e.g. sip:+33xxx@domain.com).<br>
+ * - Tel-URI (eg. tel:+33xxx).
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynContactFormatException extends JoynServiceException {
+    static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor
+     */
+    public JoynContactFormatException() {
+        super("joyn contact format not supported");
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynService.java b/src/java/org/gsma/joyn/JoynService.java
new file mode 100644
index 0000000..f6da911
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynService.java
@@ -0,0 +1,245 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+import java.lang.reflect.Method;
+import java.util.List;
+
+
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.os.IInterface;
+
+/**
+ * Abstract joyn service
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class JoynService {
+    /**
+     * Action to broadcast when joyn service is up.
+     */
+    public static final String ACTION_RCS_SERVICE_UP = "org.gsma.joyn.action.RCS_SERVICE_UP";
+
+    public static final String TAG = "TAPI-JoynService";
+
+    /**
+     * Service error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Service has been disabled
+         */
+        public final static int SERVICE_DISABLED = 1;
+
+        /**
+         * Service connection has been lost
+         */
+        public final static int CONNECTION_LOST = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Application context
+     */
+    protected Context ctx;
+
+    /**
+     * Service listener
+     */
+    protected JoynServiceListener serviceListener;
+
+    /**
+     * API interface
+     */
+    private IInterface api = null;
+
+    /**
+     * Service version
+     */
+    protected Integer version = null;
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public JoynService(Context ctx, JoynServiceListener listener) {
+        Logger.d(TAG, "JoynService() constructor " + ctx + " listener = " + listener);
+        this.ctx = ctx;
+        this.serviceListener = listener;
+    }
+
+    /**
+     * Call specific method on the API interface
+     *
+     * @param method Method to be called
+     * @param param Parameters of the method
+     * @param paramClass Class of the parameter passed
+     * @return Object
+     * @throws JoynServiceException
+     */
+    private Object callApiMethod(String method, Object param, Class paramClass) throws JoynServiceException {
+        if (api != null) {
+            Class c = api.getClass();
+            try {
+                if (param != null) {
+                    Method m = c.getDeclaredMethod(method, paramClass);
+                    return m.invoke(api, param);
+                } else {
+                    Method m = c.getDeclaredMethod(method, null);
+                    return m.invoke(api);
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        this.api = api;
+    }
+
+    /**
+     * Connects to the API
+     */
+    public abstract void connect();
+
+    /**
+     * Disconnects from the API
+     */
+    public abstract void disconnect();
+
+    /**
+     * Returns true if the service is connected, else returns false
+     *
+     * @return Returns true if connected else returns false
+     */
+    public boolean isServiceConnected() {
+        return (api != null);
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        Logger.d(TAG, "getServiceVersion() entry " + api);
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = (Integer) callApiMethod("getServiceVersion", null, null);
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        Logger.d(TAG, "isServiceRegistered() entry " + api);
+        if (api != null) {
+            return (Boolean) callApiMethod("isServiceRegistered", null, null);
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.d(TAG, "addServiceRegistrationListener() entry " + api);
+        if (api != null) {
+            callApiMethod("addServiceRegistrationListener", listener, IJoynServiceRegistrationListener.class);
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.d(TAG, "removeServiceRegistrationListener() entry " + api);
+        if (api != null) {
+            callApiMethod("removeServiceRegistrationListener", listener, IJoynServiceRegistrationListener.class);
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    /**
+     * MTK API
+     *
+     * @param Context
+     * @return boolean RcsCore service is started or not
+     */
+    public static boolean isServiceStarted(Context ctx) {
+        ActivityManager activityManager = (ActivityManager) ctx.getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningServiceInfo> serviceList = activityManager.getRunningServices(Integer.MAX_VALUE);
+         for (int i = 0; i < serviceList.size(); i++) {
+               ActivityManager.RunningServiceInfo serviceInfo = serviceList.get(i);
+               ComponentName serviceName = serviceInfo.service;
+               if (serviceName.getClassName().equals("com.orangelabs.rcs.service.RcsCoreService")) {
+                     if (serviceInfo.pid != 0) {
+                          return true;
+                     } else {
+                          return false;
+                     }
+               }
+         }
+         return false;
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceConfiguration.java b/src/java/org/gsma/joyn/JoynServiceConfiguration.java
new file mode 100644
index 0000000..0684045
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceConfiguration.java
@@ -0,0 +1,684 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+//import com.orangelabs.rcs.platform.AndroidFactory;
+
+import org.gsma.joyn.chat.ChatLog;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.net.Uri;
+import android.util.Log;
+
+/**
+ * joyn Service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynServiceConfiguration {
+    /**
+     * Returns True if the joyn service is activated, else returns False. The
+     * service may be activated or deactivated by the end user via the joyn
+     * settings application.
+     *
+     * @param ctx
+     *            Context
+     * @return Boolean
+     */
+    
+    /**
+     * Boolean value "true"
+     */
+    public static final String TRUE = Boolean.toString(true);
+
+    /**
+     * Boolean value "false"
+     */
+    public static final String FALSE = Boolean.toString(false);
+
+    public static boolean isServiceActivated() {
+        /*
+         * if
+         * (AndroidFactory.getApplicationContext().checkCallingOrSelfPermission
+         * (Permissions.READ_RCS_STATE) != PackageManager.PERMISSION_GRANTED) {
+         * throw new SecurityException(" Required permission READ_RCS_STATE"); }
+         */
+        /*
+         * boolean result = false; Uri databaseUri =
+         * Uri.parse("content://com.orangelabs.rcs.settings/settings");
+         * ContentResolver cr =
+         * AndroidFactory.getApplicationContext().getContentResolver(); Cursor c
+         * = cr.query(databaseUri, null, "key" + "='" + "ServiceActivated" +
+         * "'", null, null); if (c != null) { if ((c.getCount() > 0) &&
+         * c.moveToFirst()) { String value = c.getString(2); result =
+         * Boolean.parseBoolean(value); } c.close(); } return result;
+         */
+        return false;
+    }
+
+    /**
+     * Returns True if the joyn service is activated, else returns False. The
+     * service may be activated or deactivated by the end user via the joyn
+     * settings application.
+     *
+     * @param ctx
+     * @return Boolean
+     */
+    public static boolean isServiceActivated(Context ctx) {
+        boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "ServiceActivated" + "'", null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                String value = c.getString(2);
+                result = Boolean.parseBoolean(value);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+    /**
+     * Returns the display name associated to the joyn user account. The display
+     * name may be updated by the end user via the joyn settings application.
+     *
+     * @param ctx
+     *            Context
+     * @return Display name
+     */
+    public static String getUserDisplayName() {
+        // TODO: to be changed
+        /*
+         * String result = null; Uri databaseUri =
+         * Uri.parse("content://com.orangelabs.rcs.settings/settings");
+         * ContentResolver cr =
+         * AndroidFactory.getApplicationContext().getContentResolver(); Cursor c
+         * = cr.query(databaseUri, null, "key" + "='" + "ImsDisplayName" + "'",
+         * null, null); if (c != null) { if ((c.getCount() > 0) &&
+         * c.moveToFirst()) { result = c.getString(2); } c.close(); } return
+         * result;
+         */
+        return null;
+    }
+
+    /**
+     * Get the alias name
+     *
+     * @param contact no
+     * @result alias name for contact
+     */
+    public static String getAliasName(Context ctx, String Contact) {
+         Log.d("getAliasName ", Contact);
+         Uri CONTENT_URI = Uri.parse("content://com.orangelabs.rcs.chat/message");
+         ContentResolver cr = ctx.getContentResolver();
+        String aliasName = "";
+        Cursor cursor = cr.query(CONTENT_URI,
+                new String[] {
+                ChatLog.Message.DISPLAY_NAME,
+                },
+                "(" + ChatLog.Message.CONTACT_NUMBER + "='" + Contact + "' "+
+                "AND " +ChatLog.Message.DISPLAY_NAME + " <> '' "+")",
+                null,
+                ChatLog.GroupChat.TIMESTAMP + " DESC");
+        if (cursor.moveToFirst()) {
+            String status = cursor.getString(0);
+            aliasName = status;
+        }
+        cursor.close();
+        return aliasName;
+    }
+
+    /**
+     * Profile Auth
+     *
+     * @param ctx
+     * @return Boolean
+     */
+    public boolean getProfileAuth(Context ctx) {
+
+     // TODO: to be changed
+        boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "profileAuth"
+                + "'", null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                String value = c.getString(2);
+                result = Boolean.parseBoolean(value);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+
+
+    /**
+     * NAB Authentication
+     *
+     * @param ctx
+     * @return Auth Type
+     */
+    public boolean getNABAuth(Context ctx) {
+        boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "nabAuth" + "'",
+                null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                String value = c.getString(2);
+                result = Boolean.parseBoolean(value);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+    /**
+     * Public Account Auth
+     *
+     * @param ctx
+     * @return Boolean Auth Type
+     */
+     public boolean getPublicAccountAUTH(Context ctx) {
+         boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+         ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "publicAccountAuth" + "'", null, null);
+         if (c != null) {
+             if ((c.getCount() > 0) && c.moveToFirst()) {
+                 String value = c.getString(2);
+                 result = Boolean.parseBoolean(value);
+             }
+             c.close();
+         }
+         return result;
+     }
+
+   /**
+    * SSo Auth
+    *
+     * @param ctx
+     * @return Boolean Auth type
+    */
+    public boolean getSSOAuth(Context ctx) {
+        boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "ssoAuth" + "'",
+                null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                String value = c.getString(2);
+                result = Boolean.parseBoolean(value);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+   /**
+    * Profile Address
+    *
+     * @param ctx
+     * @return String address
+    */
+    public String getProfileAddress(Context ctx) {
+        String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "profileAddress"
+                + "'", null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                result = c.getString(2);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+
+   /**
+    * Profile Port
+    *
+     * @param ctx
+     * @return String port
+    */
+    public String getProfileAddressPort(Context ctx) {
+        String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "profileAddressPort" + "'", null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                result = c.getString(2);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+    /**
+     * Profile Address Type
+     *
+     * @param ctx
+     * @return String Address
+     */
+     public String getProfileAddressType(Context ctx) {
+         String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+         ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "ProfileAddressType" + "'", null, null);
+         if (c != null) {
+             if ((c.getCount() > 0) && c.moveToFirst()) {
+                 result = c.getString(2);
+             }
+             c.close();
+         }
+         return result;
+     }
+
+
+     /**
+      * Profile Address
+      *
+     * @param ctx
+     * @return String address
+      */
+      public String getNABAddress(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "nabAddress"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+
+     /**
+     * NAB Address Port
+      *
+     * @param ctx
+     * @return String port
+      */
+      public String getNABAddressPort(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "nabAddressPort"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+     /**
+     * NAB Address Type
+      *
+     * @param ctx
+     * @return String Address
+      */
+      public String getNABAddressType(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "nabAddressType"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+     /**
+      * Public Address
+      *
+     * @param ctx
+     * @return String address
+      */
+      public String getPublicAccountAddress(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "publicAccountAddress" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+
+     /**
+     * Public Account Port
+      *
+     * @param ctx
+     * @return String port
+      */
+      public String getPublicAccountAddressPort(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "publicAccountAddressPort" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+     /**
+     * Public Account Address Type
+      *
+     * @param ctx
+     * @return String Address
+      */
+      public String getPublicAccountAddressType(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "publicAccountAddressType" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+     /**
+      * SSo Address
+      *
+     * @param ctx
+      * @return address
+      */
+      public String getSSOAddress(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "SSOAddress"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+
+    /**
+     * SSO Port
+     *
+     * @param ctx
+     * @return port
+     */
+      public String getSSOAddressPort(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "SSOAddressPort"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+    /**
+     * Address Type
+     *
+     * @param ctx
+     * @return Address
+     */
+     public String getSSOAddressType(Context ctx) {
+         String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+         ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "SSOAddressType"
+                + "'", null, null);
+         if (c != null) {
+             if ((c.getCount() > 0) && c.moveToFirst()) {
+                 result = c.getString(2);
+             }
+             c.close();
+         }
+         return result;
+     }
+
+    /**
+     * Public Uri set by stack
+     *
+     * @param ctx
+     * @return String
+     */
+     public String getPublicUri(Context ctx) {
+         String result = "";
+         Uri databaseUri = Uri.parse("content://com.orangelabs.rcs.settings/settings");
+         ContentResolver cr = ctx.getContentResolver();
+         Cursor c = cr.query(databaseUri, null,
+                 "key" + "='" + "publicUri" + "'", null, null);
+         if (c != null) {
+             if ((c.getCount() > 0) && c.moveToFirst()) {
+                 result = c.getString(2);
+             }
+             c.close();
+         }
+
+         return result;
+     }
+
+     /**
+      * Configuration
+      * 
+     * @param ctx
+      * @return Configuration State
+      */
+      public boolean getConfigurationState(Context ctx) {
+          boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "configurationState" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  String value = c.getString(2);
+                  result = Boolean.parseBoolean(value);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+
+
+      /**
+       * Service Activation State
+       *
+     * @param ctx
+     * @return String Service State
+       */
+       public static boolean getServiceState(Context ctx) {
+           boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+           ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "ServiceActivated" + "'", null, null);
+           if (c != null) {
+               if ((c.getCount() > 0) && c.moveToFirst()) {
+                   String value = c.getString(2);
+                   result = Boolean.parseBoolean(value);
+               }
+               c.close();
+           }
+           return result;
+       }
+
+       /**
+        * Set the root directory for files
+        *
+        *  @param path Directory path
+        */
+       public void setFileRootDirectory(String path, Context ctx) {
+           Uri databaseUri = Uri
+           .parse("content://com.orangelabs.rcs.settings/settings");
+           if (ctx != null) {
+               ContentResolver cr = ctx.getContentResolver();
+               ContentValues values = new ContentValues();
+               values.put("value", path);
+               String where = "key" + "='" + "DirectoryPathFiles" + "'";
+              // long startTime = System.currentTimeMillis();
+               cr.update(databaseUri, values, where, null);
+           }
+       }
+
+       /** Set the root directory for Photo
+       *
+       *  @param path Directory path
+       */
+      public void setPhotoRootDirectory(String path, Context ctx) {
+          Uri databaseUri = Uri
+          .parse("content://com.orangelabs.rcs.settings/settings");
+          if (ctx != null) {
+              ContentResolver cr = ctx.getContentResolver();
+              ContentValues values = new ContentValues();
+              values.put("value", path);
+              String where = "key" + "='" + "DirectoryPathPhotos" + "'";
+             // long startTime = System.currentTimeMillis();
+              cr.update(databaseUri, values, where, null);
+          }
+      }
+
+      /** Set the root directory for Videos
+       *
+       *  @param path Directory path
+       */
+      public void setVideoRootDirectory(String path, Context ctx) {
+          Uri databaseUri = Uri
+          .parse("content://com.orangelabs.rcs.settings/settings");
+          if (ctx != null) {
+              ContentResolver cr = ctx.getContentResolver();
+              ContentValues values = new ContentValues();
+              values.put("value", path);
+              String where = "key" + "='" + "DirectoryPathVideos" + "'";
+             // long startTime = System.currentTimeMillis();
+              cr.update(databaseUri, values, where, null);
+          }
+      }
+      
+      /** Set the root directory for Photo
+      *
+      *  @param path Directory path
+      */
+      public static void setServicePermissionState(boolean state, Context ctx) {
+          String stringState = "";
+          if(state) {
+              stringState = TRUE;
+          } else {
+              stringState = FALSE;
+          }
+          Uri databaseUri = Uri
+          .parse("content://com.orangelabs.rcs.settings/settings");
+          if (ctx != null) {
+          ContentResolver cr = ctx.getContentResolver();
+          ContentValues values = new ContentValues();
+              values.put("value", stringState);
+              String where = "key" + "='" + "servicePermitted" + "'";
+              // long startTime = System.currentTimeMillis();
+              cr.update(databaseUri, values, where, null);
+          }
+      }
+      
+      /**
+       * Returns True if the App Permission is granted .
+       *
+       * @param ctx
+       * @return Boolean
+       */
+      public static boolean isServicePermission(Context ctx) {
+          boolean result = false;
+          Uri databaseUri = Uri
+                  .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+          Cursor c = cr.query(databaseUri, null, "key" + "='"
+                  + "servicePermitted" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  String value = c.getString(2);
+                  result = Boolean.parseBoolean(value);
+              }
+              c.close();
+          }
+          return result;
+      }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceException.java b/src/java/org/gsma/joyn/JoynServiceException.java
new file mode 100644
index 0000000..6677dd4
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceException.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn service exception
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynServiceException extends java.lang.Exception {
+    static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor
+     *
+     * @param error Error message
+     */
+    public JoynServiceException(String error) {
+        super(error);
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceListener.java b/src/java/org/gsma/joyn/JoynServiceListener.java
new file mode 100644
index 0000000..607aa08
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceListener.java
@@ -0,0 +1,41 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn service event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public interface JoynServiceListener {
+    /**
+     * Callback called when service is connected. This method is called when the
+     * service is well connected to the RCS service (binding procedure successfull):
+     * this means the methods of the API may be used.
+     */
+    public void onServiceConnected();
+
+    /**
+     * Callback called when service has been disconnected. This method is called when
+     * the service is disconnected from the RCS service (e.g. service deactivated).
+     *
+     * @param error Error
+     * @see JoynService.Error
+     */
+    public void onServiceDisconnected(int error);
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceNotAvailableException.java b/src/java/org/gsma/joyn/JoynServiceNotAvailableException.java
new file mode 100644
index 0000000..91599bf
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceNotAvailableException.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn service not available exception
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynServiceNotAvailableException extends JoynServiceException {
+    static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor
+     */
+    public JoynServiceNotAvailableException() {
+        super("joyn service not available");
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceNotRegisteredException.java b/src/java/org/gsma/joyn/JoynServiceNotRegisteredException.java
new file mode 100644
index 0000000..174f876
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceNotRegisteredException.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn service not registered exception
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynServiceNotRegisteredException extends JoynServiceException {
+    static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor
+     */
+    public JoynServiceNotRegisteredException() {
+        super("joyn service not registered");
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceRegistrationListener.java b/src/java/org/gsma/joyn/JoynServiceRegistrationListener.java
new file mode 100644
index 0000000..e668766
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceRegistrationListener.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+
+/**
+ * Service registration events listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class JoynServiceRegistrationListener extends IJoynServiceRegistrationListener.Stub {
+    /**
+     * Callback called when service is registered to the network platform
+     */
+    public abstract void onServiceRegistered();
+
+    /**
+     * Callback called when service is unregistered from the network platform
+     */
+    public abstract void onServiceUnregistered();
+}
diff --git a/src/java/org/gsma/joyn/JoynUtils.java b/src/java/org/gsma/joyn/JoynUtils.java
new file mode 100644
index 0000000..8622125
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynUtils.java
@@ -0,0 +1,86 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+import java.util.List;
+
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+
+/**
+ * Utility functions which permit to detect other joyn client installed on a
+ * device
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynUtils {
+    /**
+     * Returns the list of joyn clients installed on the device. An application
+     * is identified as a joyn client by including an intent filter with the
+     * ACTION_CLIENT_SETTINGS action in the Manifest.xml of the application.
+     *
+     * @param context Application context
+     * @return List of application info
+     */
+
+    public static final String TAG = "TAPI-JoynUtils";
+
+    public static List<ResolveInfo> getJoynClients(Context context) {
+        Logger.d(TAG, "getJoynClients() entry " + context);
+        Intent intent = new Intent(Intents.Client.ACTION_VIEW_SETTINGS);
+        List<ResolveInfo> list = context.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
+        Logger.d(TAG, "getJoynClients() exit " + list);
+        return list;
+    }
+
+    /**
+     * Is a particular joyn client activated. The result is returned
+     * asynchronously via a broadcast receiver.
+     *
+     * @param context Application context
+     * @param appInfo Application info
+     * @param receiverResult Broadcast receiver result
+     */
+    public static void isJoynClientActivated(Context context, ResolveInfo appInfo, BroadcastReceiver receiverResult) {
+        Logger.d(TAG, "isJoynClientActivated() entry " + context);
+        Intent broadcastIntent = new Intent(appInfo.activityInfo.packageName
+                + Intents.Client.ACTION_CLIENT_GET_STATUS);
+        context.sendOrderedBroadcast(broadcastIntent, null, receiverResult, null, Activity.RESULT_OK, null, null);
+    }
+
+    /**
+     * Load the settings activity of a particular joyn client to enable or
+     * disable the client
+     *
+     * @param context Application context
+     * @param appInfo Application info
+     */
+    public static void loadJoynClientSettings(Context context, ResolveInfo appInfo) {
+        Logger.d(TAG, "loadJoynClientSettings() entry " + context);
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.setComponent(new ComponentName(appInfo.activityInfo.packageName, appInfo.activityInfo.name));
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
+        context.startActivity(intent);
+    }
+}
diff --git a/src/java/org/gsma/joyn/Logger.java b/src/java/org/gsma/joyn/Logger.java
new file mode 100644
index 0000000..c644f50
--- /dev/null
+++ b/src/java/org/gsma/joyn/Logger.java
@@ -0,0 +1,209 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2011. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package org.gsma.joyn;
+
+import android.app.Activity;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.util.Log;
+
+
+//This is a common logger for MTK RCS-e solution.
+public final class Logger {
+    public static final String TAG = "[RCSe]";
+
+    private Logger() {
+    }; // Static common use class should not be instantiated.
+
+    private static final boolean XLOG_ENABLED = true;
+    private static boolean sIsLogEnabled = true;
+    // This is used for test codes
+    public static final boolean IS_DEBUG = true;
+    public static final String RCS_PREFS_IS_INTEGRATION_MODE = "IS_INTEGRATION_MODE";
+
+    // This is used for launch mode or integration mode
+    private static boolean sIsIntegrationMode;
+
+    /**
+     * Get sIsIntegrationMode.
+     *
+     * @return sIsIntegrationMode
+     */
+    public static boolean getIsIntegrationMode() {
+        return true;
+        //return sIsIntegrationMode;
+    }
+
+    /**
+     * Set sIsIntegrationMode.
+     *
+     * @param boolean isIntegrationMode.
+     */
+    public static void setIsIntegrationMode(boolean isIntegrationMode) {
+        sIsIntegrationMode = isIntegrationMode;
+    }
+
+    /**
+     * initialize sIsIntegrationMode.
+     *
+     * @param Context context.
+     */
+    public static void initialize(Context context) {
+        if (context != null) {
+            v(TAG, "initialize(), context is not null");
+            SharedPreferences preferences =
+                    context.getSharedPreferences(RCS_PREFS_IS_INTEGRATION_MODE, Activity.MODE_PRIVATE);
+            if (preferences.contains(RCS_PREFS_IS_INTEGRATION_MODE)) {
+                sIsIntegrationMode = preferences.getBoolean(RCS_PREFS_IS_INTEGRATION_MODE, false);
+            } else {
+                sIsIntegrationMode = false;
+                Editor editor = preferences.edit();
+                editor.putBoolean(RCS_PREFS_IS_INTEGRATION_MODE, false);
+                editor.commit();
+            }
+        } else {
+            sIsIntegrationMode = false;
+        }
+        v(TAG, "initialize(), sIsIntegrationMode = " + sIsIntegrationMode);
+    }
+
+    /**
+     * Run-time set whether need to enable the RCS-e log in this process.
+     *
+     * @param isLogEnable Enable/disable the RCS-e log.
+     */
+    public static void setLogEnabled(boolean isLogEnable) {
+        sIsLogEnabled = isLogEnable;
+        sIsLogEnabled = true;
+    }
+
+    /**
+     * Send a verbose log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void v(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.v(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.v(TAG, getCombinedMessage(tag, message));
+            }
+        }
+
+    }
+
+    /**
+     * Send a debug log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void d(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.d(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.d(TAG, getCombinedMessage(tag, message));
+            }
+        }
+    }
+
+    /**
+     * Send an information log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void i(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.i(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.i(TAG, getCombinedMessage(tag, message));
+            }
+        }
+    }
+
+    /**
+     * Send a warning log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void w(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.w(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.w(TAG, getCombinedMessage(tag, message));
+            }
+        }
+    }
+
+    /**
+     * Send a error log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void e(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.e(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.e(TAG, getCombinedMessage(tag, message));
+            }
+        }
+    }
+
+    private static String getCombinedMessage(String tag, String message) {
+        if (null != tag) {
+            StringBuilder builder = new StringBuilder();
+            builder.append("[");
+            builder.append(tag);
+            builder.append("]: ");
+            builder.append(message);
+            return builder.toString();
+        } else {
+            return message;
+        }
+
+    }
+}
diff --git a/src/java/org/gsma/joyn/Permissions.java b/src/java/org/gsma/joyn/Permissions.java
new file mode 100644
index 0000000..df15d55
--- /dev/null
+++ b/src/java/org/gsma/joyn/Permissions.java
@@ -0,0 +1,133 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ *
+ *
+ * @author MTK
+ */
+public class Permissions {
+
+    /**
+     * This is a new permission that governs access to the
+     * chat API, and is required both to receive and to send over an RCS
+     * chat session
+     */
+    public final static String RCS_USE_CHAT = "org.gsma.joyn.RCS_USE_CHAT";
+
+    /**
+     * This is a new permission that that is required by a
+     * client in order to read the chat history from the content provider
+     */
+    public final static String RCS_READ_CHAT = "org.gsma.joyn.RCS_READ_CHAT";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to handle the receipt of a file transferred from a remote
+     * party
+     */
+    public final static String RCS_FILETRANSFER_RECEIVE = "org.gsma.joyn.RCS_FILETRANSFER_RECEIVE";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to initiate the transfer of a file transferred to a remote
+     * party
+     */
+    public final static String RCS_FILETRANSFER_SEND = "org.gsma.joyn.RCS_FILETRANSFER_SEND";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to read the file transfer history from the content provider
+     */
+    public final static String RCS_FILETRANSFER_READ = "org.gsma.joyn.RCS_FILETRANSFER_READ";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to handle the receipt of a image shared by a remote
+     */
+    public final static String RCS_IMAGESHARE_RECEIVE = "org.gsma.joyn.RCS_IMAGESHARE_RECEIVE";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to initiate the sharing of an image with a remote party
+     */
+    public final static String RCS_IMAGESHARE_SEND = "org.gsma.joyn.RCS_IMAGESHARE_SEND";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to read the image share history from the content provider
+     */
+    public final static String RCS_IMAGESHARE_READ = "org.gsma.joyn.RCS_FILETRANSFER_READ";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to receipt of a video shared by a remote party
+     */
+    public final static String RCS_VIDEOSHARE_RECEIVE = "org.gsma.joyn.RCS_VIDEOSHARE_RECEIVE";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to initiate the sharing of an video with a remote party
+     */
+    public final static String RCS_VIDEOSHARE_SEND = "org.gsma.joyn.RCS_VIDEOSHARE_SEND";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to read the video share history from the content provider
+     */
+    public final static String RCS_VIDEOSHARE_READ = "org.gsma.joyn.RCS_VIDEOSHARE_READ";
+
+    /**
+     * This is a new permission this is a new permission that governs
+     * access to capability information
+     */
+    public final static String RCS_READ_CAPABILITIES = "org.gsma.joyn.RCS_READ_CAPABILITIES";
+
+    /**
+     * This is a new permission that governs access to the IP Call API, and is required to initiate,
+     * receive and to manage RCS IP Call sessions.
+     */
+    public final static String RCS_USE_IPCALL = "org.gsma.joyn.RCS_USE_IPCALL";
+
+    /**
+     * This is a new permission that that is required by client in order to read the IP Call
+     * history from the content provider..
+     */
+    public final static String RCS_READ_IPCALL = "org.gsma.joyn.RCS_READ_IPCALL";
+
+    /**
+     * this is a new permission that is required to
+     * send Geolocation data over an RCS chat session
+     */
+    public final static String RCS_LOCATION_SEND = "org.gsma.joyn.RCS_LOCATION_SEND";
+
+    /**
+     * This is a new permission that that is required by client in order to read the using the
+     * capabilities service, since use of the API implicitly reveals information about
+     * past and current contacts for the device.
+     */
+    public final static String ANDROID_READ_CONTACTS = "android.permission.READ_CONTACTS";
+
+    /**
+     * This is a new permission that that is required by client analogous to READ_PHONE_STATE,
+     * covering general access to the RCS stack state.
+     */
+    public final static String READ_RCS_STATE = "org.gsma.joyn.READ_RCS_STATE";
+
+}
diff --git a/src/java/org/gsma/joyn/capability/Capabilities.aidl b/src/java/org/gsma/joyn/capability/Capabilities.aidl
new file mode 100644
index 0000000..df47aa0
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/Capabilities.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.capability;
+
+/**
+ * Capabilities object
+ */
+parcelable Capabilities;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/capability/Capabilities.java b/src/java/org/gsma/joyn/capability/Capabilities.java
new file mode 100644
index 0000000..c1dff37
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/Capabilities.java
@@ -0,0 +1,405 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.capability;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Capabilities of a contact. This class encapsulates the different capabilities
+ * which may be supported by the local user or a remote contact.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Capabilities implements Parcelable {
+    /**
+     * Image sharing support
+     */
+    private boolean imageSharing = false;
+
+    public static final String TAG = "Capabilities";
+
+    public void setImageSharingSupport(boolean imageSharing) {
+        Logger.i(TAG, "setImageSharingSupport entry" + imageSharing);
+        this.imageSharing = imageSharing;
+    }
+
+    /**
+     * Video sharing support
+     */
+    private boolean videoSharing = false;
+
+    public void setVideoSharingSupport(boolean videoSharing) {
+        Logger.i(TAG, "setVideoSharingSupport entry" + videoSharing);
+        this.videoSharing = videoSharing;
+    }
+
+    /**
+     * IM session support
+     */
+    private boolean imSession = false;
+
+    /**
+     * File transfer support
+     */
+    private boolean fileTransfer = false;
+
+    /**
+     * Geolocation push support
+     */
+    private boolean geolocPush = false;
+
+    /**
+     * IP voice call support
+     */
+    private boolean ipVoiceCall = false;
+
+    /**
+     * IP video call support
+     */
+    private boolean ipVideoCall = false;
+
+    /**
+     * List of supported extensions
+     */
+    private Set<String> extensions = new HashSet<String>();
+
+    /**
+     * Automata flag
+     */
+    private boolean automata = false;
+
+    /**
+     * Automata flag
+     */
+    private boolean fileTransferHttpSupported = false;
+
+    /**
+     * Automata flag
+     */
+    private boolean rcsContact = false;
+
+    private boolean burnAfterRead = false;
+
+    /**
+     * Integrated Mode of this contact
+     */
+    private boolean integratedMessagingMode = false;
+
+    public void setIntegratedMessagingMode(boolean integratedMessagingMode) {
+        Logger.i(TAG, "setIntegratedMessagingMode entry" + integratedMessagingMode);
+        this.integratedMessagingMode = integratedMessagingMode;
+    }
+
+    public boolean isIntegratedMessagingMode() {
+        Logger.i(TAG, "isIntegratedMessagingMode entry" + integratedMessagingMode);
+        return integratedMessagingMode;
+    }
+
+    /**
+     * Cs Video support
+     */
+    private boolean csVideoSupported = false;
+
+    public boolean isCsVideoSupported() {
+        return csVideoSupported;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param imageSharing Image sharing support
+     * @param videoSharing Video sharing support
+     * @param imSession IM/Chat support
+     * @param fileTransfer File transfer support
+     * @param geolocPush Geolocation push support
+     * @param ipVoiceCall IP voice call support
+     * @param ipVideoCall IP video call support
+     * @param extensions Set of supported extensions
+     * @param automata Automata flag
+     * @hide
+     */
+    public Capabilities(boolean imageSharing, boolean videoSharing, boolean imSession,
+            boolean fileTransfer, boolean geolocPush,
+            boolean ipVoiceCall, boolean ipVideoCall,
+            Set<String> extensions, boolean automata, boolean fileTransferHttpSupport, boolean rcsContact, boolean integratedMessagingMode, boolean csVideoSupported,
+            boolean isBurnAfterRead
+            ) {
+        Logger.i(TAG, "Capabilities entry , values are " + "Imagesharing-" + imageSharing + "videosharing-" + videoSharing + "imSession-" + imSession +
+                "filetransfer-" + fileTransfer + "geolocPush-" + geolocPush + "ipVoicecall-" + ipVoiceCall + "ipVideoCall-" + ipVideoCall +
+                "extensions-" + extensions + "automata-" + automata + "fileTransferHttpSupport-" + "rcsContact-" + rcsContact +
+                "integratedMessagingMode-" + integratedMessagingMode + "csVideoSupported-" + csVideoSupported);
+        this.imageSharing = imageSharing;
+        this.videoSharing = videoSharing;
+        this.imSession = imSession;
+        this.fileTransfer = fileTransfer;
+        this.geolocPush = geolocPush;
+        this.ipVoiceCall = ipVoiceCall;
+        this.ipVideoCall = ipVideoCall;
+        this.extensions = extensions;
+        this.automata = automata;
+        this.fileTransferHttpSupported = fileTransferHttpSupport;
+        this.rcsContact = rcsContact;
+        this.integratedMessagingMode = integratedMessagingMode;
+        this.csVideoSupported = csVideoSupported;
+        this.burnAfterRead = isBurnAfterRead;
+    }
+
+    public Capabilities(boolean imageSharing, boolean videoSharing, boolean imSession,
+            boolean fileTransfer, boolean geolocPush,
+            boolean ipVoiceCall, boolean ipVideoCall,
+            Set<String> extensions, boolean automata, boolean fileTransferHttpSupport, boolean rcsContact, boolean integratedMessagingMode, boolean csVideoSupported) {
+        Logger.i(TAG, "Capabilities entry , values are " + "Imagesharing-" + imageSharing + "videosharing-" + videoSharing + "imSession-" + imSession +
+                "filetransfer-" + fileTransfer + "geolocPush-" + geolocPush + "ipVoicecall-" + ipVoiceCall + "ipVideoCall-" + ipVideoCall +
+                "extensions-" + extensions + "automata-" + automata + "fileTransferHttpSupport-" + "rcsContact-" + rcsContact +
+                "integratedMessagingMode-" + integratedMessagingMode + "csVideoSupported-" + csVideoSupported);
+        this.imageSharing = imageSharing;
+        this.videoSharing = videoSharing;
+        this.imSession = imSession;
+        this.fileTransfer = fileTransfer;
+        this.geolocPush = geolocPush;
+        this.ipVoiceCall = ipVoiceCall;
+        this.ipVideoCall = ipVideoCall;
+        this.extensions = extensions;
+        this.automata = automata;
+        this.fileTransferHttpSupported = fileTransferHttpSupport;
+        this.rcsContact = rcsContact;
+        this.integratedMessagingMode = integratedMessagingMode;
+        this.csVideoSupported = csVideoSupported;
+
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public Capabilities(Parcel source) {
+        this.imageSharing = source.readInt() != 0;
+        this.videoSharing = source.readInt() != 0;
+        this.imSession = source.readInt() != 0;
+        this.fileTransfer = source.readInt() != 0;
+        List<String> exts = new ArrayList<String>();
+        source.readStringList(exts);
+        this.extensions = new HashSet<String>(exts);
+        this.geolocPush = source.readInt() != 0;
+        this.ipVoiceCall = source.readInt() != 0;
+        this.ipVideoCall = source.readInt() != 0;
+        this.automata = source.readInt() != 0;
+        this.fileTransferHttpSupported = source.readInt() != 0;
+        this.rcsContact = source.readInt() != 0;
+        this.integratedMessagingMode = source.readInt() != 0;
+        this.csVideoSupported = source.readInt() != 0;
+        this.burnAfterRead = source.readInt() != 0;
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(imageSharing ? 1 : 0);
+        dest.writeInt(videoSharing ? 1 : 0);
+        dest.writeInt(imSession ? 1 : 0);
+        dest.writeInt(fileTransfer ? 1 : 0);
+        if (extensions != null) {
+            List<String> exts = new ArrayList<String>();
+            exts.addAll(extensions);
+            dest.writeStringList(exts);
+        }
+        dest.writeInt(geolocPush ? 1 : 0);
+        dest.writeInt(ipVoiceCall ? 1 : 0);
+        dest.writeInt(ipVideoCall ? 1 : 0);
+        dest.writeInt(automata ? 1 : 0);
+        dest.writeInt(fileTransferHttpSupported ? 1 : 0);
+        dest.writeInt(rcsContact ? 1 : 0);
+        dest.writeInt(integratedMessagingMode ? 1 : 0);
+        dest.writeInt(csVideoSupported ? 1 : 0);
+        dest.writeInt(burnAfterRead ? 1 : 0);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<Capabilities> CREATOR
+            = new Parcelable.Creator<Capabilities>() {
+        public Capabilities createFromParcel(Parcel source) {
+            return new Capabilities(source);
+        }
+
+        public Capabilities[] newArray(int size) {
+            return new Capabilities[size];
+        }
+    };
+
+    /**
+     * Is image sharing supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isImageSharingSupported() {
+        Logger.i(TAG, "isImageSharingSupported value " + imageSharing);
+        return imageSharing;
+    }
+
+    /**
+     * Is video sharing supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isVideoSharingSupported() {
+        Logger.i(TAG, "isVideoSharingSupported value " + videoSharing);
+        return videoSharing;
+    }
+
+    /**
+     * Is IM session supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isImSessionSupported() {
+        Logger.i(TAG, "isImSessionSupported value " + imSession);
+        return imSession;
+    }
+
+    /**
+     * Is file transfer supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isFileTransferSupported() {
+        Logger.i(TAG, "isFileTransferSupported value " + fileTransfer);
+        return fileTransfer;
+    }
+
+
+    /**
+     * Is geolocation push supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isGeolocPushSupported() {
+        Logger.i(TAG, "isGeolocPushSupported value " + geolocPush);
+        return geolocPush;
+    }
+
+    /**
+     * Is IP voice call supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isIPVoiceCallSupported() {
+        Logger.i(TAG, "isIPVoiceCallSupported value " + ipVoiceCall);
+        return ipVoiceCall;
+    }
+
+    /**
+     * Is IP video call supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isIPVideoCallSupported() {
+        Logger.i(TAG, "isIPVideoCallSupported value " + ipVideoCall);
+        return ipVideoCall;
+    }
+
+    /**
+     * Is extension supported
+     *
+     * @param tag Feature tag
+     * @return Returns true if supported else returns false
+     */
+    public boolean isExtensionSupported(String tag) {
+        Logger.i(TAG, "isExtensionSupported value " + extensions.contains(tag));
+        return extensions.contains(tag);
+    }
+
+    /**
+     * Get list of supported extensions
+     *
+     * @return List of feature tags
+     */
+    public Set<String> getSupportedExtensions() {
+        Logger.i(TAG, "getSupportedExtensions value " + extensions);
+        return extensions;
+    }
+
+    /**
+     * Is automata
+     *
+     * @return Returns true if it's an automata else returns false
+     */
+    public boolean isAutomata() {
+        Logger.i(TAG, "isAutomata value" + automata);
+        return automata;
+    }
+
+    /**
+     * If FT HTTP Supported
+     *
+     * @return Returns true if it's supported
+     */
+    public boolean isFileTransferHttpSupported() {
+        Logger.i(TAG, "isFileTransferHttpSupported value" + fileTransferHttpSupported);
+        return fileTransferHttpSupported;
+    }
+
+    /**
+     * Is contact RCSe supported
+     *
+     * @return Returns true if it's rcs contact
+     */
+    public boolean isSupportedRcseContact() {
+        Logger.i(TAG, "isSupportedRcseContact value" + rcsContact);
+        return rcsContact;
+    }
+
+    /**
+     * BURN AFTER READING
+     *
+     */
+
+    public boolean isBurnAfterRead() {
+        return burnAfterRead;
+    }
+}
diff --git a/src/java/org/gsma/joyn/capability/CapabilitiesListener.java b/src/java/org/gsma/joyn/capability/CapabilitiesListener.java
new file mode 100644
index 0000000..5135caf
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/CapabilitiesListener.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.capability;
+
+
+/**
+ * New capabilities event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class CapabilitiesListener extends ICapabilitiesListener.Stub {
+    /**
+     * Callback called when new capabilities are received for a given contact
+     *
+     * @param contact Contact
+     * @param capabilities Received capabilities
+     */
+    public abstract void onCapabilitiesReceived(String contact, Capabilities capabilities);
+}
diff --git a/src/java/org/gsma/joyn/capability/CapabilitiesLog.java b/src/java/org/gsma/joyn/capability/CapabilitiesLog.java
new file mode 100644
index 0000000..cb4d8a8
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/CapabilitiesLog.java
@@ -0,0 +1,109 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.capability;
+
+import android.net.Uri;
+
+/**
+ * Content provider for last received capabilities
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class CapabilitiesLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.capabilities/capabilities");
+
+    /**
+     * Capability is not supported
+     */
+    public static final int NOT_SUPPORTED = 0;
+
+    /**
+     * Capability is supported
+     */
+    public static final int SUPPORTED = 1;
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the MSISDN of the contact associated to the capabilities.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the image share capability.
+     * @see CapabilitiesLog.Support
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_IMAGE_SHARE = "capability_image_share";
+
+    /**
+     * The name of the column containing the video share capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_VIDEO_SHARE = "capability_video_share";
+
+    /**
+     * The name of the column containing the file transfer capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_FILE_TRANSFER = "capability_file_transfer";
+
+    /**
+     * The name of the column containing the chat/IM session capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_IM_SESSION = "capability_im_session";
+
+    /**
+     * The name of the column containing the geoloc push capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_GEOLOC_PUSH = "capability_geoloc_push";
+
+    /**
+     * The name of the column containing the IP voice call capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_IP_VOICE_CALL = "capability_ip_voice_call";
+
+    /**
+     * The name of the column containing the IP video call capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_IP_VIDEO_CALL = "capability_ip_video_call";
+
+    /**
+     * The name of the column containing the RCS extensions. List of features tags
+     * semicolon separated (e.g. <TAG1>;<TAG2>;TAGn).
+     * <P>Type: TEXT</P>
+     */
+    public static final String CAPABILITY_EXTENSIONS = "capability_extensions";
+
+
+    public static final String CAPABILITY_BURN_AFTER_READING = "burn_after_reading";
+
+
+}
diff --git a/src/java/org/gsma/joyn/capability/CapabilityService.java b/src/java/org/gsma/joyn/capability/CapabilityService.java
new file mode 100644
index 0000000..c871492
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/CapabilityService.java
@@ -0,0 +1,452 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.capability;
+
+import java.util.Iterator;
+import java.util.Set;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+
+
+import org.gsma.joyn.Logger;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+
+/**
+ * Capability service offers the main entry point to read capabilities
+ * of remote contacts, to initiate capability discovery and to receive
+ * capabilities updates. Several applications may connect/disconnect
+ * to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class CapabilityService extends JoynService {
+    /**
+     * Intent broadcasted to discover extensions
+     *
+     * @see CapabilityService.EXTENSION_MIME_TYPE
+     */
+    public final static String INTENT_EXTENSIONS = "org.gsma.joyn.capability.EXTENSION";
+
+    /**
+     * Extension MIME type
+     */
+    public final static String EXTENSION_MIME_TYPE = "org.gsma.joyn";
+
+    /**
+     * API
+     */
+    private ICapabilityService api = null;
+
+    public static final String TAG = "CapabilityService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public CapabilityService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_READ_CAPABILITIES) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_READ_CAPABILITIES");
+        }*/
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.ANDROID_READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission ANDROID_READ_CONTACTS");
+        }*/
+        Logger.i(TAG, "connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        intent.setAction(ICapabilityService.class.getName());
+        ctx.bindService(intent, apiConnection, 0);
+
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+        Logger.i(TAG, "setApi entry" + api);
+        this.api = (ICapabilityService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry");
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getCapabilitiesServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(ICapabilityService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected entry");
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the capabilities supported by the local end user. The supported
+     * capabilities are fixed by the MNO and read during the provisioning.
+     *
+     * @return Capabilities
+     * @throws JoynServiceException
+     */
+    public Capabilities getMyCapabilities() throws JoynServiceException {
+        Logger.i(TAG, "getMyCapabilities entry");
+        if (api != null) {
+            try {
+                return api.getMyCapabilities();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the capabilities of a given contact from the local database. This
+     * method doesnt request any network update to the remote contact. The parameter
+     * contact supports the following formats: MSISDN in national or international
+     * format, SIP address, SIP-URI or Tel-URI. If the format of the contact is not
+     * supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @return Capabilities
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public Capabilities getContactCapabilities(String contact) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "getContactCapabilities entry" + contact);
+        if (api != null) {
+            try {
+                return api.getContactCapabilities(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Requests capabilities to a remote contact. This method initiates in background
+     * a new capability request to the remote contact by sending a SIP OPTIONS. The
+     * result of the capability request is sent asynchronously via callback method of
+     * the capabilities listener. A capability refresh is only sent if the timestamp
+     * associated to the capability has expired (the expiration value is fixed via MNO
+     * provisioning). The parameter contact supports the following formats: MSISDN in
+     * national or international format, SIP address, SIP-URI or Tel-URI. If the format
+     * of the contact is not supported an exception is thrown. The result of the
+     * capability refresh request is provided to all the clients that have registered
+     * the listener for this event.
+     *
+     * @param contact Contact
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public void requestContactCapabilities(String contact) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "requestContactCapabilities entry" + contact);
+        if (api != null) {
+            try {
+                api.requestContactCapabilities(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Requests capabilities for a group of remote contacts. This method initiates
+     * in background new capability requests to the remote contact by sending a
+     * SIP OPTIONS. The result of the capability request is sent asynchronously via
+     * callback method of the capabilities listener. A capability refresh is only
+     * sent if the timestamp associated to the capability has expired (the expiration
+     * value is fixed via MNO provisioning). The parameter contact supports the
+     * following formats: MSISDN in national or international format, SIP address,
+     * SIP-URI or Tel-URI. If the format of the contact is not supported an exception
+     * is thrown. The result of the capability refresh request is provided to all the
+     * clients that have registered the listener for this event.
+     *
+     * @param contacts List of contacts
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public void requestContactCapabilities(Set<String> contacts) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "requestContactCapabilities entry" + contacts);
+        Iterator<String> values = contacts.iterator();
+        while (values.hasNext()) {
+            requestContactCapabilities(values.next());
+        }
+    }
+
+    /**
+     * Requests capabilities for all contacts existing in the local address book. This
+     * method initiates in background new capability requests for each contact of the
+     * address book by sending SIP OPTIONS. The result of a capability request is sent
+     * asynchronously via callback method of the capabilities listener. A capability
+     * refresh is only sent if the timestamp associated to the capability has expired
+     * (the expiration value is fixed via MNO provisioning). The result of the capability
+     * refresh request is provided to all the clients that have registered the listener
+     * for this event.
+     *
+     * @param contacts List of contacts
+     * @throws JoynServiceException
+     */
+    public void requestAllContactsCapabilities() throws JoynServiceException {
+        Logger.i(TAG, "requestAllContactsCapabilities entry");
+        if (api != null) {
+            try {
+                api.requestAllContactsCapabilities();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        Logger.i(TAG, "getServiceVersion entry");
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            Logger.i(TAG, "getServiceVersion is" + version);
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        Logger.i(TAG, "isServiceRegistered entry");
+        if (api != null) {
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            Logger.i(TAG, "isServiceRegistered" + serviceStatus);
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a capabilities listener on any contact
+     *
+     * @param listener Capabilities listener
+     * @throws JoynServiceException
+     */
+    public void addCapabilitiesListener(CapabilitiesListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addCapabilitiesListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addCapabilitiesListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a capabilities listener
+     *
+     * @param listener Capabilities listener
+     * @throws JoynServiceException
+     */
+    public void removeCapabilitiesListener(CapabilitiesListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeCapabilitiesListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeCapabilitiesListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a capabilities listener on a list of contacts
+     *
+     * @param contacts Set of contacts
+     * @param listener Capabilities listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public void addCapabilitiesListener(Set<String> contacts, CapabilitiesListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "addCapabilitiesListener entry" + contacts + listener);
+        if (api != null) {
+            try {
+                Iterator<String> list = contacts.iterator();
+                while (list.hasNext()) {
+                    String contact = list.next();
+                    api.addContactCapabilitiesListener(contact, listener);
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a capabilities listener on a list of contacts
+     *
+     * @param contacts Set of contacts
+     * @param listener Capabilities listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public void removeCapabilitiesListener(Set<String> contacts, CapabilitiesListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "removeCapabilitiesListener entry" + contacts + listener);
+        if (api != null) {
+            try {
+                Iterator<String> list = contacts.iterator();
+                while (list.hasNext()) {
+                    String contact = list.next();
+                    api.removeContactCapabilitiesListener(contact, listener);
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl b/src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl
new file mode 100644
index 0000000..7dbcfa1
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl
@@ -0,0 +1,10 @@
+package org.gsma.joyn.capability;
+
+import org.gsma.joyn.capability.Capabilities;
+
+/**
+ * Callback method for new capabilities
+ */
+interface ICapabilitiesListener {
+	void onCapabilitiesReceived(in String contact, in Capabilities capabilities);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/capability/ICapabilityService.aidl b/src/java/org/gsma/joyn/capability/ICapabilityService.aidl
new file mode 100644
index 0000000..ca140f3
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/ICapabilityService.aidl
@@ -0,0 +1,34 @@
+package org.gsma.joyn.capability;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.capability.Capabilities;
+import org.gsma.joyn.capability.ICapabilitiesListener;
+
+/**
+ * Capability service API
+ */
+interface ICapabilityService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	Capabilities getMyCapabilities();
+
+	Capabilities getContactCapabilities(in String contact);
+
+	void requestContactCapabilities(in String contact);
+
+	void requestAllContactsCapabilities();
+
+	void addCapabilitiesListener(in ICapabilitiesListener listener);
+
+	void removeCapabilitiesListener(in ICapabilitiesListener listener);
+
+	void addContactCapabilitiesListener(in String contact, in ICapabilitiesListener listener);
+
+	void removeContactCapabilitiesListener(in String contact, in ICapabilitiesListener listener);
+	
+	int getServiceVersion();
+}
diff --git a/src/java/org/gsma/joyn/capability/package-info.java b/src/java/org/gsma/joyn/capability/package-info.java
new file mode 100644
index 0000000..6cc2258
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/package-info.java
@@ -0,0 +1,20 @@
+/**
+ * This API permits to discover capabilities supported by remote contacts.
+ * <p>
+ * This API allows for querying the capabilities of a user or users and checking
+ * for changes in their capabilities:<br>
+ * - Read the supported capabilities locally by the user on its device.<br>
+ * - Retrieve all capabilities of a user.<br>
+ * - Checking a specific capability of a user.<br>
+ * - Registering for changes to a user/users capabilities.<br>
+ * - Unregistering for changes to a user/users capabilities.<br>
+ * - Define scheme for registering new service capabilities based on manifest defined
+ *  feature tags. This API may be accessible by any application (third party, MNO, OEM).
+ *  The RCS extensions are controlled internally by the RCS service.
+ * <p>
+ * For example, this API may be used:<br>
+ * - To request capability update for a user when opening its contact card in the address book.<br>
+ * - To synchronize capabilities of all the contacts from the RCS account management menu.<br>
+ * - To receive supported capabilities when a CS call is established.<br>
+ */
+package org.gsma.joyn.capability;
diff --git a/src/java/org/gsma/joyn/chat/Chat.java b/src/java/org/gsma/joyn/chat/Chat.java
new file mode 100644
index 0000000..d24be2c
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/Chat.java
@@ -0,0 +1,482 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+
+import org.gsma.joyn.JoynServiceException;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * Chat
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Chat {
+
+    /**
+     * Direction of the group chat
+     */
+    public static class MessageState {
+        /**
+         * Message being sent
+         */
+        public static final int SENDING = 0;
+
+        /**
+         * Message sent
+         */
+        public static final int SENT = 1;
+
+        /**
+         * Message delivered to remote
+         */
+        public static final int DELIVERED = 2;
+
+        /**
+         * Message sending failed
+         */
+        public static final int FAILED = 3;
+    }
+
+    /**
+     * Direction of the group chat
+     */
+    public static class ErrorCodes {
+        /**
+         * Message being sent
+         */
+        public static final int TIMEOUT = 1;
+
+        /**
+         * Message sent
+         */
+        public static final int UNKNOWN = 2;
+
+        /**
+         * Message delivered to remote
+         */
+        public static final int INTERNAL_EROR = 3;
+
+        /**
+         * Message sending failed
+         */
+        public static final int OUT_OF_SIZE = 4;
+    }
+
+    /**
+     * Chat interface
+     */
+    protected IChat chatInf;
+
+    public static final String TAG = "TAPI-Chat";
+
+    /**
+     * Constructor
+     *
+     * @param chatIntf Chat interface
+     */
+    Chat(IChat chatIntf) {
+        this.chatInf = chatIntf;
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact entry");
+        try {
+            return chatInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a chat message
+     *
+     * @param message Message
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendMessage(String message) throws JoynServiceException {
+        Logger.i(TAG, "ABC sendMessage entry " + message);
+        try {
+            return chatInf.sendMessage(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a geoloc message
+     *
+     * @param geoloc Geoloc info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendGeoloc(Geoloc geoloc) throws JoynServiceException {
+
+        Logger.i(TAG, "sendGeoloc entry " + geoloc);
+        try {
+            return chatInf.sendGeoloc(geoloc);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a large mode message
+     *
+     * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+   public String sendMessageByLargeMode(String message) throws JoynServiceException {
+
+        Logger.i(TAG, "sendMessageByLargeMode entry " + message);
+        try {
+            return chatInf.sendMessageByLargeMode(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+  /**
+    * Sends a cloud large mode message
+    *
+    * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+    */
+  public String sendCloudMessageByLargeMode(String message) throws JoynServiceException {
+
+    Logger.i(TAG, "sendCloudMessageByLargeMode entry " + message);
+        try {
+            return chatInf.sendCloudMessageByLargeMode(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+   }
+
+  /**
+     * Sends a pager mode message
+     *
+     * @param messageId Message id
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+  public void sendSpamMessageByPagerMode(String contact, String messageId)  throws JoynServiceException {
+
+        Logger.i(TAG, "sendSpamMessageByPagerMode entry " + messageId);
+        try {
+            chatInf.sendSpamMessageByPagerMode(contact, messageId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+   /**
+    * Sends a pager mode message for spam report
+    *
+     * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+   public String sendMessageByPagerMode(String message) throws JoynServiceException {
+
+        Logger.i(TAG, "sendMessageByPagerMode entry " + message);
+        try {
+            return chatInf.sendMessageByPagerMode(message, false, false, false, false, null);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+   /**
+    * Sends a pager mode message
+    *
+    * @param message Message info
+    * @return Unique message ID or null in case of error
+    * @throws JoynServiceException
+    */
+  public String sendOnetoMultiMessageByPagerMode(String message, HashSet<String> participants) throws JoynServiceException {
+
+       Logger.i(TAG, "sendMessageByPagerMode entry " + message);
+       try {
+           return chatInf.sendMessageByPagerMode(message, false, false, true, false, new ArrayList<String>(participants));
+       } catch (Exception e) {
+           throw new JoynServiceException(e.getMessage());
+       }
+   }
+
+  /**
+    * Sends a pager mode emoticon message
+    * 
+    * @param message Message info
+    * @return Unique message ID or null in case of error
+    * @throws JoynServiceException
+    */
+  public String sendOnetoMultiEmoticonsMessageByPagerMode(String message, HashSet<String> participants) throws JoynServiceException {
+       
+       Logger.i(TAG, "sendOnetoMultiEmoticonsMessageByPagerMode entry " + message + "Participants: " + participants);
+       try {
+           return chatInf.sendOnetoMultiEmoticonsMessage(message,new ArrayList<String>(participants));
+       } catch(Exception e) {
+           throw new JoynServiceException(e.getMessage());
+       }       
+   }
+   
+   
+  /**
+   * Sends a pager mode message
+   *
+   * @param message Message info
+   * @return Unique message ID or null in case of error
+   * @throws JoynServiceException
+   */
+ public String sendOnetoMultiMessage(String message, HashSet<String> participants) throws JoynServiceException {
+
+      try {
+          return chatInf.sendOnetoMultiMessage(message, new ArrayList<String>(participants));
+      } catch (Exception e) {
+          throw new JoynServiceException(e.getMessage());
+      }
+  }
+
+
+ /**
+  * Sends a pager mode message
+  *
+  * @param message Message info
+  * @return Unique message ID or null in case of error
+  * @throws JoynServiceException
+  */
+public String sendEmoticonShopMessage(String message) throws JoynServiceException {
+
+     try {
+         return chatInf.sendEmoticonShopMessage(message);
+     } catch (Exception e) {
+         throw new JoynServiceException(e.getMessage());
+     }
+ }
+
+public String sendCloudMessage(String message) throws JoynServiceException {
+
+     try {
+         return chatInf.sendCloudMessage(message);
+     } catch (Exception e) {
+         throw new JoynServiceException(e.getMessage());
+     }
+ }
+
+
+
+
+  public String sendBurnMessage(String message)throws JoynServiceException {
+      Logger.i(TAG, "sendBurnMessage entry " + message);
+        try {
+        //  return chatInf.sendGeoloc(geoloc);
+        return null;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+  }
+
+
+
+  public String sendPagerModeBurnMessage(String message)throws JoynServiceException {
+      Logger.i(TAG, "sendPagerModeBurnMessage entry " + message);
+        try {
+            return chatInf.sendPagerModeBurnMessage(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+  }
+
+  /**
+   * Sends a burn message by large message mode
+   *
+   * @param message Message info
+   * @return Unique message ID or null in case of error
+   * @throws JoynServiceException
+   */
+  public String sendLargeModeBurnMessage(String message)throws JoynServiceException {
+      Logger.i(TAG, "sendLargeModeBurnMessage entry " + message);
+        try {
+        return chatInf.sendLargeModeBurnMessage(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+  }
+
+    /**
+     * Sends a displayed delivery report for a given message ID
+     *
+     * @param msgId Message ID
+     * @throws JoynServiceException
+     */
+    public void sendDisplayedDeliveryReport(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "sendDisplayedDeliveryReport entry " + msgId);
+        try {
+            chatInf.sendDisplayedDeliveryReport(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a burn report for a given burn message ID
+     *
+     * @param msgId Message ID
+     * @throws JoynServiceException
+     */
+    public void sendBurnDeliveryReport(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "sendBurnDeliveryReport entry " + msgId);
+        try {
+            chatInf.sendBurnDeliveryReport(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends an Is-composing event. The status is set to true when
+     * typing a message, else it is set to false.
+     *
+     * @param status Is-composing status
+     * @throws JoynServiceException
+     */
+    public void sendIsComposingEvent(boolean status) throws JoynServiceException {
+        Logger.i(TAG, "sendIsComposingEvent entry " + status);
+        try {
+            chatInf.sendIsComposingEvent(status);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     *
+     * @param msgId message Id of message
+     * @return state of the message
+     * @throws JoynServiceException
+     */
+    public int resendMessage(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "resendMessage msgId " + msgId);
+        try {
+            return chatInf.resendMessage(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     *
+     * @param msgId message Id of message
+     * @throws JoynServiceException
+     */
+    public int reSendMultiMessageByPagerMode(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "reSendMultiMessageByPagerMode msgId " + msgId);
+        try {
+            return chatInf.reSendMultiMessageByPagerMode(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     *
+     * @param msgId message Id of message
+     * @return state of the message
+     * @throws JoynServiceException
+     */
+    public int getState(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "getState MessageId= " + msgId);
+        try {
+            return 0;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on chat events
+     *
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(ChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener entry " + listener);
+        try {
+            chatInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener on chat events
+     *
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(ChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener entry " + listener);
+        try {
+            chatInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on spam events
+     *
+     * @param listener Spam event listener
+     * @throws JoynServiceException
+     */
+    public void addSpamReportListener(SpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addSpamReportListener entry " + listener);
+        try {
+            chatInf.addSpamReportListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener on spam events
+     *
+     * @param listener Spam event listener
+     * @throws JoynServiceException
+     */
+    public void removeSpamReportListener(SpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeSpamReportListener entry " + listener);
+        try {
+            chatInf.removeSpamReportListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatIntent.java b/src/java/org/gsma/joyn/chat/ChatIntent.java
new file mode 100644
index 0000000..ae74d4c
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatIntent.java
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+/**
+ * Intent for chat conversation
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatIntent {
+    /**
+     * Broadcast action: a new chat message has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the remote contact
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_MESSAGE} containing the chat message (parcelable object).
+     * </ul>
+     */
+    public final static String ACTION_NEW_CHAT = "org.gsma.joyn.chat.action.NEW_CHAT";
+
+     /**
+     * Broadcast action: a delivery status of a chat message has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the remote contact
+     * <li> {msgId} containing the message id of the message.
+     * <li> {status} containing the delivery status of chat message.
+     * </ul>
+     */
+    public final static String ACTION_DELIVERY_STATUS = "org.gsma.joyn.chat.action.DELIEVRY_STATUS";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CLOUD_MESSAGE = "cloudMessage";
+
+    /**
+     * Display name of the contact sending the invitation (extracted from the SIP address)
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Received message
+     *
+     * @see ChatMessage
+     * @see GeolocMessage
+     */
+    public final static String EXTRA_MESSAGE = "firstMessage";
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatListener.java b/src/java/org/gsma/joyn/chat/ChatListener.java
new file mode 100644
index 0000000..a2e34e9
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatListener.java
@@ -0,0 +1,111 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+
+/**
+ * Chat event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class ChatListener extends IChatListener.Stub {
+    /**
+     * Callback called when a new message has been received
+     *
+     * @param message Chat message
+     * @see ChatMessage
+     */
+    public abstract void onNewMessage(ChatMessage message);
+
+    /**
+     * Callback called when a new geoloc has been received
+     *
+     * @param message Geoloc message
+     */
+    public abstract void onNewGeoloc(GeolocMessage message);
+
+    /**
+     * Callback called when a message has been delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageDelivered(String msgId);
+
+    /**
+     * Callback called when a message has been displayed by the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageDisplayed(String msgId);
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageFailed(String msgId);
+
+    /**
+     * Callback called when an Is-composing event has been received. If the
+     * remote is typing a message the status is set to true, else it is false.
+     *
+     * @param status Is-composing status
+     */
+    public abstract void onComposingEvent(boolean status);
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public void onReportFailedMessage(String msgId, int errtype, String statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has been sent to the remote
+     *
+     * @param msgId Message ID
+     */
+    public void onReportSentMessage(String msgId) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public void onReportDeliveredMessage(String msgId) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a new burn message has been received
+     *
+     * @param message Chat message
+     * @see ChatMessage
+     */
+    public void onNewBurnMessageArrived(ChatMessage msg) {
+        // default implementation for TAPI extension
+    }
+
+    //message callback when a new burn file transfer arrives
+    //public abstract void onNewBurnFileTransfer(
+    //          String transferId,Boolean isGroup,String chatSessionId,String ChatId);
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatLog.java b/src/java/org/gsma/joyn/chat/ChatLog.java
new file mode 100644
index 0000000..6dc01ae
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatLog.java
@@ -0,0 +1,702 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.io.ByteArrayInputStream;
+import java.io.ObjectInputStream;
+
+import android.net.Uri;
+
+/**
+ * Content provider for chat history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatLog {
+    /**
+     * Group chat
+     */
+    public static class GroupChat {
+        /**
+         * Content provider URI for chat conversations
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/chat");
+
+        /**
+         * The name of the column containing the unique ID for a row.
+         * <P>Type: primary key</P>
+         */
+        public static final String ID = "_id";
+
+        /**
+         * The name of the column containing the unique ID of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CHAT_ID = "chat_id";
+
+        /**
+         * The name of the column containing the state of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.State
+         */
+        public static final String STATE = "state";
+
+        /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String SUBJECT = "subject";
+
+
+        /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PARTICIPANTS_LIST = "participants";
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String DIRECTION = "direction";
+
+        /**
+         * The name of the column containing the time when group chat is created.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP = "timestamp";
+
+
+        /*
+         * M: CPM related changes
+         */
+        /**
+         * The name of the column containing the conversation ID.(in case of CPM only its added)
+         * <P>Type: TEXT</P>
+         */
+        public static final String CONVERSATION_ID = "conversation_id";
+
+        /*
+         *@: ENDS
+         */
+        /**
+         * CMCC changes
+         */
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String CHAIRMAN = "chairman";
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String NICKNAME = "nickname";
+
+        public static final String ISBLOCKED = "isBlocked";
+
+    }
+
+    /**
+     * Chat message from a single chat or group chat
+     */
+    public static class Message {
+        /**
+         * Content provider URI for chat messages
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/message");
+
+        /**
+         * Content provider URI for chat messages of a given conversation. In case of single chat
+         * the conversation is identified by the contact phone number. In case of group chat the
+         * the conversation is identified by the unique chat ID.
+         */
+        public static final Uri CONTENT_CHAT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/message/#");
+
+        /**
+         * The name of the column containing the unique ID for a row.
+         * <P>Type: primary key</P>
+         */
+        public static final String ID = "_id";
+
+        /**
+         * The name of the column containing the chat ID.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CHAT_ID = "chat_id";
+
+        /**
+         * The name of the column containing the message ID.
+         * <P>Type: TEXT</P>
+         */
+        public static final String MESSAGE_ID = "msg_id";
+
+        /**
+         * The name of the column containing the message status.
+         * <P>Type: INTEGER</P>
+         */
+        public static final String MESSAGE_STATUS = "status";
+
+        /**
+         * The name of the column containing the message direction.
+         * <P>Type: INTEGER</P>
+         */
+        public static final String DIRECTION = "direction";
+
+        /**
+         * The name of the column containing the type of message.
+         * <P>Type: INTEGER</P>
+         * @see ChatLog.Message.Type
+         */
+        public static final String MESSAGE_TYPE = "msg_type";
+
+        /**
+         * The name of the column containing the identity of the sender of the message.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CONTACT_NUMBER = "sender";
+
+
+        /**
+         * The name of the column containing the message body.
+         * <P>Type: BLOB</P>
+         */
+        public static final String BODY = "body";
+
+        /**
+         * The name of the column containing the time when message is created.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP = "timestamp";
+
+        /**
+         * The name of the column containing the time when message is sent. If 0 means not sent.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP_SENT = "timestamp_sent";
+
+        /**
+         * The name of the column containing the time when message is delivered. If 0 means not delivered.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP_DELIVERED = "timestamp_delivered";
+
+        /**
+         * The name of the column containing the time when message is displayed. If 0 means not displayed.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP_DISPLAYED = "timestamp_displayed";
+
+        /**
+         * The name of the column containing the MIME-TYPE of the message body.
+         * <P>Type: TEXT</P>
+         */
+        public static final String MIME_TYPE = "mime_type";
+
+
+        /** M:for adding alias or display name
+         * The name of the column containing the display name user. in case of O2O only in SYSTEM_MSG this value will be set.
+         * in case of GROUP CHAT, it will be set for all messages
+         * <P>Type: TEXT</P>
+         */
+        public static final String DISPLAY_NAME = "display_name";
+        /**@*/
+
+        /*
+         * M: CPM related changes
+         */
+        /**
+         * The name of the column containing the conversation ID.(in case of CPM only its added)
+         * <P>Type: TEXT</P>
+         */
+        public static final String CONVERSATION_ID = "conversation_id";
+
+        /*
+         *@: ENDS
+         */
+
+
+        /**
+         * Type of the message
+         */
+        public static class Type {
+            /**
+             * Content message
+             */
+            public static final int CONTENT = 0;
+
+            /**
+             * System message
+             */
+            public static final int SYSTEM = 1;
+
+            /**
+             * Spam message
+             */
+            public static final int SPAM = 2;
+
+            /**
+             * burn message
+             */
+            public static final int BURN = 3;
+
+            /**
+             * burn message
+             */
+            public static final int PUBLIC = 4;
+
+            /**
+             * CLOUD message
+             */
+            public static final int CLOUD = 5;
+
+            /**
+             * CLOUD message
+             */
+            public static final int EMOTICON = 6;
+
+        }
+
+        /**
+         * Direction of the message
+         */
+        public static class Direction {
+            /**
+             * Incoming message
+             */
+            public static final int INCOMING = 0;
+
+            /**
+             * Outgoing message
+             */
+            public static final int OUTGOING = 1;
+
+            /**
+             * Irrelevant or not applicable (e.g. for a system message)
+             */
+            public static final int IRRELEVANT = 2;
+        }
+
+        /**
+         * Status of the message
+         */
+        public static class Status {
+            /**
+             * Status of a content message
+             */
+            public static class Content {
+                /**
+                 * The message has been delivered, but we don't know if the message
+                 * has been read by the remote
+                 */
+                public static final int UNREAD = 0;
+
+                /**
+                 * The message has been delivered and a displayed delivery report is
+                 * requested, but we don't know if the message has been read by the remote
+                 */
+                public static final int UNREAD_REPORT = 1;
+
+                /**
+                 * The message has been read by the remote (i.e. displayed)
+                 */
+                public static final int READ = 2;
+
+                /**
+                 * The message is in progress of sending
+                 */
+                public static final int SENDING = 3;
+
+                /**
+                 * The message has been sent
+                 */
+                public static final int SENT = 4;
+
+                /**
+                 * The message is failed to be sent
+                 */
+                public static final int FAILED = 5;
+
+                /**
+                 * The message is queued to be sent by joyn service when possible
+                 */
+                public static final int TO_SEND = 6;
+
+                /**
+                 * The message is a spam message
+                 */
+                public static final int BLOCKED = 7;
+            }
+
+            /**
+             * Status of the system message
+             */
+            public static class System {
+                /**
+                 * Invitation of a participant is pending
+                 */
+                public static final int PENDING = 0;
+
+                /**
+                 * Invitation accepted by a participant
+                 */
+                public static final int ACCEPTED = 1;
+
+                /**
+                 * Invitation declined by a participant
+                 */
+                public static final int DECLINED = 2;
+
+                /**
+                 * Invitation of a participant has failed
+                 */
+                public static final int FAILED = 3;
+
+                /**
+                 * Participant has joined the group chat
+                 */
+                public static final int JOINED = 4;
+
+                /**
+                 * Participant has left the group chat (i.e. departed)
+                 */
+                public static final int GONE = 5;
+
+                /**
+                 * Participant has been disconnected from the group chat (i.e. booted)
+                 */
+                public static final int DISCONNECTED = 6;
+
+                /**
+                 * Participant is busy
+                 */
+                public static final int BUSY = 7;
+            }
+        }
+    }
+
+    /**
+     * Chat message from a single chat or group chat
+     */
+    public static class MultiMessage {
+        /**
+         * Content provider URI for chat messages
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/multimessage");
+
+        /**
+         * Content provider URI for chat messages of a given conversation. In case of single chat
+         * the conversation is identified by the contact phone number. In case of group chat the
+         * the conversation is identified by the unique chat ID.
+         */
+        public static final Uri CONTENT_CHAT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/multimessage/#");
+
+
+        /**
+         * The name of the column containing the unique ID for a row.
+         * <P>Type: primary key</P>
+         */
+        public static final String ID = "_id";
+
+        /**
+         * The name of the column containing the unique ID of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CHAT_ID = "chat_id";
+
+        public static final String MESSAGE_ID = "msg_id";
+        /**
+         * The name of the column containing the state of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.State
+         */
+        public static final String STATE = "state";
+
+        /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String SUBJECT = "subject";
+
+
+        /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PARTICIPANTS_LIST = "participants";
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String DIRECTION = "direction";
+
+        /**
+         * The name of the column containing the time when group chat is created.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP = "timestamp";
+
+        /*
+         *@: ENDS
+         */
+
+
+        /**
+         * Type of the message
+         */
+        public static class Type {
+            /**
+             * Content message
+             */
+            public static final int CONTENT = 0;
+
+            /**
+             * System message
+             */
+            public static final int SYSTEM = 1;
+
+            /**
+             * Spam message
+             */
+            public static final int SPAM = 2;
+        }
+
+        /**
+         * Direction of the message
+         */
+        public static class Direction {
+            /**
+             * Incoming message
+             */
+            public static final int INCOMING = 0;
+
+            /**
+             * Outgoing message
+             */
+            public static final int OUTGOING = 1;
+
+            /**
+             * Irrelevant or not applicable (e.g. for a system message)
+             */
+            public static final int IRRELEVANT = 2;
+        }
+
+        /**
+         * Status of the message
+         */
+        public static class Status {
+            /**
+             * Status of a content message
+             */
+            public static class Content {
+                /**
+                 * The message has been delivered, but we don't know if the message
+                 * has been read by the remote
+                 */
+                public static final int UNREAD = 0;
+
+                /**
+                 * The message has been delivered and a displayed delivery report is
+                 * requested, but we don't know if the message has been read by the remote
+                 */
+                public static final int UNREAD_REPORT = 1;
+
+                /**
+                 * The message has been read by the remote (i.e. displayed)
+                 */
+                public static final int READ = 2;
+
+                /**
+                 * The message is in progress of sending
+                 */
+                public static final int SENDING = 3;
+
+                /**
+                 * The message has been sent
+                 */
+                public static final int SENT = 4;
+
+                /**
+                 * The message is failed to be sent
+                 */
+                public static final int FAILED = 5;
+
+                /**
+                 * The message is queued to be sent by joyn service when possible
+                 */
+                public static final int TO_SEND = 6;
+
+                /**
+                 * The message is a spam message
+                 */
+                public static final int BLOCKED = 7;
+            }
+
+            /**
+             * Status of the system message
+             */
+            public static class System {
+                /**
+                 * Invitation of a participant is pending
+                 */
+                public static final int PENDING = 0;
+
+                /**
+                 * Invitation accepted by a participant
+                 */
+                public static final int ACCEPTED = 1;
+
+                /**
+                 * Invitation declined by a participant
+                 */
+                public static final int DECLINED = 2;
+
+                /**
+                 * Invitation of a participant has failed
+                 */
+                public static final int FAILED = 3;
+
+                /**
+                 * Participant has joined the group chat
+                 */
+                public static final int JOINED = 4;
+
+                /**
+                 * Participant has left the group chat (i.e. departed)
+                 */
+                public static final int GONE = 5;
+
+                /**
+                 * Participant has been disconnected from the group chat (i.e. booted)
+                 */
+                public static final int DISCONNECTED = 6;
+
+                /**
+                 * Participant is busy
+                 */
+                public static final int BUSY = 7;
+            }
+        }
+    }
+
+
+    public static class GroupChatMember {
+        /**
+         * Content provider URI for chat conversations
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/groupmember");
+
+
+        /**
+         *
+         * <P>Type: TEXT</P>
+         */
+        public static final String ID = "_id";
+
+
+        /**
+         *
+         * <P>Type: TEXT</P>
+         */
+        public static final String CHAT_ID = "CHAT_ID";
+
+
+        /**
+         *
+         * <P>Type: TEXT</P>
+         */
+        public static final String GROUP_MEMBER_NAME = "MEMBER_NAME";
+
+        /**
+         * .
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String GROUP_MEMBER_PORTRAIT = "PORTRAIT";
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String GROUP_MEMBER_NUMBER = "CONTACT_NUMBER";
+
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String GROUP_MEMBER_TYPE = "CONTACT_ETYPE";
+
+
+
+        /*
+         * M: CPM related changes
+         */
+        /**
+         * The name of the column containing the conversation ID.(in case of CPM only its added)
+         * <P>Type: TEXT</P>
+         */
+        public static final String CONVERSATION_ID = "conversation_id";
+
+        /*
+         *@: ENDS
+         */
+    }
+
+    /**
+     * Get plain text message from a BLOB
+     *
+     * @param content BLOB content
+     * @return Text message or null in case of error
+     */
+    public static String getTextFromBlob(byte[] content) {
+        try {
+            return new String(content);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    /**
+     * Get geoloc object from a BLOB
+     *
+     * @param content BLOB content
+     * @return Geoloc object or null in case of error
+     * @see Geoloc
+     */
+    public static Geoloc getGeolocFromBlob(byte[] content) {
+        try {
+            ByteArrayInputStream bis = new ByteArrayInputStream(content);
+            ObjectInputStream is = new ObjectInputStream(bis);
+            Geoloc geoloc = (Geoloc) is.readObject();
+            is.close();
+            return geoloc;
+        } catch (Exception e) {
+            return null;
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatMessage.aidl b/src/java/org/gsma/joyn/chat/ChatMessage.aidl
new file mode 100644
index 0000000..5fd54a4
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatMessage.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Chat message object
+ */
+parcelable ChatMessage;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/ChatMessage.java b/src/java/org/gsma/joyn/chat/ChatMessage.java
new file mode 100644
index 0000000..085fcd0
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatMessage.java
@@ -0,0 +1,275 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.Date;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Chat message
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatMessage implements Parcelable {
+    /**
+     * MIME type
+     */
+    public final static String MIME_TYPE = "text/plain";
+
+    public static final String TAG = "TAPI-ChatMessage";
+    /**
+     * Unique message Id
+     */
+    private String id;
+
+    /**
+     * Contact who has sent the message
+     */
+    private String contact;
+
+    /**
+     * Message content
+     */
+    private String message;
+
+    /**
+     * Receipt date of the message
+     */
+    private Date receiptAt;
+
+    /**
+     * Display Name
+     */
+    private String displayName;
+
+    /**
+     * Flag indicating is a displayed report is requested
+     */
+    private boolean displayedReportRequested = false;
+
+
+    /**
+     * burn message
+     */
+    private boolean isBurnMessage = false;
+
+    private boolean isPublicMessage = false;
+
+    private boolean isCloudMessage = false;
+
+    private boolean isEmoticonMessage = false;
+
+
+    /**
+     * Constructor for outgoing message
+     *
+     * @param messageId Message Id
+     * @param contact Contact
+     * @param message Message content
+     * @param receiptAt Receipt date
+     * @param displayedReportRequested Flag indicating if a displayed report is requested
+     * @hide
+     */
+    public ChatMessage(String messageId, String remote, String message, Date receiptAt, boolean displayedReportRequested, String displayName) {
+        Logger.i(TAG, "ChatMessage entry" + "messageId=" + messageId + " remote=" + remote + " message=" + message +
+                " receiptAt=" + receiptAt + " displayedReportRequested=" + displayedReportRequested);
+        Logger.i(TAG, "ABCG ChatMessage entry" + "displayname=" + displayName);
+        this.id = messageId;
+        this.contact = remote;
+        this.message = message;
+        this.displayedReportRequested = displayedReportRequested;
+        this.receiptAt = receiptAt;
+        this.displayName = displayName;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public ChatMessage(Parcel source) {
+        this.id = source.readString();
+        this.contact = source.readString();
+        this.message = source.readString();
+        this.receiptAt = new Date(source.readLong());
+        this.displayedReportRequested = source.readInt() != 0;
+        this.displayName = source.readString();
+        this.isBurnMessage = source.readByte() != 0;
+        this.isPublicMessage = source.readByte() != 0;
+        this.isCloudMessage = source.readByte() != 0;
+        this.isEmoticonMessage = source.readByte() != 0;
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(id);
+        dest.writeString(contact);
+        dest.writeString(message);
+        dest.writeLong(receiptAt.getTime());
+        dest.writeInt(displayedReportRequested ? 1 : 0);
+        dest.writeString(displayName);
+        dest.writeByte((byte) (isBurnMessage ? 1 : 0));
+        dest.writeByte((byte) (isPublicMessage ? 1 : 0));
+        dest.writeByte((byte) (isCloudMessage ? 1 : 0));
+        dest.writeByte((byte) (isEmoticonMessage ? 1 : 0));
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<ChatMessage> CREATOR
+            = new Parcelable.Creator<ChatMessage>() {
+        public ChatMessage createFromParcel(Parcel source) {
+            return new ChatMessage(source);
+        }
+
+        public ChatMessage[] newArray(int size) {
+            return new ChatMessage[size];
+        }
+    };
+
+    /**
+     * Returns the message ID
+     *
+     * @return ID
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * Returns the contact
+     *
+     * @return Contact
+     */
+    public String getContact() {
+        return contact;
+    }
+
+    /**
+     * Returns the message content
+     *
+     * @return String
+     */
+    public String getMessage() {
+        return message;
+    }
+
+    /**
+     * Returns the display name
+     *
+     * @return String
+     */
+    public String getDisplayName() {
+        return displayName;
+    }
+
+    /**
+     * Returns the receipt date of chat message
+     *
+     * @return Date
+     */
+    public Date getReceiptDate() {
+        return receiptAt;
+    }
+
+    /**
+     * Is displayed delivery report requested
+     *
+     * @return Returns true if requested else returns false
+     */
+    public boolean isDisplayedReportRequested() {
+        return displayedReportRequested;
+    }
+
+    /**
+     * Is the chat message of burn type
+     *
+     * @return Returns true if chat message is of burn type else returns false
+     */
+    public boolean isBurnMessage() {
+        return isBurnMessage;
+    }
+
+     /**
+     * Set the message type of chat message as burn message
+     *
+     * @param burnFlag Flag indicating whether message is burn message type
+     */
+    public void setBurnMessage(boolean burnFlag) {
+        isBurnMessage = burnFlag;
+    }
+
+    public boolean isCloudMessage() {
+        return isCloudMessage;
+    }
+
+    public void setCloudMessage(boolean burnFlag) {
+        isCloudMessage = burnFlag;
+    }
+
+    public boolean isEmoticonMessage() {
+        return isEmoticonMessage;
+    }
+
+    public void setEmoticonMessage(boolean burnFlag) {
+        isEmoticonMessage = burnFlag;
+    }
+
+    /**
+     * Is the chat message of public chat type
+     *
+     * @return Returns true if chat message is of public chat type else returns false
+     */
+    public boolean isPublicMessage() {
+        return isPublicMessage;
+    }
+
+    /**
+     * Set the message type of chat message as public chat
+     *
+     * @param publicFlag Flag indicating whether message is public chat type
+     */
+    public void setPublicMessage(boolean publicFlag) {
+        isPublicMessage = publicFlag;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatService.java b/src/java/org/gsma/joyn/chat/ChatService.java
new file mode 100644
index 0000000..07877ac
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatService.java
@@ -0,0 +1,843 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+import org.gsma.joyn.Logger;
+//import com.orangelabs.rcs.service.api.ChatServiceImpl;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+
+/**
+ * Chat service offers the main entry point to initiate chat 1-1 ang group
+ * conversations with contacts. Several applications may connect/disconnect
+ * to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatService extends JoynService {
+    /**
+     * API
+     */
+    private IChatService api = null;
+
+    public static final String TAG = "TAPI-ChatService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public ChatService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    @Override
+    public void connect() {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_USE_CHAT) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_USE_CHAT");
+        }*/
+        Logger.i(TAG, "connected() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        boolean connected = ctx.bindService(intent, apiConnection, 0);
+        Logger.i(TAG, "connect() exit status" + connected);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    @Override
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    @Override
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+        Logger.i(TAG, "setApi entry" + api);
+        this.api = (IChatService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry" + service);
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getChatServiceBinder();
+            } catch (RemoteException e1) {
+
+                e1.printStackTrace();
+            }
+            setApi(IChatService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            setApi(null);
+            Logger.i(TAG, "onServiceDisconnected entry");
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of the chat service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public ChatServiceConfiguration getConfiguration() throws JoynServiceException {
+        if (api != null) {
+            try {
+                Logger.i(TAG, "getConfiguration entry");
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    @Override
+    public int getServiceVersion() throws JoynServiceException {
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                    Logger.i(TAG, "getServiceVersion entry " + version);
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    @Override
+    public boolean isServiceRegistered() throws JoynServiceException {
+        Logger.i(TAG, "isServiceRegistered entry ");
+        if (api != null) {
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+                Logger.i(TAG, "isServiceRegistered entry " + serviceStatus);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public void initiateSpamReport(String contact, String messageId) throws JoynServiceException {
+        Logger.i(TAG, "initiateSpamReport entry " + contact + ":" + messageId);
+        if (api != null) {
+            try {
+                api.initiateSpamReport(contact, messageId);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    @Override
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Adds a spam listener.
+     *
+     * @param listener Spam Report listener
+     * @throws JoynServiceException
+     */
+    public void addSpamReportListener(SpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addSpamReportListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addSpamReportListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Removes a spam listener
+     *
+     * @param listener Spam Report listener
+     * @throws JoynServiceException
+     */
+    public void removeSpamReportListener(SpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeSpamReportListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeSpamReportListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    @Override
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Open a single chat with a given contact and returns a Chat instance.
+     * The parameter contact supports the following formats: MSISDN in national
+     * or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @param contact Contact
+     * @param listener Chat event listener
+     * @return Chat or null
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public Chat openSingleChat(String contact, ChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "openSingleChat entry " + contact);
+        if (api != null) {
+            try {
+                IChat chatIntf = api.openSingleChat(contact, listener);
+                if (chatIntf != null) {
+                    return new Chat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Open a 1-Multi chat with a list of contscs and returns a Chat instance.
+     * The  contact supports the following formats: MSISDN in national
+     * or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @param participants list of Contacts
+     * @param listener Chat event listener
+     * @return Chat or null
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public Chat openMultiChat(List<String> participants, ChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            try {
+                IChat chatIntf = api.openMultiChat(participants, listener);
+                if (chatIntf != null) {
+                    return new Chat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+
+    /**
+     * Open a public account chat with a given contact and returns a Chat instance.
+     * The parameter contact supports the following formats: MSISDN in national
+     * or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @param contact Contact
+     * @param listener Chat Event listener
+     * @return Chat or null
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public PublicAccountChat initPublicAccountChat(String contact, ChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "initPublicAccountChat entry " + contact);
+        if (api != null) {
+            try {
+                IChat chatIntf = api.initPublicAccountChat(contact, listener);
+                if (chatIntf != null) {
+                    return new PublicAccountChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates a group chat with a group of contact and returns a GroupChat
+     * instance. The subject is optional and may be null.
+     *
+     * @param contact List of contacts
+     * @param subject Subject
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public GroupChat initiateGroupChat(Set<String> contacts, String subject, GroupChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "initiateGroupChat entry= " + contacts + " subject =" + subject);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.initiateGroupChat(new ArrayList<String>(contacts), subject, listener);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Sends a message to list of participants
+     *
+     * @param participants List of contacts
+     * @param message Message to be sent
+     * @param listener Group Chat event listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public String sendOne2MultiMessageLargeMode(String message, Set<String> participants,  GroupChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "sendOne2MultiMessage entry= " + participants + " subject =" + message);
+        if (api != null) {
+            try {
+                return api.sendOne2MultiMessage(new ArrayList<String>(participants), message, listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates a group chat with a group of contact and returns a GroupChat
+     * instance. The subject is optional and may be null.
+     *
+     * @param contact List of contacts
+     * @param subject Subject
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public int resendOne2MultiMessage(String msgId, GroupChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "resendOne2MultiMessage entry= " + msgId);
+        if (api != null) {
+            try {
+                return api.resendOne2MultiMessage(msgId, listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates a group chat with a group of contact and returns a GroupChat
+     * instance. The subject is optional and may be null.
+     *
+     * @param contact List of contacts
+     * @param subject Subject
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public String sendOne2MultiCloudMessageLargeMode(String message, Set<String> participants,  GroupChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "sendOne2MultiCloudMessageLarge entry= " + participants + " subject =" + message);
+        if (api != null) {
+            try {
+                return api.sendOne2MultiCloudMessageLargeMode(new ArrayList<String>(participants), message, listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    /**
+     * Rejoins an existing group chat from its unique chat ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat
+     * @throws JoynServiceException
+     */
+    public GroupChat rejoinGroupChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "rejoinGroupChat entry= " + chatId);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.rejoinGroupChat(chatId);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Rejoins an existing group chat from its unique chat ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat
+     * @throws JoynServiceException
+     */
+    public GroupChat rejoinGroupChatId(String chatId, String rejoinId) throws JoynServiceException {
+        Logger.i(TAG, "rejoinGroupChat entry= " + chatId + "; rejoin id: " + rejoinId);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.rejoinGroupChatId(chatId, rejoinId);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Restarts a previous group chat from its unique chat ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat
+     * @throws JoynServiceException
+     */
+    public GroupChat restartGroupChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "restartGroupChat entry= " + chatId);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.restartGroupChat(chatId);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Restarts a previous group chat from its unique chat ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat
+     * @throws JoynServiceException
+     */
+    public void syncAllGroupChats(GroupChatSyncingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "syncAllGroupChats ");
+        if (api != null) {
+            try {
+                api.syncAllGroupChats(listener);
+            } catch(Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * sync the group info from server use group chat id
+     *
+     * @param chatId Chat ID
+     * @throws JoynServiceException
+     */
+    public void syncGroupChat(String chatId, GroupChatSyncingListener listener)
+            throws JoynServiceException {
+        Logger.i(TAG, "sync group info: " + chatId);
+        if (api != null) {
+            try {
+                api.syncGroupChat(chatId, listener);
+            } catch(Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of single chats in progress
+     *
+     * @return List of chats
+     * @throws JoynServiceException
+     */
+    public Set<Chat> getChats() throws JoynServiceException {
+        Logger.i(TAG, "getChats entry ");
+        if (api != null) {
+            try {
+                Set<Chat> result = new HashSet<Chat>();
+                List<IBinder> chatList = api.getChats();
+                for (IBinder binder : chatList) {
+                    Chat chat = new Chat(IChat.Stub.asInterface(binder));
+                    result.add(chat);
+                }
+                Logger.i(TAG, "getChats returning with  " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a chat in progress with a given contact
+     *
+     * @param contact Contact
+     * @return Chat or null if not found
+     * @throws JoynServiceException
+     */
+    public Chat getChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "getChat entry " + chatId);
+        if (api != null) {
+            try {
+                IChat chatIntf = api.getChat(chatId);
+                if (chatIntf != null) {
+                    return new Chat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a public chat in progress for the provided chatId
+     *
+     * @param chatId Chat Id of the Public chat
+     * @throws JoynServiceException
+     */
+    public Chat getPublicAccountChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "getPublicAccountChat entry " + chatId);
+        if (api != null) {
+            try {
+                IChat chatIntf = api.getPublicAccountChat(chatId);
+                if (chatIntf != null) {
+                    return new PublicAccountChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a single chat from its invitation Intent
+     *
+     * @param intent Invitation Intent
+     * @return Chat or null if not found
+     * @throws JoynServiceException
+     */
+    public Chat getChatFor(Intent intent) throws JoynServiceException {
+        Logger.i(TAG, "getChatFor entry " + intent);
+        if (api != null) {
+            try {
+                String contact = intent.getStringExtra(ChatIntent.EXTRA_CONTACT);
+                if (contact != null) {
+                    return getChat(contact);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of group chats in progress
+     *
+     * @return List of group chat
+     * @throws JoynServiceException
+     */
+    public Set<GroupChat> getGroupChats() throws JoynServiceException {
+        Logger.i(TAG, "getGroupChats entry ");
+        if (api != null) {
+            try {
+                Set<GroupChat> result = new HashSet<GroupChat>();
+                List<IBinder> chatList = api.getGroupChats();
+                for (IBinder binder : chatList) {
+                    GroupChat chat = new GroupChat(IGroupChat.Stub.asInterface(binder));
+                    result.add(chat);
+                }
+                Logger.i(TAG, "getGroupChats returning with " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a group chat in progress from its unique ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat or null if not found
+     * @throws JoynServiceException
+     */
+    public GroupChat getGroupChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "getGroupChat entry " + chatId);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.getGroupChat(chatId);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a group chat from its invitation Intent
+     *
+     * @param intent Intent invitation
+     * @return Group chat or null if not found
+     * @throws JoynServiceException
+     */
+    public GroupChat getGroupChatFor(Intent intent) throws JoynServiceException {
+        Logger.i(TAG, "getGroupChat entry " + intent);
+        if (api != null) {
+            try {
+                String chatId = intent.getStringExtra(GroupChatIntent.EXTRA_CHAT_ID);
+                if (chatId != null) {
+                    return getGroupChat(chatId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Block messages in group, stack will not notify application about
+     * any received message in this group
+     *
+     * @param chatId chatId of the group
+     * @param flag true means block the message, false means unblock it
+     * @throws JoynServiceException
+     */
+    public void blockGroupMessages(String chatId, boolean flag) throws JoynServiceException {
+        Logger.i(TAG, "blockGroupMessages() entry with chatId: " + chatId + ",flag:" + flag);
+        if (api != null) {
+            try {
+                api.blockGroupMessages(chatId, flag);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a chat invitation listener
+     *
+     * @param listener New chat listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(NewChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addEventListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a chat invitation listener
+     *
+     * @param listener New chat listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(NewChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeEventListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.aidl b/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.aidl
new file mode 100644
index 0000000..4cecc2a
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Chat configuration object
+ */
+parcelable ChatServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.java b/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.java
new file mode 100644
index 0000000..3595a4b
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.java
@@ -0,0 +1,357 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Chat service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatServiceConfiguration {
+
+    public static final String TAG = "ChatServiceConfiguration";
+    /**
+     * Store and Forward warning
+     */
+    private boolean warnSF;
+
+    /**
+     * Chat timeout
+     */
+    private int chatTimeout;
+
+    /**
+     * Is-composing timeout
+     */
+    private int isComposingTimeout;
+
+    /**
+     * Max participants in a group chat
+     */
+    private int maxGroupChatParticipants;
+
+    /**
+     * Max length of a message in a single chat
+     */
+    private long maxMsgLengthSingleChat;
+
+    /**
+     * Max length of a message in a group chat
+     */
+    private long maxMsgLengthGroupChat;
+
+    /**
+     * Max group chat sessions
+     */
+    private int maxGroupChat;
+
+    /**
+     * SMS fallback
+     */
+    private boolean smsFallback;
+
+    /**
+     * Auto accept mode for single chat
+     */
+    private boolean autoAcceptSingleChat;
+
+    /**
+     * Auto accept mode for group chat
+     */
+    private boolean autoAcceptGroupChat;
+
+    /**
+     * Displayed delivery report
+     */
+    private boolean displayedDeliveryReport;
+
+    /**
+     * Max geoloc label length
+     */
+    private int maxGeolocLabelLength;
+
+    /**
+     * Geoloc expiraion time
+     */
+    private int geolocExpireTime;
+
+
+    /**
+     * Geoloc expiraion time
+     */
+    private boolean mIsImCapAlwaysOn;
+
+    /**
+     * Constructor
+     *
+     * @param chatSF Chat S&F
+     * @param groupChatSF Group chat S&F
+     * @param warnSF Store and Forward warning
+     * @param chatTimeout Chat timeout
+     * @param isComposingTimeout Is-composing timeout
+     * @param maxGroupChatParticipants Max participants in a group chat
+     * @param maxMsgLengthSingleChat Max length of a message in a single chat
+     * @param maxMsgLengthGroupChat Max length of a message in a group chat
+     * @param maxGroupChat Max group chats
+     * @param smsFallback SMS fallback
+     * @param autoAcceptSingleChat Auto accept mode for single chat
+     * @param autoAcceptGroupChat Auto accept mode for group chat
+     * @param displayedDeliveryReport Displayed delivery report
+     * @param maxGeolocLabelLength Max geoloc label length
+     * @param geolocExpireTime Geoloc expiration time
+     * @hide
+     */
+    public ChatServiceConfiguration(boolean warnSF, int chatTimeout, int isComposingTimeout,
+            int maxGroupChatParticipants, long maxMsgLengthSingleChat, long maxMsgLengthGroupChat,
+            int maxGroupChat, boolean smsFallback, boolean autoAcceptSingleChat, boolean autoAcceptGroupChat,
+            boolean displayedDeliveryReport, int maxGeolocLabelLength, int geolocExpireTime, boolean isImCapAlwaysOn) {
+        Logger.i(TAG, "ChatServiceConfiguration entry" + "warnSF " + warnSF + "chatTimeout " + chatTimeout + "isComposingTimeout " + isComposingTimeout +
+                "maxGroupChatParticipants" + maxGroupChatParticipants + "maxMsgLengthSingleChat " + maxMsgLengthSingleChat + "maxMsgLengthGroupChat" + maxMsgLengthGroupChat + "maxGroupChat " + maxGroupChat +
+                "smsFallback " + smsFallback + "autoAcceptSingleChat " + autoAcceptSingleChat + "autoAcceptGroupChat " + autoAcceptGroupChat + "displayedDeliveryReport " + displayedDeliveryReport +
+                "maxGeolocLabelLength " + maxGeolocLabelLength + "geolocExpireTime " + geolocExpireTime + "isImCapAlwaysOn " + isImCapAlwaysOn);
+        this.warnSF = warnSF;
+        this.chatTimeout = chatTimeout;
+        this.isComposingTimeout = isComposingTimeout;
+        this.maxGroupChatParticipants = maxGroupChatParticipants;
+        this.maxMsgLengthSingleChat = maxMsgLengthSingleChat;
+        this.maxMsgLengthGroupChat = maxMsgLengthGroupChat;
+        this.maxGroupChat = maxGroupChat;
+        this.smsFallback = smsFallback;
+        this.autoAcceptSingleChat = autoAcceptSingleChat;
+        this.autoAcceptGroupChat = autoAcceptGroupChat;
+        this.displayedDeliveryReport = displayedDeliveryReport;
+        this.maxGeolocLabelLength = maxGeolocLabelLength;
+        this.geolocExpireTime = geolocExpireTime;
+        this.mIsImCapAlwaysOn = isImCapAlwaysOn;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public ChatServiceConfiguration(Parcel source) {
+        this.chatTimeout = source.readInt();
+        this.isComposingTimeout = source.readInt();
+        this.maxGroupChatParticipants = source.readInt();
+        this.maxMsgLengthSingleChat = source.readLong();
+        this.maxMsgLengthGroupChat = source.readLong();
+        this.smsFallback = source.readInt() != 0;
+        this.autoAcceptSingleChat = source.readInt() != 0;
+        this.autoAcceptGroupChat = source.readInt() != 0;
+        this.displayedDeliveryReport = source.readInt() != 0;
+        this.warnSF = source.readInt() != 0;
+        this.maxGroupChat = source.readInt();
+        this.maxGeolocLabelLength = source.readInt();
+        this.geolocExpireTime = source.readInt();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(chatTimeout);
+        dest.writeInt(isComposingTimeout);
+        dest.writeInt(maxGroupChatParticipants);
+        dest.writeLong(maxMsgLengthSingleChat);
+        dest.writeLong(maxMsgLengthGroupChat);
+        dest.writeInt(smsFallback ? 1 : 0);
+        dest.writeInt(autoAcceptSingleChat ? 1 : 0);
+        dest.writeInt(autoAcceptGroupChat ? 1 : 0);
+        dest.writeInt(displayedDeliveryReport ? 1 : 0);
+        dest.writeInt(warnSF ? 1 : 0);
+        dest.writeInt(maxGroupChat);
+        dest.writeInt(maxGeolocLabelLength);
+        dest.writeInt(geolocExpireTime);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<ChatServiceConfiguration> CREATOR
+            = new Parcelable.Creator<ChatServiceConfiguration>() {
+        public ChatServiceConfiguration createFromParcel(Parcel source) {
+            return new ChatServiceConfiguration(source);
+        }
+
+        public ChatServiceConfiguration[] newArray(int size) {
+            return new ChatServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Does the UX should alert the user that messages are handled differently when
+     * the Store and Forward functionality is involved. It returns True if user should
+     * be informed when sending message to offline user.
+     *
+     * @return Boolean
+     */
+    public boolean isImWarnSf() {
+        return warnSF;
+    }
+
+    /**
+     * Returns the time after inactive chat session could be closed
+     *
+     * @return Timeout in seconds
+     */
+    public int getChatSessionTimeout() {
+        return chatTimeout;
+    }
+
+    /**
+     * Returns the Is-composing timeout value
+     *
+     * @return Timeout in seconds
+     */
+    public int getIsComposingTimeout() {
+        return isComposingTimeout;
+    }
+
+    /**
+     * Returns maximum number of participants in a group chat
+     *
+     * @return Number
+     */
+    public int getGroupChatMaxParticipantsNumber() {
+        return maxGroupChatParticipants;
+    }
+
+    /**
+     * Return maximum length of a single chat message
+     *
+     * @return Number of bytes
+     */
+    public long getSingleChatMessageMaxLength() {
+        return maxMsgLengthSingleChat;
+    }
+
+    /**
+     * Return maximum length of a group chat message
+     *
+     * @return Number of bytes
+     */
+    public long getGroupChatMessageMaxLength() {
+        return maxMsgLengthGroupChat;
+    }
+
+    /**
+     * Returns the max number of simultaneous group chats
+     *
+     * @return Number
+     */
+    public int getMaxGroupChats() {
+        return maxGroupChat;
+    }
+
+    /**
+     * Does the UX proposes automatically a SMS fallback in case of chat failure. It
+     * returns True if SMS fallback procedure is activated, else returns False.
+     *
+     * @return Boolean
+     */
+    public boolean isSmsFallback() {
+        return smsFallback;
+    }
+
+    /**
+     * Does auto accept mode activated for single chat
+     *
+     * @return Boolean
+     */
+    public boolean isChatAutoAcceptMode() {
+        return autoAcceptSingleChat;
+    }
+
+    /**
+     * Does auto accept mode activated for group chat
+     *
+     * @return Boolean
+     */
+    public boolean isGroupChatAutoAcceptMode() {
+        return autoAcceptGroupChat;
+    }
+
+    /**
+     * Does displayed delivery report activated on received chat messages
+     *
+     * @return Boolean
+     */
+    public boolean isDisplayedDeliveryReport() {
+        return displayedDeliveryReport;
+    }
+
+    /**
+     * Activates or deactivates the displayed delivery report on received chat messages
+     *
+     * @param state State
+     */
+    public void setDisplayedDeliveryReport(boolean state) {
+        this.displayedDeliveryReport = state;
+    }
+
+    /**
+     * Return maximum length of a geoloc label
+     *
+     * @return Number of bytes
+     */
+    public int getGeolocLabelMaxLength() {
+        return maxGeolocLabelLength;
+    }
+
+    /**
+     * Get geoloc expiration time
+     *
+     * @return Time in seconds
+     */
+    public int getGeolocExpirationTime() {
+        return geolocExpireTime;
+    }
+
+    /**
+     * Returns IM always on or not
+     *
+     * @return boolean value
+     */
+    public boolean isImCapAlwaysOn() {
+        return mIsImCapAlwaysOn;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ConferenceEventData.aidl b/src/java/org/gsma/joyn/chat/ConferenceEventData.aidl
new file mode 100644
index 0000000..33a8900
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ConferenceEventData.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Chat message object
+ */
+parcelable ConferenceEventData;
diff --git a/src/java/org/gsma/joyn/chat/ConferenceEventData.java b/src/java/org/gsma/joyn/chat/ConferenceEventData.java
new file mode 100644
index 0000000..97baeb9
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ConferenceEventData.java
@@ -0,0 +1,352 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Chat message
+ *
+ */
+public class ConferenceEventData implements Parcelable {
+    public static final String TAG = "TAPI-ConferenceEventData";
+
+    public static final class State {
+        public static final String FULL = "full";
+        public static final String PARTIAL = "partial";
+    }
+
+    private String state = "";
+
+    private String subject = "";
+
+    private String chairman = "";
+
+    private List<ConferenceUser> users;
+
+    public String getState() {
+        return state;
+    }
+
+    public void setState(String state) {
+        this.state = state;
+    }
+
+    public String getSubject() {
+        return subject;
+    }
+
+    public void setSubject(String subject) {
+        this.subject = subject;
+    }
+
+    public String getChairman() {
+        return chairman;
+    }
+
+    public void setChairman(String chairman) {
+        this.chairman = chairman;
+    }
+
+    public List<ConferenceUser> getUsers() {
+        return users;
+    }
+
+    public void setUsers(List<ConferenceUser> users) {
+        this.users = users;
+    }
+
+    public ConferenceEventData(
+            String state,
+            String subject,
+            String chairman,
+            List<ConferenceUser> users) {
+        this.state = state;
+        this.subject = subject;
+        this.chairman = chairman;
+        this.users = users;
+    }
+
+    public ConferenceEventData(Parcel source) {
+        this.state = source.readString();
+        this.subject = source.readString();
+        this.chairman = source.readString();
+
+        if (source.dataAvail() > 0) {
+            int size = source.readInt();
+            this.users = new ArrayList<ConferenceUser>(size);
+            for (int i = 0; i < size; i++ ) {
+                ConferenceUser user = (ConferenceUser)source.readParcelable(null);
+                this.users.add(user);
+            }
+        }
+    }
+
+    public ConferenceEventData() {
+    }
+
+    public void writeToParcel(Parcel dest, int arg1) {
+        dest.writeString(state);
+        dest.writeString(subject);
+        dest.writeString(chairman);
+        if (users != null) {
+            dest.writeInt(users.size());
+            for (ConferenceUser user : users) {
+                dest.writeParcelable(user, 0);
+            }
+        }
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<ConferenceEventData> CREATOR
+            = new Parcelable.Creator<ConferenceEventData>() {
+        public ConferenceEventData createFromParcel(Parcel source) {
+            return new ConferenceEventData(source);
+        }
+
+        public ConferenceEventData[] newArray(int size) {
+            return new ConferenceEventData[size];
+        }
+    };
+
+    public static class ConferenceUser implements Parcelable{
+        /**
+         * User State
+         */
+        private String state;
+
+        /**
+         * Status of the user
+         */
+        private String status;
+
+        /**
+         * disconnection method
+         */
+        private String method;
+
+        /**
+         * role of the user
+         */
+        private String role;
+
+        /**
+         * etype of the user
+         */
+        private String etype;
+
+        /**
+         * displayname of the user
+         */
+        private String displayName;
+
+        /**
+         * entity of the user
+         */
+        private String entity;
+
+
+        /**
+         * Constructor for outgoing message
+         *
+         * @param entity entity
+         * @param state state
+         * @param status status
+         * @param method method
+         * @param role role
+         * @param etype etype
+         * @param displayname displayname
+         *
+         */
+        public ConferenceUser(
+                String entity,
+                String state,
+                String status,
+                String method,
+                String role,
+                String etype,
+                String displayName) {
+            Logger.i(TAG, "ConferenceUser entry" +
+                    "entity=" + entity + " state=" + state + " status=" + status +
+                    " method=" + method + " role=" + role + " etype=" + etype +
+                    " displayName=" + displayName);
+            this.entity = entity;
+            this.state = state;
+            this.status = status;
+            this.method = method;
+            this.role = role;
+            this.etype = etype;
+            this.displayName = displayName;
+        }
+
+        /**
+         * Constructor
+         *
+         * @param source Parcelable source
+         * @hide
+         */
+        public ConferenceUser(Parcel source) {
+            this.entity = source.readString();
+            this.state = source.readString();
+            this.status = source.readString();
+            this.method = source.readString();
+            this.role = source.readString();
+            this.etype = source.readString();
+            this.displayName = source.readString();
+        }
+
+
+        /**
+         * Write parcelable object
+         *
+         * @param dest The Parcel in which the object should be written
+         * @param flags Additional flags about how the object should be written
+         * @hide
+         */
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeString(entity);
+            dest.writeString(state);
+            dest.writeString(status);
+            dest.writeString(method);
+            dest.writeString(role);
+            dest.writeString(etype);
+            dest.writeString(displayName);
+        }
+
+        /**
+         * Parcelable creator
+         *
+         * @hide
+         */
+        public static final Parcelable.Creator<ConferenceUser> CREATOR
+            = new Parcelable.Creator<ConferenceUser>() {
+            public ConferenceUser createFromParcel(Parcel source) {
+                return new ConferenceUser(source);
+            }
+
+            public ConferenceUser[] newArray(int size) {
+                return new ConferenceUser[size];
+            }
+        };
+
+        /**
+         * Returns the role
+         *
+         * @return role
+         */
+        public String getRole() {
+            return role;
+        }
+
+        /**
+         * Returns the state
+         *
+         * @return state
+         */
+        public String getState() {
+            return state;
+        }
+
+        /**
+         * Returns the status
+         *
+         * @return status
+         */
+        public String getStatus() {
+            return status;
+        }
+
+        /**
+         * Returns the method
+         *
+         * @return method
+         */
+        public String getDisconnectMethod() {
+            return method;
+        }
+
+        /**
+         * Returns the etype
+         *
+         * @return etype
+         */
+        public String getEtype() {
+            return etype;
+        }
+
+        /**
+         * Returns the entity
+         *
+         * @return entity
+         */
+        public String getEntity() {
+            return entity;
+        }
+
+        /**
+         * Returns the display name
+         *
+         * @return displayName
+         */
+        public String getDisplayName() {
+            return displayName;
+        }
+
+        @Override
+        public int describeContents() {
+            // TODO Auto-generated method stub
+            return 0;
+        }
+
+        public static class State {
+            public final static String FULL = "full";
+            public final static String PARTIAL = "partial";
+            public final static String DELETED = "deleted";
+        }
+        public static class Status {
+            public final static String CONNECTED = "connected";
+            public final static String DISCONNECTED = "disconnected";
+            public final static String PENDING = "pending";
+        }
+        public static class Method {
+            public final static String BOOTED = "booted";
+            public final static String DEPARTED = "departed";
+        }
+        public static class Role {
+            public final static String CHAIRMAN = "chairman";
+            public final static String PARTICIPANT = "participant";
+        }
+    }
+
+    @Override
+    public int describeContents() {
+        // TODO Auto-generated method stub
+        return 0;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ConferenceEventData/ConferenceUser.aidl b/src/java/org/gsma/joyn/chat/ConferenceEventData/ConferenceUser.aidl
new file mode 100644
index 0000000..a1d4c2e
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ConferenceEventData/ConferenceUser.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat.ConferenceEventData;
+
+/**
+ * Chat message object
+ */
+parcelable ConferenceUser;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/Geoloc.aidl b/src/java/org/gsma/joyn/chat/Geoloc.aidl
new file mode 100644
index 0000000..d5128bb
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/Geoloc.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Geoloc object
+ */
+parcelable Geoloc;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/Geoloc.java b/src/java/org/gsma/joyn/chat/Geoloc.java
new file mode 100644
index 0000000..b5e64ab
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/Geoloc.java
@@ -0,0 +1,239 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.io.Serializable;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Geolocation push info
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Geoloc implements Parcelable, Serializable {
+    private static final long serialVersionUID = 0L;
+
+    public static final String TAG = "TAPI-Geoloc";
+    /**
+     * Label associated to the geolocation
+     */
+    private String label;
+
+    /**
+     * Latitude
+     */
+    private double latitude;
+
+    /**
+     * Longitude
+     */
+    private double longitude;
+
+    /**
+     * Expiration date of the geolocation
+     */
+    private long expiration = 0L;
+
+    /**
+     * Accuracy (in meters)
+     */
+    private float accuracy = 0.0f;
+
+    /**
+     * Constructor
+     *
+     * @param label Label
+     * @param latitude Latitude
+     * @param longitude Longitude
+     * @param expiration Expiration time
+     * @hide
+     */
+    public Geoloc(String label, double latitude, double longitude, long expiration) {
+        Logger.i(TAG, "Geoloc entry" + "label=" + label + " latitude=" + latitude + " longitude=" + longitude +
+                " expiration=" + expiration);
+        this.label = label;
+        this.latitude = latitude;
+        this.longitude = longitude;
+        this.expiration = expiration;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param label Label
+     * @param latitude Latitude
+     * @param longitude Longitude
+     * @param expiration Expiration date
+     * @param accuracy Accuracy
+     * @hide
+     */
+    public Geoloc(String label, double latitude, double longitude, long expiration, float accuracy) {
+        this(label, latitude, longitude, expiration);
+        Logger.i(TAG, "accuracy=" + accuracy);
+        this.accuracy = accuracy;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public Geoloc(Parcel source) {
+        this.label = source.readString();
+        this.latitude = source.readDouble();
+        this.longitude = source.readDouble();
+        this.expiration = source.readLong();
+        this.accuracy = source.readFloat();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(label);
+        dest.writeDouble(latitude);
+        dest.writeDouble(longitude);
+        dest.writeLong(expiration);
+        dest.writeFloat(accuracy);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<Geoloc> CREATOR = new Parcelable.Creator<Geoloc>() {
+        public Geoloc createFromParcel(Parcel source) {
+            return new Geoloc(source);
+        }
+
+        public Geoloc[] newArray(int size) {
+            return new Geoloc[size];
+        }
+    };
+
+    /**
+     * Returns the label
+     *
+     * @return Label
+     */
+    public String getLabel() {
+        return label;
+    }
+
+    /**
+     * Set the label
+     *
+     * @param label Label
+     */
+    public void setLabel(String label) {
+        this.label = label;
+    }
+
+    /**
+     * Returns the latitude
+     *
+     * @return Latitude
+     */
+    public double getLatitude() {
+        return latitude;
+    }
+
+    /**
+     * Set the latitude
+     *
+     * @param latitude Latitude
+     */
+    public void setLatitude(double latitude) {
+        this.latitude = latitude;
+    }
+
+    /**
+     * Returns the longitude
+     *
+     * @return Longitude
+     */
+    public double getLongitude() {
+        return longitude;
+    }
+
+    /**
+     * Set the longitude
+     *
+     * @param longitude Longitude
+     */
+    public void setLongitude(double longitude) {
+        this.longitude = longitude;
+    }
+
+    /**
+     * Returns the expiration date of the geolocation
+     *
+     * @return Expiration date. 0 means no expiration date has been defined.
+     */
+    public long getExpiration() {
+        return expiration;
+    }
+
+    /**
+     * Set the expiration date of the geolocation
+     *
+     * @param expiration Expiration
+     */
+    public void setExpiration(long expiration) {
+        this.expiration = expiration;
+    }
+
+    /**
+     * Returns the accuracy
+     *
+     * @return Accuracy in meters. 0 means no accuracy has been defined.
+     */
+    public float getAccuracy() {
+        return accuracy;
+    }
+
+    /**
+     * Set the accuracy
+     *
+     * @param accuracy Accuracy in meters
+     */
+    public void setAcuracy(float accuracy) {
+        this.accuracy = accuracy;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/GeolocMessage.aidl b/src/java/org/gsma/joyn/chat/GeolocMessage.aidl
new file mode 100644
index 0000000..2636449
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GeolocMessage.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Geoloc message object
+ */
+parcelable GeolocMessage;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/GeolocMessage.java b/src/java/org/gsma/joyn/chat/GeolocMessage.java
new file mode 100644
index 0000000..5f9bfe0
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GeolocMessage.java
@@ -0,0 +1,123 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.Date;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Geoloc push message
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GeolocMessage extends ChatMessage implements Parcelable {
+    /**
+     * MIME type
+     */
+    public final static String MIME_TYPE = "application/geoloc";
+
+    public static final String TAG = "TAPI-GeolocMessage";
+    /**
+     * Geoloc info
+     */
+    private Geoloc geoloc = null;
+
+    /**
+     * Constructor for outgoing message
+     *
+     * Constructor for outgoing message
+     *
+     * @param messageId Message Id
+     * @param contact Contact
+     * @param geoloc Geolocation info
+     * @param receiptAt Receipt date
+     * @param displayedReportRequested Flag indicating if a displayed report is requested
+     * @hide
+     */
+    public GeolocMessage(String messageId, String remote, Geoloc geoloc, Date receiptAt, boolean imdnDisplayedRequested) {
+        super(messageId, remote, null, receiptAt, imdnDisplayedRequested, null);
+        Logger.i(TAG, "GeolocMessage entry geoloc =" + geoloc);
+        this.geoloc = geoloc;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public GeolocMessage(Parcel source) {
+        super(source);
+
+        this.geoloc = new Geoloc(source);
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        super.writeToParcel(dest, flags);
+
+        geoloc.writeToParcel(dest, flags);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<GeolocMessage> CREATOR
+            = new Parcelable.Creator<GeolocMessage>() {
+        public GeolocMessage createFromParcel(Parcel source) {
+            return new GeolocMessage(source);
+        }
+
+        public GeolocMessage[] newArray(int size) {
+            return new GeolocMessage[size];
+        }
+    };
+
+    /**
+     * Get geolocation info
+     *
+     * @return Geoloc object
+     * @see Geoloc
+     */
+    public Geoloc getGeoloc() {
+        return geoloc;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/GroupChat.java b/src/java/org/gsma/joyn/chat/GroupChat.java
new file mode 100644
index 0000000..f3634c7
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GroupChat.java
@@ -0,0 +1,696 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.ft.FileTransfer;
+import org.gsma.joyn.ft.FileTransferListener;
+import org.gsma.joyn.ft.IFileTransfer;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * Group chat
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GroupChat {
+
+    public static final String TAG = "TAPI-GroupChat";
+    /**
+     * Group chat state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Chat invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Chat invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Chat is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Chat has been terminated
+         */
+        public final static int TERMINATED = 4;
+
+        /**
+         * Chat has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Chat has been closed by the user. A user which has closed a
+         * conversation voluntary can't rejoin it afterward.
+         */
+        public final static int CLOSED_BY_USER = 6;
+
+        /**
+         * Chat has failed
+         */
+        public final static int FAILED = 7;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the group chat
+     */
+    public static class Direction {
+        /**
+         * Incoming chat
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing chat
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * State of the group chat conference Notify
+     */
+    public static class ConfState {
+
+        public final static String FULL = "full";
+        public final static String PARTIAL = "partial";
+    }
+
+    /**
+     * Status of group chat addparticipants
+     */
+    public static class ParticipantStatus {
+        /**
+         * Successfuly added
+         */
+        public static final int SUCCESS = 0;
+
+        /**
+         * Nota added
+         */
+        public static final int FAIL = 1;
+    }
+
+     /**
+     * Direction of the group chat
+     */
+    public static class MessageState {
+        /**
+         * Message being sent
+         */
+        public static final int SENDING = 0;
+
+        /**
+         * Message sent
+         */
+        public static final int SENT = 1;
+
+        /**
+         * Message delivered to remote
+         */
+        public static final int DELIVERED = 2;
+
+        /**
+         * Message sending failed
+         */
+        public static final int FAILED = 3;
+    }
+
+     /**
+     * Direction of the group chat
+     */
+    public static class ErrorCodes {
+        /**
+         * Message being sent
+         */
+        public static final int TIMEOUT = 1;
+
+        /**
+         * Message sent
+         */
+        public static final int UNKNOWN = 2;
+
+        /**
+         * Message delivered to remote
+         */
+        public static final int INTERNAL_EROR = 3;
+
+        /**
+         * Message sending failed
+         */
+        public static final int OUT_OF_SIZE = 4;
+    }
+
+    /**
+     * Error codes for Failed reason
+     */
+    public static class ReasonCode {
+        /**
+         * successful
+         */
+        public static final int SUCCESSFUL = 1;
+
+        /**
+         * Unknown
+         */
+        public static final int UNKNOWN = 2;
+
+        /**
+         * internal error
+         */
+        public static final int INTERNAL_ERROR = 3;
+
+        /**
+         * Time out
+         */
+        public static final int TIME_OUT = 4;
+    }
+
+    /**
+     * Group chat error
+     */
+    public static class Error {
+        /**
+         * Group chat has failed
+         */
+        public final static int CHAT_FAILED = 0;
+
+        /**
+         * Group chat invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        /**
+         * Chat conversation not found
+         */
+        public final static int CHAT_NOT_FOUND = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Group chat interface
+     */
+    private IGroupChat chatInf;
+
+    /**
+     * Constructor
+     *
+     * @param chatIntf Group chat interface
+     */
+    GroupChat(IGroupChat chatIntf) {
+        this.chatInf = chatIntf;
+    }
+
+    /**
+     * Returns the chat ID
+     *
+     * @return Chat ID
+     * @throws JoynServiceException
+     */
+    public String getChatId() throws JoynServiceException {
+        Logger.i(TAG, "getChatId entry " + chatInf);
+        try {
+            return chatInf.getChatId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the chat ID
+     *
+     * @return Session ID
+     * @throws JoynServiceException
+     */
+    public String getChatSessionId() throws JoynServiceException {
+        Logger.i(TAG, "getChatSessionId entry " + chatInf);
+        try {
+            return chatInf.getChatSessionId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the group chat (incoming or outgoing)
+     *
+     * @return Direction
+     * @see GroupChat.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        Logger.i(TAG, "getDirection entry " + chatInf);
+        try {
+            return chatInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the group chat
+     *
+     * @return State
+     * @see GroupChat.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        Logger.i(TAG, "getState() entry " + chatInf);
+        try {
+            return chatInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the group chat
+     *
+     * @param messageId Message Id
+     * @return State
+     * @see GroupChat.State
+     * @throws JoynServiceException
+     */
+    public int getMessageState(String messageId) throws JoynServiceException {
+        Logger.i(TAG, "getState() entry " + chatInf + "Message Id = " + messageId);
+        try {
+            //return chatInf.getState();
+            return chatInf.getMessageState(messageId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact() entry " + chatInf);
+        try {
+            return chatInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the subject of the group chat
+     *
+     * @return Subject
+     * @throws JoynServiceException
+     */
+    public String getSubject() throws JoynServiceException {
+        Logger.i(TAG, "getSubject() entry " + chatInf);
+        try {
+            return chatInf.getSubject();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the list of connected participants. A participant is identified
+     * by its MSISDN in national or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @return List of participants
+     * @throws JoynServiceException
+     */
+    public Set<String> getParticipants() throws JoynServiceException {
+        Logger.i(TAG, "getParticipants() entry " + chatInf);
+        try {
+            return new HashSet<String>(chatInf.getParticipants());
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the list of connected participants. A participant is identified
+     * by its MSISDN in national or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @return List of participants
+     * @throws JoynServiceException
+     */
+    public Set<String> getAllParticipants() throws JoynServiceException {
+        Logger.i(TAG, "getAllParticipants() entry " + chatInf);
+        try {
+            return new HashSet<String>(chatInf.getAllParticipants());
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts chat invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        Logger.i(TAG, "acceptInvitation() entry " + chatInf);
+        try {
+            chatInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects chat invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        Logger.i(TAG, "rejectInvitation() entry " + chatInf);
+        try {
+            chatInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a text message to the group
+     *
+     * @param text Message
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendMessage(String text) throws JoynServiceException {
+        Logger.i(TAG, "sendMessage() entry " + text);
+        try {
+            return chatInf.sendMessage(text);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a emoticons message to the group
+     *
+     * @param text Message
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendEmoticonsMessage(String text) throws JoynServiceException {
+        Logger.i(TAG, "sendEmoticonsMessage() entry " + text);
+        try {
+            return chatInf.sendEmoticonsMessage(text);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a geoloc message
+     *
+     * @param geoloc Geoloc info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendGeoloc(Geoloc geoloc) throws JoynServiceException {
+        Logger.i(TAG, "sendGeoloc() entry " + geoloc);
+        try {
+            return chatInf.sendGeoloc(geoloc);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Transfers a file to participants. The parameter filename contains the complete
+     * path of the file to be transferred.
+     *
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer sendFile(String filename, String fileicon, FileTransferListener listener) throws JoynServiceException {
+        Logger.i(TAG, "sendFile() entry filename=" + filename + " fileicon=" + fileicon + " listener =" + listener);
+        try {
+            IFileTransfer ftIntf = chatInf.sendFile(filename, fileicon, listener);
+            if (ftIntf != null) {
+                return new FileTransfer(ftIntf);
+            } else {
+                return null;
+            }
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends an Is-composing event. The status is set to true when typing
+     * a message, else it is set to false.
+     *
+     * @param status Is-composing status
+     * @throws JoynServiceException
+     */
+    public void sendIsComposingEvent(boolean status) throws JoynServiceException {
+        Logger.i(TAG, "sendIsComposingEvent() entry " + status);
+        try {
+            chatInf.sendIsComposingEvent(status);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * @param msgId message Id of message
+     * @throws JoynServiceException
+     */
+    public int resendMessage(String msgId) throws JoynServiceException  {
+        Logger.i(TAG, "resendMessage msgId " + msgId);
+        try {
+            return chatInf.resendMessage(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a displayed delivery report for a given message ID
+     *
+     * @param msgId Message ID
+     * @return State of the message
+     * @throws JoynServiceException
+     */
+    public void sendDisplayedDeliveryReport(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "sendDisplayedDeliveryReport() entry " + msgId);
+        try {
+            chatInf.sendDisplayedDeliveryReport(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds participants to a group chat
+     *
+     * @param participants List of participants
+     * @throws JoynServiceException
+     */
+    public void addParticipants(Set<String> participants) throws JoynServiceException {
+        Logger.i(TAG, "addParticipants() entry " + participants);
+        try {
+            chatInf.addParticipants(new ArrayList<String>(participants));
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the max number of participants in the group chat. This limit is
+     * read during the conference event subscription and overrides the provisioning
+     * parameter.
+     *
+     * @return Number
+     * @throws JoynServiceException
+     */
+    public int getMaxParticipants() throws JoynServiceException {
+        Logger.i(TAG, "getMaxParticipants() entry ");
+        try {
+            return chatInf.getMaxParticipants();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Quits a group chat conversation. The conversation will continue between
+     * other participants if there are enough participants.
+     *
+     * @throws JoynServiceException
+     */
+    public void quitConversation() throws JoynServiceException {
+        Logger.i(TAG, "quitConversation() entry ");
+        try {
+            chatInf.quitConversation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on chat events
+     *
+     * @param listener Group chat event listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(GroupChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener() entry " + listener);
+
+        try {
+            chatInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener on chat events
+     *
+     * @param listener Group chat event listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(GroupChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener() entry " + listener);
+        try {
+            chatInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Set the new chairman(chairman privilege).
+     *
+     * @param newChairman new chairman of the group, should be a group member
+     * @throws JoynServiceException
+     */
+    public void transferChairman(String newChairman) throws JoynServiceException {
+        Logger.i(TAG, "transferChairman() entry " + newChairman);
+        try {
+            chatInf.transferChairman(newChairman);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * modify subject of group(chairman privilege).
+     *
+     * @param newSubject new subject string
+     * @throws JoynServiceException
+     */
+    public void modifySubject(String newSubject) throws JoynServiceException {
+        Logger.i(TAG, "modifySubject() entry " + newSubject);
+        try {
+            chatInf.modifySubject(newSubject);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * modify nickname of participant.
+     *
+     * @param newNickname new nick name of participant
+     * @throws JoynServiceException
+     */
+    public void modifyMyNickName(String newNickname) throws JoynServiceException {
+        Logger.i(TAG, "modifyMyNickName() entry " + newNickname);
+        try {
+            chatInf.modifyMyNickName(newNickname);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * remove set of participants(chairman privilege).
+     *
+     * @param participants list of participants to be removed
+     * @throws JoynServiceException
+     */
+    public void removeParticipants(List<String> participants) throws JoynServiceException {
+        Logger.i(TAG, "removeParticipants() entry " + participants);
+        try {
+            chatInf.removeParticipants(participants);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * chairman abort(leave) the group, Group session will abort
+     *
+     * @throws JoynServiceException
+     */
+    public void abortConversation() throws JoynServiceException {
+        Logger.i(TAG, "abortConversation() entry ");
+        try {
+            chatInf.abortConversation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * If myself chairman of the group
+     *
+     * @return true/false
+     * @throws JoynServiceException
+     */
+    public boolean isMeChairman() throws JoynServiceException {
+        Logger.i(TAG, "isMeChairman() entry ");
+        boolean flag = false;
+        try {
+            flag = chatInf.isMeChairman();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+        return flag;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/GroupChatIntent.java b/src/java/org/gsma/joyn/chat/GroupChatIntent.java
new file mode 100644
index 0000000..b695060
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GroupChatIntent.java
@@ -0,0 +1,74 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+/**
+ * Intent for group chat conversation
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GroupChatIntent {
+    /**
+     * Broadcast action: a new group chat invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_CHAT_ID} containing the unique ID of the chat conversation.
+     * <li> {@link #EXTRA_SUBJECT} containing the subject associated to the conversation.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.chat.action.NEW_GROUP_CHAT";
+
+    /**
+     * Broadcast action: a new group chat invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CHAT_ID} containing the unique ID of the chat conversation.
+     * <li> {sessionId} containing the session Id of the group chat.
+     * </ul>
+     */
+    public final static String ACTION_SESSION_REPLACED = "org.gsma.joyn.chat.action.REPLACED_GROUP_CHAT";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation (extracted from the SIP address)
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the chat conversation
+     */
+    public final static String EXTRA_CHAT_ID = "chatId";
+
+    /**
+     * Subject associated to the conversation (optional)
+     */
+    public final static String EXTRA_SUBJECT = "subject";
+
+    /**
+     * Session identitiy to the conversation
+     */
+    public final static String EXTRA_SESSION_IDENTITY = "sessionIdentity";
+}
diff --git a/src/java/org/gsma/joyn/chat/GroupChatListener.java b/src/java/org/gsma/joyn/chat/GroupChatListener.java
new file mode 100644
index 0000000..4908cdc
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GroupChatListener.java
@@ -0,0 +1,301 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.List;
+import org.gsma.joyn.chat.ConferenceEventData.ConferenceUser;
+
+
+/**
+ * Group chat event listener
+
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class GroupChatListener extends IGroupChatListener.Stub {
+    /**
+     * Callback called when the session is well established and messages
+     * may be exchanged with the group of participants
+     */
+    public abstract void onSessionStarted();
+
+    /**
+     * Callback called when the session has been aborted or terminated
+     */
+    public abstract void onSessionAborted();
+
+    /**
+     * Callback called when the session has failed
+     *
+     * @param error Error
+     * @see GroupChat.Error
+     */
+    public abstract void onSessionError(int error);
+
+    /**
+     * Callback called when a new message has been received
+     *
+     * @param message New chat message
+     * @see ChatMessage
+     */
+    public abstract void onNewMessage(ChatMessage message);
+
+    /**
+     * Callback called when a new geoloc has been received
+     *
+     * @param message Geoloc message
+     * @see GeolocMessage
+     */
+    public abstract void onNewGeoloc(GeolocMessage message);
+
+    /**
+     * Callback called when a message has been delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageDelivered(String msgId);
+
+    /**
+     * Callback called when a message has been displayed by the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageDisplayed(String msgId);
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageFailed(String msgId);
+
+    /**
+     * Callback called when an Is-composing event has been received. If the
+     * remote is typing a message the status is set to true, else it is false.
+     *
+     * @param contact Contact
+     * @param status Is-composing status
+     */
+    public abstract void onComposingEvent(String contact, boolean status);
+
+    /**
+     * Callback called when a new participant has joined the group chat
+     *
+     * @param contact Contact
+     * @param contactDisplayname Remote Contact display name
+     */
+    public abstract void onParticipantJoined(String contact, String contactDisplayname);
+
+    /**
+     * Callback called when a participant has left voluntary the group chat
+     *
+     * @param contact Contact
+     */
+    public abstract void onParticipantLeft(String contact);
+
+    /**
+     * Callback called when a participant is disconnected from the group chat
+     *
+     * @param contact Contact
+     */
+    public abstract void onParticipantDisconnected(String contact);
+
+    /**
+     * Callback called when the session has been aborted by chairman
+     */
+    public void onSessionAbortedbyChairman() {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has been delivered to the remote
+     *
+     * @param msgId Message ID
+     * @param contact Remote contact
+     */
+    public void onReportMessageDeliveredContact(String msgId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has been displayed by the remote
+     *
+     * @param msgId Message ID
+     * @param contact Remote contact
+     */
+    public void onReportMessageDisplayedContact(String msgId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     * @param contact Remote contact
+     */
+    public void onReportMessageFailedContact(String msgId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     * @param errtype Error cause for failure
+     * @param statusCode Status code associated with failure
+     */
+    public void onReportFailedMessage(String msgId, int errtype, String statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has been sent to remote
+     *
+     * @param msgId Message ID
+     */
+    public void onReportSentMessage(String msgId) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a group chat is dissolved
+     *
+     */
+    public void onGroupChatDissolved() {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called to inform the result of invite participants
+     *
+     * @param errtype Error cause for failure
+     * @param statusCode Status code associated with failure
+     */
+    public void onInviteParticipantsResult(int errType, String statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when new chairman is successfully changed by current chairman
+     * (Callback only received by chairman)
+     * @param errType errorType
+     */
+    public void onSetChairmanResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when chairman is changed by current chairman
+     * (Callback received by every user of group)
+     * @param newChairman new chairman
+     */
+    public void onChairmanChanged(String newChairman) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when subject is modified
+     * (Callback only received by chairman)
+     * @param errType errorType
+     */
+    public void onModifySubjectResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when subject is changed
+     * (Callback received by every user of group)
+     * @param newSubject new subject
+     */
+    public void onSubjectChanged(String newSubject) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when nickname is modified
+     * (callback received only by user who modified the nickname)
+     * @param errType errorType
+     */
+    public void onModifyNickNameResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when nickname is changed
+     * (callback received by every group member)
+     * @param contact contact who modified nick name
+     */
+    public void onNickNameChanged(String contact, String newNickName) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when participants are removed
+     * (Callback only received by chairman)
+     * @param errType errorType
+     * @param statusCode status Code
+     * @param participant participant removed
+     */
+    public void onRemoveParticipantResult(int errType, int statusCode, String participant) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called participant is kicked out(removed) by chairman
+     * (Callback received by removed participant)
+     * @param from who kicked out
+     */
+    public void onReportMeKickedOut(String from) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called participant is kicked out(removed) by chairman
+     * (Callback received by other than removed participants)
+     * @param contact kicked out participant
+     */
+    public void onReportParticipantKickedOut(String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called chairman has successfully aborted the group
+     * (Callback only received by chairman)
+     * @param errType errorType
+     */
+    public void onAbortConversationResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called user has left the group successfully
+     * (Callback received by user who left the group)
+     * @param errType errorType
+     */
+    public void onQuitConversationResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when SIP notify is received in group conference
+     * (Callback received for add participant, remove participant, User left, nick name change)
+     * @param confState conference state
+     */
+    public void onConferenceNotify(String confState, List<ConferenceUser> users) {
+        // default implementation for TAPI extension
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/GroupChatSyncingListener.java b/src/java/org/gsma/joyn/chat/GroupChatSyncingListener.java
new file mode 100644
index 0000000..2516e20
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GroupChatSyncingListener.java
@@ -0,0 +1,21 @@
+package org.gsma.joyn.chat;
+
+import java.util.List;
+
+/**
+ * Group chat event listener
+ */
+public abstract class GroupChatSyncingListener extends IGroupChatSyncingListener.Stub {
+    /**
+     */
+    public abstract void onSyncStart(int goupCount);
+
+    /**
+     */
+    public abstract void onSyncInfo(String chatId, ConferenceEventData info);
+
+    /**
+     */
+    public abstract void onSyncDone(int result);
+
+}
diff --git a/src/java/org/gsma/joyn/chat/IChat.aidl b/src/java/org/gsma/joyn/chat/IChat.aidl
new file mode 100644
index 0000000..245b2c7
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IChat.aidl
@@ -0,0 +1,60 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.IChatListener;
+import org.gsma.joyn.chat.ISpamReportListener;
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Chat interface
+ */
+interface IChat {
+	String getRemoteContact();
+	
+
+	String sendMessage(in String message);
+	
+	void sendDisplayedDeliveryReport(in String msgId);
+	
+	void sendIsComposingEvent(in boolean status);
+	
+	void addEventListener(in IChatListener listener);
+	
+	void removeEventListener(in IChatListener listener);
+
+	void addSpamReportListener(in ISpamReportListener listener);
+	
+	void removeSpamReportListener(in ISpamReportListener listener);
+
+	String sendGeoloc(in Geoloc geoloc);
+	
+	int resendMessage(in String msgId);
+	
+	int reSendMultiMessageByPagerMode(in String msgId);
+	
+	String sendMessageByLargeMode(in String message);
+	
+        String sendCloudMessageByLargeMode(in String message);
+	
+	String sendPublicAccountMessageByLargeMode(in String message);
+	
+	String sendMessageByPagerMode(in String message ,in boolean isBurnMessage , in boolean isPublicMessage , in boolean isMultiMessage , in boolean isPayEmoticon,in List<String> participants);
+	
+	void sendSpamMessageByPagerMode(in String contact, in String messageId) ;
+	
+	String sendOnetoMultiMessage(in String message, in List<String> participants);
+	
+	String sendOnetoMultiEmoticonsMessage(in String message, in List<String> participants);
+		
+	//String sendOnetoMultiCloudMessage(in String message, in List<String> participants);
+	
+	String sendEmoticonShopMessage(in String message);
+	String sendCloudMessage(in String message);
+	
+	String sendPagerModeBurnMessage(in String message);
+	
+	String sendLargeModeBurnMessage(in String message);
+	
+	int getState(in String msgId);
+	
+	void sendBurnDeliveryReport(in String msgId);
+}
diff --git a/src/java/org/gsma/joyn/chat/IChatListener.aidl b/src/java/org/gsma/joyn/chat/IChatListener.aidl
new file mode 100644
index 0000000..3e6d495
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IChatListener.aidl
@@ -0,0 +1,30 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.ChatMessage;
+import org.gsma.joyn.chat.GeolocMessage;
+
+/**
+ * Chat event listener
+ */
+interface IChatListener {
+	void onNewMessage(in ChatMessage message);
+
+	void onNewGeoloc(in GeolocMessage message);
+
+	void onReportMessageDelivered(in String msgId);
+
+	void onReportMessageDisplayed(in String msgId);
+
+	void onReportMessageFailed(in String msgId);
+
+	void onComposingEvent(in boolean status);
+
+  void onReportFailedMessage(in String msgId,in int errtype,in String statusCode);
+	
+	void onReportSentMessage(in String msgId);
+	
+	void onReportDeliveredMessage(in String msgId);
+	
+	void onNewBurnMessageArrived(in ChatMessage message);
+	
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/IChatService.aidl b/src/java/org/gsma/joyn/chat/IChatService.aidl
new file mode 100644
index 0000000..188a00c
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IChatService.aidl
@@ -0,0 +1,73 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.chat.IChatListener;
+import org.gsma.joyn.chat.IChat;
+import org.gsma.joyn.chat.IGroupChatListener;
+import org.gsma.joyn.chat.IGroupChat;
+import org.gsma.joyn.chat.INewChatListener;
+import org.gsma.joyn.chat.ISpamReportListener;
+import org.gsma.joyn.chat.IGroupChatSyncingListener;
+import org.gsma.joyn.chat.ChatServiceConfiguration;
+
+/**
+ * Chat service API
+ */
+interface IChatService {
+	boolean isServiceRegistered();
+    
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	ChatServiceConfiguration getConfiguration();
+    
+	IChat openSingleChat(in String contact, in IChatListener listener);
+	
+    IChat openMultiChat(in List<String> participants, in IChatListener listener);
+
+	IChat initPublicAccountChat(in String contact, in IChatListener listener);
+
+	IGroupChat initiateGroupChat(in List<String> contacts, in String subject, in IGroupChatListener listener);
+    
+	String sendOne2MultiMessage(in List<String> contacts, in String messages, in IGroupChatListener listener);
+        
+	int resendOne2MultiMessage(in String megId, in IGroupChatListener listener);
+    
+        String sendOne2MultiCloudMessageLargeMode(in List<String> contacts, in String messages, in IGroupChatListener listener);
+    
+	IGroupChat rejoinGroupChat(in String chatId);
+    
+	IGroupChat rejoinGroupChatId(in String chatId, in String rejoinId);
+    
+	IGroupChat restartGroupChat(in String chatId);
+
+    void syncAllGroupChats(in IGroupChatSyncingListener listener);
+    void syncGroupChat(in String chatId, in IGroupChatSyncingListener listener);
+    
+	void addEventListener(in INewChatListener listener);
+    
+	void removeEventListener(in INewChatListener listener);
+    
+	void initiateSpamReport(String contact, String messageId);
+	
+	void addSpamReportListener(in ISpamReportListener listener);
+	
+	void removeSpamReportListener(in ISpamReportListener listener);
+    
+	IChat getChat(in String chatId);
+
+	IChat getPublicAccountChat(in String chatId);
+
+	List<IBinder> getChats();
+
+	List<IBinder> getGroupChats();
+    
+	IGroupChat getGroupChat(in String chatId);
+	
+	void blockGroupMessages(in String chatId, in boolean flag);
+	
+	int getServiceVersion();
+	
+	boolean isImCapAlwaysOn();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/IGroupChat.aidl b/src/java/org/gsma/joyn/chat/IGroupChat.aidl
new file mode 100644
index 0000000..ed1df5b
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IGroupChat.aidl
@@ -0,0 +1,72 @@
+package org.gsma.joyn.chat;
+
+import java.util.List;
+
+import org.gsma.joyn.chat.IGroupChatListener;
+import org.gsma.joyn.chat.Geoloc;
+import org.gsma.joyn.ft.IFileTransfer;
+import org.gsma.joyn.ft.IFileTransferListener;
+
+
+/**
+ * Group chat interface
+ */
+interface IGroupChat {
+	String getChatId();
+	
+	String getChatSessionId();
+
+	int getDirection();
+	
+	int getState();	
+
+	String getSubject();	
+
+	List<String> getParticipants();
+	
+	List<String> getAllParticipants();
+	
+	void acceptInvitation();
+	
+	void rejectInvitation();
+	
+	String sendMessage(in String text);
+
+	String sendEmoticonsMessage(in String text);
+
+	void sendIsComposingEvent(in boolean status);
+	
+	void sendDisplayedDeliveryReport(in String msgId);
+
+	void addParticipants(in List<String> participants);
+	
+	int getMaxParticipants();
+	
+	int getMessageState(in String messageId);
+	
+	int resendMessage(in String msgId);
+	
+	void quitConversation();
+	
+	void addEventListener(in IGroupChatListener listener);
+	
+	void removeEventListener(in IGroupChatListener listener);
+	
+	String getRemoteContact();
+
+	String sendGeoloc(in Geoloc geoloc);
+
+	IFileTransfer sendFile(in String filename, in String fileicon, in IFileTransferListener listener);
+	
+	void transferChairman(in String newChairman);
+	
+	void modifySubject(in String newSubject);
+	
+	void modifyMyNickName(in String newNickname);
+	
+	void removeParticipants(in List<String> participants);
+	
+	void abortConversation();
+	
+	boolean isMeChairman();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/IGroupChatListener.aidl b/src/java/org/gsma/joyn/chat/IGroupChatListener.aidl
new file mode 100644
index 0000000..3143f1e
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IGroupChatListener.aidl
@@ -0,0 +1,76 @@
+package org.gsma.joyn.chat;
+
+import java.util.List;
+
+import org.gsma.joyn.chat.ChatMessage;
+import org.gsma.joyn.chat.GeolocMessage;
+import org.gsma.joyn.chat.ConferenceEventData.ConferenceUser;
+
+/**
+ * Group chat event listener
+ */
+interface IGroupChatListener {
+	void onSessionStarted();
+	
+	void onSessionAborted();
+
+	void onSessionAbortedbyChairman();
+
+	void onSessionError(in int reason);
+		
+	void onNewMessage(in ChatMessage message);
+
+	void onNewGeoloc(in GeolocMessage message);
+
+	void onReportMessageDeliveredContact(in String msgId,in String contact);
+
+	void onReportMessageDisplayedContact(in String msgId,in String contact);
+
+	void onReportMessageFailedContact(in String msgId,in String contact);
+	
+	void onReportMessageDelivered(in String msgId);
+
+	void onReportMessageDisplayed(in String msgId);
+
+	void onReportMessageFailed(in String msgId);
+	
+	void onReportFailedMessage(in String msgId,in int errtype,in String statusCode);
+		
+	void onReportSentMessage(in String msgId);
+
+	void onGroupChatDissolved();
+	
+	void onInviteParticipantsResult(in int errType,in String statusCode);
+	
+	void onComposingEvent(in String contact, in boolean status);
+	
+	void onParticipantJoined(in String contact, in String contactDisplayname);
+	
+	void onParticipantLeft(in String contact);
+
+	void onParticipantDisconnected(in String contact);
+
+    void onSetChairmanResult(in int errType, in int statusCode);
+	
+	void onChairmanChanged(in String newChairman);
+	
+	void onModifySubjectResult(in int errType, in int statusCode);
+	
+	void onSubjectChanged(in String newSubject);
+	
+	void onModifyNickNameResult(in int errType, in int statusCode);
+    
+    void onNickNameChanged(in String contact, in String newNickName);
+	
+	void onRemoveParticipantResult(in int errType, in int statusCode, in String participant);
+	
+	void onReportMeKickedOut(in String from);
+	
+	void onReportParticipantKickedOut(in String contact);
+	
+	void onAbortConversationResult(in int errType, in int statusCode);
+	
+	void onQuitConversationResult(in int errType, in int statusCode);
+	
+	void onConferenceNotify(in String confState, in List<ConferenceUser> users);
+}
diff --git a/src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl b/src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl
new file mode 100644
index 0000000..df5e312
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl
@@ -0,0 +1,12 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.ConferenceEventData;
+
+/**
+ * Conference info listener
+ */
+interface IGroupChatSyncingListener {
+    void onSyncStart(in int count);
+    void onSyncInfo(in String chatId, in ConferenceEventData info);
+    void onSyncDone(in int result);
+}
diff --git a/src/java/org/gsma/joyn/chat/INewChatListener.aidl b/src/java/org/gsma/joyn/chat/INewChatListener.aidl
new file mode 100644
index 0000000..806c284
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/INewChatListener.aidl
@@ -0,0 +1,12 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.ChatMessage;
+
+/**
+ * New chat invitation event listener
+ */
+interface INewChatListener {
+	void onNewSingleChat(in String contact, in ChatMessage message);
+	
+	void onNewGroupChat(in String chatId);
+}
diff --git a/src/java/org/gsma/joyn/chat/IPublicAccountChat.aidl b/src/java/org/gsma/joyn/chat/IPublicAccountChat.aidl
new file mode 100644
index 0000000..f4e84bc
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IPublicAccountChat.aidl
@@ -0,0 +1,11 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.IChatListener;
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Public Account Chat interface
+ */
+interface IPublicAccountChat {
+	
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/ISpamReportListener.aidl b/src/java/org/gsma/joyn/chat/ISpamReportListener.aidl
new file mode 100644
index 0000000..f16abad
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ISpamReportListener.aidl
@@ -0,0 +1,10 @@
+package org.gsma.joyn.chat;
+
+/**
+ * New chat invitation event listener
+ */
+interface ISpamReportListener {
+	void onSpamReportSuccess( String contact, String msgId);
+	
+	void onSpamReportFailed( String contact, String msgId, int errorCode);
+}
diff --git a/src/java/org/gsma/joyn/chat/NewChatListener.java b/src/java/org/gsma/joyn/chat/NewChatListener.java
new file mode 100644
index 0000000..e5eba0c
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/NewChatListener.java
@@ -0,0 +1,51 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+
+/**
+ * New chat invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewChatListener extends INewChatListener.Stub {
+    /**
+     * Callback called when a new chat invitation has been received
+     *
+     * @param contact Remote contact
+     * @param message Chat message
+     * @see ChatMessage
+     */
+    public abstract void onNewSingleChat(String contact, ChatMessage message);
+
+    /**
+     * Callback called when a new group chat invitation has been received
+     *
+     * @param chatId Chat ID
+     */
+    public abstract void onNewGroupChat(String chatId);
+
+    /**
+     * Callback called when a new public account chat invitation has been received
+     *
+     * @param chatId Chat ID
+     */
+    public void onNewPublicAccountChat(String chatId,ChatMessage message) {
+        // default implementation for TAPI extension
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/PublicAccountChat.java b/src/java/org/gsma/joyn/chat/PublicAccountChat.java
new file mode 100644
index 0000000..e8f15e8
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/PublicAccountChat.java
@@ -0,0 +1,50 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.Logger;
+
+public class PublicAccountChat extends Chat {
+    /**
+     * Constructor
+     *
+     * @param chatIntf Chat interface
+     */
+    PublicAccountChat(IChat chatIntf) {
+        super(chatIntf);
+    }
+
+    /**
+     * Sends a large mode public account message
+     *
+     * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+   public String sendPublicAccountMessageByLargeMode(String message) throws JoynServiceException {
+
+        Logger.i(TAG, "PAM sendPublicAccountMessageByLargeMode entry " + message);
+        try {
+            return chatInf.sendPublicAccountMessageByLargeMode(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+  /**
+     * Sends a pager mode message
+     *
+     * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+   public String sendPublicAccountMessageByPagerMode(String message) throws JoynServiceException {
+
+        Logger.i(TAG, "PAM sendPublicAccountMessageByPagerMode entry " + message);
+        try {
+            String extraParams[] = {"public" };
+          return chatInf.sendMessageByPagerMode(message, false, true, false, false, null);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/SpamReportListener.java b/src/java/org/gsma/joyn/chat/SpamReportListener.java
new file mode 100644
index 0000000..9372dcf
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/SpamReportListener.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+
+/**
+ * New chat invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class SpamReportListener extends ISpamReportListener.Stub {
+    /**
+     * Callback called when a new chat invitation has been received
+     *
+     * @param contact Remote contact
+     * @param msgId Chat message ID
+     * @see ChatMessage
+     */
+    public abstract void onSpamReportSuccess(String contact, String msgId);
+
+    /**
+     * Callback called when a new group chat invitation has been received
+     *
+     * @param contact contact
+     * @param msgId msgId
+     * @param errorCode errorCode
+     */
+    public abstract void onSpamReportFailed(String contact, String msgId, int errorCode);
+}
diff --git a/src/java/org/gsma/joyn/chat/package-info.java b/src/java/org/gsma/joyn/chat/package-info.java
new file mode 100644
index 0000000..f5c2877
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * This API exposes all functionality for single chat and group chat services.
+ * <p>
+ */
+package org.gsma.joyn.chat;
diff --git a/src/java/org/gsma/joyn/contacts/ContactsProvider.java b/src/java/org/gsma/joyn/contacts/ContactsProvider.java
new file mode 100644
index 0000000..f1a96c2
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/ContactsProvider.java
@@ -0,0 +1,75 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.contacts;
+
+/**
+ * Contacts provider for joyn info integrated in the native address book
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ContactsProvider {
+    /**
+     * RCS phone number
+     */
+    public final static String MIME_TYPE_PHONE_NUMBER = "vnd.android.cursor.item/org.gsma.joyn.number";
+
+    /**
+     * Registration state
+     */
+    public final static String MIME_TYPE_REGISTRATION_STATE = "vnd.android.cursor.item/org.gsma.joyn.registration-state";
+
+    /**
+     * Image sharing capability support
+     */
+    public final static String MIME_TYPE_IMAGE_SHARING = "vnd.android.cursor.item/org.gsma.joyn.image-sharing";
+
+    /**
+     * Video sharing capability support
+     */
+    public final static String MIME_TYPE_VIDEO_SHARING = "vnd.android.cursor.item/org.gsma.joyn.video-sharing";
+
+    /**
+     * IM/Chat capability support
+     */
+    public final static String MIME_TYPE_IM_SESSION = "vnd.android.cursor.item/org.gsma.joyn.im-session";
+
+    /**
+     * File transfer capability support
+     */
+    public final static String MIME_TYPE_FILE_TRANSFER = "vnd.android.cursor.item/org.gsma.joyn.file-transfer";
+
+    /**
+     * Geolocation push capability support
+     */
+    public final static String MIME_TYPE_GEOLOC_PUSH = "vnd.android.cursor.item/org.gsma.joyn.geoloc-push";
+
+    /**
+     * IP voice call capability support
+     */
+    public final static String MIME_TYPE_IP_VOICE_CALL = "vnd.android.cursor.item/org.gsma.joyn.ip-voice-call";
+
+    /**
+     * IP video call capability support
+     */
+    public final static String MIME_TYPE_IP_VIDEO_CALL = "vnd.android.cursor.item/org.gsma.joyn.ip-video-call";
+
+    /**
+     * RCS extensions supported
+     */
+    public final static String MIME_TYPE_EXTENSIONS = "vnd.android.cursor.item/org.gsma.joyn.extensions";
+}
diff --git a/src/java/org/gsma/joyn/contacts/ContactsService.java b/src/java/org/gsma/joyn/contacts/ContactsService.java
new file mode 100644
index 0000000..f6bc54f
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/ContactsService.java
@@ -0,0 +1,447 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.contacts;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.res.AssetFileDescriptor;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Environment;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+import android.provider.ContactsContract;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+import org.gsma.joyn.Logger;
+
+/**
+ * Contacts service offers additional methods to manage RCS info in the
+ * local address book.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ContactsService extends JoynService {
+    /**
+     * API
+     */
+    private IContactsService api = null;
+    private Context mContext = null;
+    public static final String TAG = "TAPI-ContactsService";
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public ContactsService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+        mContext = ctx;
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "ContactsService connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        Logger.i(TAG, "ContactsService disconnect() entry");
+        try {
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IContactsService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry " + className);
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getContactsServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IContactsService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected entry " + className);
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the joyn contact infos from its contact ID (i.e. MSISDN)
+     *
+     * @param contactId Contact ID
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public JoynContact getJoynContact(String contactId) throws JoynServiceException {
+        Logger.i(TAG, "getJoynContact entry Id=" + contactId);
+        if (api != null) {
+            try {
+                return api.getJoynContact(contactId);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of joyn contacts
+     *
+     * @return List of contacts
+     * @throws JoynServiceException
+     */
+    public Set<JoynContact> getJoynContacts() throws JoynServiceException {
+        Logger.i(TAG, "getJoynContacts entry ");
+        if (api != null) {
+            try {
+                Set<JoynContact> result = new HashSet<JoynContact>();
+                List<JoynContact> contacts = api.getJoynContacts();
+                for (int i = 0; i < contacts.size(); i++) {
+                    JoynContact contact = contacts.get(i);
+                    result.add(contact);
+                }
+                Logger.i(TAG, "getJoynContacts returning result = " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of online contacts (i.e. registered)
+     *
+     * @return List of contacts
+     * @throws JoynServiceException
+     */
+    public Set<JoynContact> getJoynContactsOnline() throws JoynServiceException {
+        Logger.i(TAG, "getJoynContactsOnline() entry ");
+        if (api != null) {
+            try {
+                Set<JoynContact> result = new HashSet<JoynContact>();
+                result.addAll(api.getJoynContactsOnline());
+                Logger.i(TAG, "getJoynContactsOnline() returning result = " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of contacts supporting a given extension or service ID
+     *
+     * @param serviceId Service ID
+     * @return List of contacts
+     * @throws JoynServiceException
+     */
+    public Set<JoynContact> getJoynContactsSupporting(String serviceId) throws JoynServiceException {
+        Logger.i(TAG, "getJoynContactsSupporting() entry ");
+        if (api != null) {
+            try {
+                Set<JoynContact> result = new HashSet<JoynContact>();
+                result.addAll(api.getJoynContactsSupporting(serviceId));
+                Logger.i(TAG, "getJoynContactsSupporting() returning result = " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the vCard of a contact. The method returns the complete filename including the path of the visit
+     * card. The filename has the file extension .vcf and is generated from the native address book
+     * vCard URI (see Android SDK attribute ContactsContract.Contacts.CONTENT_VCARD_URI which returns
+     * the referenced contact formatted as a vCard when opened through openAssetFileDescriptor(Uri, String)).
+     *
+     * @param contactUri Contact URI of the contact in the native address book
+     * @return Filename of vCard
+     * @throws JoynServiceException
+     */
+    public String getVCard(Uri contactUri) throws JoynServiceException {
+        Logger.i(TAG, "getVCard() entry ");
+        String fileName = null;
+        Cursor cursor = mContext.getContentResolver().query(contactUri, null, null, null, null);
+        while (cursor.moveToNext()) {
+            String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));
+            String lookupKey = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.LOOKUP_KEY));
+            Uri vCardUri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_VCARD_URI, lookupKey);
+            Logger.i(TAG, "getVCard() uri= " + vCardUri);
+            AssetFileDescriptor fd;
+            try {
+                fd = mContext.getContentResolver().openAssetFileDescriptor(vCardUri, "r");
+                FileInputStream fis = fd.createInputStream();
+                byte[] buf = new byte[(int) fd.getDeclaredLength()];
+                fis.read(buf);
+                String Vcard = new String(buf);
+
+                fileName = Environment.getExternalStorageDirectory().toString() + File.separator + name + ".vcf";
+                Logger.i(TAG, "getVCard() filename= " + fileName);
+                File vCardFile = new File(fileName);
+
+                if (vCardFile.exists())
+                    vCardFile.delete();
+
+                FileOutputStream mFileOutputStream = new FileOutputStream(vCardFile, true);
+                mFileOutputStream.write(Vcard.toString().getBytes());
+                mFileOutputStream.close();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        }
+        cursor.close();
+        return fileName;
+    }
+
+    /**
+     * Get all IM blocked contacts that stored in the local copy
+     * @return
+     */
+    public List<String> getImBlockedContactsFromLocal() {
+        Logger.i(TAG, "getImBlockedContactsFromLocal entry");
+        if (api != null) {
+            try {
+                return api.getImBlockedContactsFromLocal();
+            } catch (Exception e) {
+                //throw new JoynServiceException(e.getMessage());
+                return null;
+            }
+        } else {
+            //throw new JoynServiceNotAvailableException();
+            return null;
+        }
+    }
+
+    /**
+     * Get whether the "IM" feature is enabled or not for the contact
+     *
+     * @param contact
+     * @return flag indicating if IM sessions with the contact are enabled or not
+     */
+    public boolean isImBlockedForContact(String contact) throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.isImBlockedForContact(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+    /**
+     * Get the contacts that are "IM blocked"
+     *
+     * @return list containing all contacts that are "IM blocked"
+     */
+    public List<String> getImBlockedContacts() throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.getImBlockedContacts();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    public String getTimeStampForBlockedContact(String contact) throws JoynServiceException {
+        Logger.i(TAG, "getTimeStampForBlockedContact entry" + contact);
+        if (api != null) {
+            try {
+                return api.getTimeStampForBlockedContact(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /*public static Set<String> getAllBlockedList(){
+        Logger.i(TAG, "getAllBlockedList entry");
+        if (api != null) {
+            try {
+                return api.getAllBlockedList();
+            } catch(Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }*/
+
+    /**
+     * Mark the contact as "blocked for IM"
+     *
+     * @param contact
+     * @param flag indicating if we enable or disable the IM sessions with the contact
+     */
+    public void setImBlockedForContact(String contact, boolean flag) throws JoynServiceException {
+        Logger.i(TAG, "setImBlockedForContact entry" + contact + ",flag=" + flag);
+        if (api != null) {
+            try {
+                api.setImBlockedForContact(contact, flag);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Mark the contact as "blocked for FT"
+     *
+     * @param contact
+     * @param flag indicating if we enable or disable the FT sessions with the contact
+     */
+    public void setFtBlockedForContact(String contact, boolean flag) throws JoynServiceException {
+        Logger.i(TAG, "setFtBlockedForContact entry" + contact + ",flag=" + flag);
+        if (api != null) {
+            try {
+                api.setFtBlockedForContact(contact, flag);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Check if number provided is a valid number for RCS
+     * <br>It is not valid if :
+     * <li>well formatted (not digits only or '+')
+     * <li>minimum length
+     *
+     * @param number Phone number
+     * @return Returns true if it is a RCS valid number
+     */
+    public boolean isRcsValidNumber(String number) throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.isRcsValidNumber(number);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Get the registration state of a contact in the EAB
+     *
+     * @param contact Contact
+     * @return Contact info
+     */
+    public int getRegistrationState(String contact) throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.getRegistrationState(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Load the IM blocked contacts to the local copy
+     */
+    public void loadImBlockedContactsToLocal() throws JoynServiceException {
+        if (api != null) {
+            try {
+                api.loadImBlockedContactsToLocal();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+}
diff --git a/src/java/org/gsma/joyn/contacts/IContactsService.aidl b/src/java/org/gsma/joyn/contacts/IContactsService.aidl
new file mode 100644
index 0000000..387f1a9
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/IContactsService.aidl
@@ -0,0 +1,37 @@
+package org.gsma.joyn.contacts;
+
+import org.gsma.joyn.contacts.JoynContact;
+
+/**
+ * Contacts service API
+ */
+interface IContactsService {
+	JoynContact getJoynContact(String contactId);
+
+	List<JoynContact> getJoynContacts();
+
+	List<JoynContact> getJoynContactsOnline();
+
+	List<JoynContact> getJoynContactsSupporting(in String tag);
+	
+	int getServiceVersion();
+	
+	List<String> getImBlockedContactsFromLocal();
+	
+	boolean isImBlockedForContact(String contact);
+	
+	List<String> getImBlockedContacts();
+	
+	String getTimeStampForBlockedContact(in String contact);
+	
+	void setImBlockedForContact(in String contact, in boolean flag);
+	
+	void setFtBlockedForContact(in String contact, in boolean flag);
+	
+	boolean isRcsValidNumber(in String number);
+	
+	int getRegistrationState(in String contact);
+	
+	void loadImBlockedContactsToLocal();
+	
+}
diff --git a/src/java/org/gsma/joyn/contacts/JoynContact.aidl b/src/java/org/gsma/joyn/contacts/JoynContact.aidl
new file mode 100644
index 0000000..0327cd9
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/JoynContact.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.contacts;
+
+/**
+ * Joyn contact object
+ */
+parcelable JoynContact;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/contacts/JoynContact.java b/src/java/org/gsma/joyn/contacts/JoynContact.java
new file mode 100644
index 0000000..42b6fd9
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/JoynContact.java
@@ -0,0 +1,153 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.contacts;
+
+import org.gsma.joyn.capability.Capabilities;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * Joyn contact
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynContact implements Parcelable {
+    /**
+     * Capabilities
+     */
+    private Capabilities capabilities = null;
+
+    /**
+     * Contact ID
+     */
+    private String contactId = null;
+
+    /**
+     * Registration state
+     */
+    private boolean registered = false;
+
+    public static final String TAG = "TAPI-JoynContact";
+    /**
+     * Constructor
+     *
+     * @param contactId Contact ID
+     * @param registered Registration state
+     * @param capabilities Capabilities
+     * @hide
+     */
+    public JoynContact(String contactId, boolean registered, Capabilities capabilities) {
+        Logger.i(TAG, "JoynContact entry" + "contactId =" + contactId + " registered=" + registered + " capabilities=" + capabilities) ;
+        this.contactId = contactId;
+        this.registered = registered;
+        this.capabilities = capabilities;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public JoynContact(Parcel source) {
+        contactId = source.readString();
+        registered = source.readInt() != 0;
+        boolean flag = source.readInt() != 0;
+        if (flag) {
+            this.capabilities = source.readParcelable(getClass().getClassLoader());
+        } else {
+            this.capabilities = null;
+        }
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(contactId);
+        dest.writeInt(registered ? 1 : 0);
+        if (capabilities != null) {
+            dest.writeInt(1);
+            dest.writeParcelable(capabilities, flags);
+        } else {
+            dest.writeInt(0);
+        }
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<JoynContact> CREATOR
+            = new Parcelable.Creator<JoynContact>() {
+        public JoynContact createFromParcel(Parcel source) {
+            return new JoynContact(source);
+        }
+
+        public JoynContact[] newArray(int size) {
+            return new JoynContact[size];
+        }
+    };
+
+    /**
+     * Returns the canonical contact ID (i.e. MSISDN)
+     *
+     * @return Contact ID
+     */
+    public String getContactId() {
+        return contactId;
+    }
+
+    /**
+     * Is contact online (i.e. registered to the service platform)
+     *
+     * @return Returns true if registered else returns false
+     */
+    public boolean isRegistered() {
+        return registered;
+    }
+
+    /**
+     * Returns the capabilities associated to the contact
+     *
+     * @return Capabilities
+     */
+    public Capabilities getCapabilities() {
+        return capabilities;
+    }
+}
diff --git a/src/java/org/gsma/joyn/contacts/package-info.java b/src/java/org/gsma/joyn/contacts/package-info.java
new file mode 100644
index 0000000..9b3f789
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * This API exposes all infos related to joyn contacts.
+ * <p>
+ */
+package org.gsma.joyn.contacts;
diff --git a/src/java/org/gsma/joyn/ft/FileSpamReportListener.java b/src/java/org/gsma/joyn/ft/FileSpamReportListener.java
new file mode 100644
index 0000000..c7ecea6
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileSpamReportListener.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+
+/**
+ * New chat invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class FileSpamReportListener extends IFileSpamReportListener.Stub {
+    /**
+     * Callback called when a new chat invitation has been received
+     *
+     * @param contact Remote contact
+     * @param msgId Chat message ID
+     * @see ChatMessage
+     */
+    public abstract void onFileSpamReportSuccess(String contact, String ftId);
+
+    /**
+     * Callback called when a new group chat invitation has been received
+     *
+     * @param contact contact
+     * @param msgId msgId
+     * @param errorCode errorCode
+     */
+    public abstract void onFileSpamReportFailed(String contact, String ftId, int errorCode);
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransfer.java b/src/java/org/gsma/joyn/ft/FileTransfer.java
new file mode 100644
index 0000000..8498c61
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransfer.java
@@ -0,0 +1,393 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import org.gsma.joyn.JoynServiceException;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * File transfer
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransfer {
+
+    public static final String TAG = "TAPI-FileTransfer";
+    /**
+     * File transfer state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * File transfer invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * File transfer invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * File transfer is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * File transfer has been transferred with success
+         */
+        public final static int TRANSFERRED = 4;
+
+        /**
+         * File transfer has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * File transfer has failed
+         */
+        public final static int FAILED = 6;
+
+        /**
+         * File transfer has been delivered
+         */
+        public final static int DELIVERED = 7;
+
+        /**
+         * File transfer has been displayed or opened
+         */
+        public final static int DISPLAYED = 8;
+
+        /**
+         * File transfer has been PAUSED
+         */
+        public final static int PAUSED = 8;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the transfer
+     */
+    public static class Direction {
+        /**
+         * Incoming transfer
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing transfer
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * File transfer error
+     */
+    public static class Error {
+        /**
+         * Transfer has failed
+         */
+        public final static int TRANSFER_FAILED = 0;
+
+        /**
+         * Transfer invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        /**
+         * File saving has failed
+         */
+        public final static int SAVING_FAILED = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * File transfer interface
+     */
+    private IFileTransfer transferInf;
+
+    /**
+     * Constructor
+     *
+     * @param transferIntf File transfer interface
+     * @hide
+     */
+    public FileTransfer(IFileTransfer transferIntf) {
+        this.transferInf = transferIntf;
+    }
+
+    /**
+     * Is the file transfer via HTTP
+     *
+     * @return Returns true if file transfer is via HTPP else returns false
+     */
+    public boolean isHttpFileTransfer() throws JoynServiceException {
+        Logger.i(TAG, "isHttpFileTransfer ");
+        try {
+            return transferInf.isHttpFileTransfer();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the file transfer ID of the file transfer
+     *
+     * @return Transfer ID
+     * @throws JoynServiceException
+     */
+    public String getTransferId() throws JoynServiceException {
+        Logger.i(TAG, "getTransferId() entry ");
+        try {
+            return transferInf.getTransferId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the file transfer duration of the file transfer
+     *
+     * @return Transfer ID
+     * @throws JoynServiceException
+     */
+    public int getTransferDuration() throws JoynServiceException {
+        Logger.i(TAG, "getTransferDuration() entry ");
+        try {
+            return transferInf.getTransferDuration();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact() entry ");
+        try {
+            return transferInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the complete filename including the path of the file to be transferred
+     *
+     * @return Filename
+     * @throws JoynServiceException
+     */
+    public String getFileName() throws JoynServiceException {
+        Logger.i(TAG, "getFileName() entry ");
+        try {
+            return transferInf.getFileName();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the size of the file to be transferred
+     *
+     * @return Size in bytes
+     * @throws JoynServiceException
+     */
+    public long getFileSize() throws JoynServiceException {
+        Logger.i(TAG, "getFileSize() entry ");
+        try {
+            return transferInf.getFileSize();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the MIME type of the file to be transferred
+     *
+     * @return Type
+     * @throws JoynServiceException
+     */
+    public String getFileType() throws JoynServiceException {
+        Logger.i(TAG, "getFileType() entry ");
+        try {
+            return transferInf.getFileType();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the complete filename including the path of the file icon
+     *
+     * @return Filename
+     * @throws JoynServiceException
+     */
+    public String getFileIconName() throws JoynServiceException {
+        Logger.i(TAG, "getFileIconName() entry ");
+        try {
+            return transferInf.getFileIconName();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the file transfer
+     *
+     * @return State
+     * @see FileTransfer.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        Logger.i(TAG, "getState() entry ");
+        try {
+            return transferInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the transfer (incoming or outgoing)
+     *
+     * @return Direction
+     * @see FileTransfer.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        Logger.i(TAG, "getDirection() entry ");
+        try {
+            return transferInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts file transfer invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        Logger.i(TAG, "acceptInvitation() entry ");
+        try {
+            transferInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects file transfer invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        Logger.i(TAG, "rejectInvitation() entry ");
+        try {
+            transferInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the file transfer
+     *
+     * @throws JoynServiceException
+     */
+    public void abortTransfer() throws JoynServiceException {
+        Logger.i(TAG, "abortTransfer() entry ");
+        try {
+            transferInf.abortTransfer();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Pauses the file transfer
+     *
+     * @throws JoynServiceException
+     */
+    public void pauseTransfer() throws JoynServiceException {
+        Logger.i(TAG, "pauseTransfer() entry ");
+        try {
+            transferInf.pauseTransfer();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Resumes the file transfer
+     *
+     * @throws JoynServiceException
+     */
+    public void resumeTransfer() throws JoynServiceException {
+        Logger.i(TAG, "resumeTransfer() entry ");
+        try {
+            transferInf.resumeTransfer();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on file transfer events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(FileTransferListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener() entry " + listener);
+        try {
+            transferInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from file transfer
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(FileTransferListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener() entry " + listener);
+        try {
+            transferInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferIntent.java b/src/java/org/gsma/joyn/ft/FileTransferIntent.java
new file mode 100644
index 0000000..cba8c75
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferIntent.java
@@ -0,0 +1,98 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+/**
+ * Intent for file transfer invitation
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransferIntent {
+    /**
+     * Broadcast action: a new file transfer has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_TRANSFER_ID} containing the unique ID of the file transfer.
+     * <li> {@link #EXTRA_FILENAME} containing the filename of file to be transferred.
+     * <li> {@link #EXTRA_FILESIZE} containing the size of the file to be transferred.
+     * <li> {@link #EXTRA_FILETYPE} containing the MIME type of the file to be transferred.
+     * <li> {@link #EXTRA_FILEICON} containing the filename of the file icon associated to the file to be transferred.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.ft.action.NEW_FILE_TRANSFER";
+
+    public final static String ACTION_RESUME_FILE = "org.gsma.joyn.ft.action.RESUME_FILE_TRANSFER";
+
+    public final static String ACTION_DELIVERY_STATUS = "org.gsma.joyn.ft.action.DELIVERY_REPORT_FILE_TRANSFER";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation (extracted from the SIP address)
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the file transfer
+     */
+    public final static String EXTRA_TRANSFER_ID = "transferId";
+
+    /**
+     * Unique ID of the file transfer
+     */
+    public final static String RESUMED_TRANSFER_ID = "resumeTransferId";
+
+    /**
+     * Name of the file
+     */
+    public final static String EXTRA_FILENAME = "filename";
+
+    /**
+     * Size of the file in byte
+     */
+    public final static String EXTRA_FILESIZE = "filesize";
+
+    /**
+     * MIME type of the file
+     */
+    public final static String EXTRA_FILETYPE = "filetype";
+
+    /**
+     * MIME type of the file
+     */
+    public final static String TIME_LEN = "timelength";
+
+    /**
+     * MIME type of the file
+     */
+    public final static String GEOLOC_FILE = "geolocfile";
+
+    /**
+     * Name of the file icon
+     */
+    public final static String EXTRA_FILEICON = "fileicon";
+
+    public final static String EXTRA_BURN = "isBurn";
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferListener.java b/src/java/org/gsma/joyn/ft/FileTransferListener.java
new file mode 100644
index 0000000..5138e48
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferListener.java
@@ -0,0 +1,74 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+
+/**
+ * File transfer event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class FileTransferListener extends IFileTransferListener.Stub {
+    /**
+     * Callback called when the file transfer is started
+     */
+    public abstract void onTransferStarted();
+
+    /**
+     * Callback called when the file transfer has been aborted
+     */
+    public abstract void onTransferAborted();
+
+    /**
+     * Callback called when the transfer has failed
+     *
+     * @param error Error
+     * @see FileTransfer.Error
+     */
+    public abstract void onTransferError(int error);
+
+    /**
+     * Callback called during the transfer progress
+     *
+     * @param currentSize Current transferred size in bytes
+     * @param totalSize Total size to transfer in bytes
+     */
+    public abstract void onTransferProgress(long currentSize, long totalSize);
+
+    /**
+     * Callback called when the file has been transferred
+     *
+     * @param filename Filename including the path of the transferred file
+     */
+    public abstract void onFileTransferred(String filename);
+
+    /**
+     * Callback called when the file transfer has been aborted
+     */
+    public void onTransferPaused() {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when the file transfer has been aborted
+     */
+    public void onTransferResumed(String oldFTid, String newFTId) {
+        // default implementation for TAPI extension
+    }
+
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferLog.java b/src/java/org/gsma/joyn/ft/FileTransferLog.java
new file mode 100644
index 0000000..a24c7a8
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferLog.java
@@ -0,0 +1,150 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import android.net.Uri;
+
+/**
+ * Content provider for file transfer history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransferLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.ft/ft");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the file transfer.
+     * <P>Type: TEXT</P>
+     */
+    public static final String FT_ID = "ft_id";
+
+    /**
+     * The name of the column containing the MSISDN of the sender.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the filename (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILENAME = "filename";
+
+    /**
+     * The name of the column containing the file size to be transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String FILESIZE = "filesize";
+
+    /**
+     * The name of the column containing the MIME-type of the file.
+     * <P>Type: TEXT</P>
+     */
+    public static final String MIME_TYPE = "mime_type";
+
+    /**
+     * The name of the column containing the direction of the transfer.
+     * <P>Type: INTEGER</P>
+     * @see FileTransfer.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the amount of data transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String TRANSFERRED = "transferred";
+
+    /**
+     * The name of the column containing the time when transfer is initiated.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the time when file is sent. If 0 means not sent.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_SENT = "timestamp_sent";
+
+    /**
+     * The name of the column containing the time when file is delivered. If 0 means not delivered.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_DELIVERED = "timestamp_delivered";
+
+    /**
+     * The name of the column containing the time when file is displayed. If 0 means not displayed.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_DISPLAYED = "timestamp_displayed";
+
+    /**
+     * The name of the column containing the state of the transfer.
+     * <P>Type: INTEGER</P>
+     * @see FileTransfer.State
+     */
+    public static final String STATE = "state";
+
+    /**
+     * The name of the column containing the file icon (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILEICON = "fileicon";
+
+    /**
+     * The name of the column containing the chat ID used for the file transfer in group chat.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CHAT_ID = "chat_id";
+
+    public static final String MSG_ID = "msg_id";
+
+    public static final String DURATION = "duration";
+
+
+    public static final String SESSION_TYPE = "session_type";
+
+    public static final String HASH = "hash";
+
+
+    /**
+     * Type of the SESSION
+     */
+    public static class Type {
+        /**
+         * Content
+         */
+        public static final int CHAT = 0;
+
+        /**
+         * BURN message
+         */
+        public static final int BURN = 1;
+
+    }
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferService.java b/src/java/org/gsma/joyn/ft/FileTransferService.java
new file mode 100644
index 0000000..e927cb7
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferService.java
@@ -0,0 +1,739 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+import org.gsma.joyn.Logger;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+
+/**
+ * This class offers the main entry point to transfer files and to
+ * receive files. Several applications may connect/disconnect to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransferService extends JoynService {
+    /**
+     * API
+     */
+    private IFileTransferService api = null;
+
+    public static final String TAG = "TAPI-FileTransferService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public FileTransferService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "FileTransfer connected() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        intent.setAction(IFileTransferService.class.getName());
+
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "FileTransfer disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IFileTransferService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry " + className);
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getFileTransferServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IFileTransferService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected entry " + className);
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of the file transfer service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public FileTransferServiceConfiguration getConfiguration() throws JoynServiceException {
+        Logger.i(TAG, "getConfiguration() entry " + api);
+        if (api != null) {
+            try {
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Transfers a file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferFile(String contact, String filename, FileTransferListener listener) throws JoynServiceException, JoynContactFormatException {
+        return transferFile(contact, filename, null, listener);
+    }
+
+    /**
+     * Transfers a file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferFile(String contact, String filename, String fileicon, FileTransferListener listener) throws JoynServiceException, JoynContactFormatException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferFile() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " listener=" + listener);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferFile(contact, filename, fileicon, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Resumes an interrupted file from the point it got interrupted. Only for MSRP FT
+     *
+     * @param fileTranferId fileTranferId
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer resumeFileTransfer(String fileTranferId, FileTransferListener listener) throws JoynServiceException
+    {
+        Logger.i(TAG, "resumeFileTransfer() entry fileTranferId=" + fileTranferId);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.resumeFileTransfer(fileTranferId, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Resumes an interrupted file from the point it got interrupted. Only for MSRP FT
+     *
+     * @param fileTranferId fileTranferId
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer resumePublicFileTransfer(String fileTranferId, FileTransferListener listener, int timeLen) throws JoynServiceException
+    {
+        Logger.i(TAG, "resumePublicFileTransfer() entry fileTranferId=" + fileTranferId);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.resumePublicFileTransfer(fileTranferId, listener, timeLen);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+
+    /**
+     * Resumes an interrupted file from the point it got interrupted. Only for MSRP FT
+     *
+     * @param fileTranferId fileTranferId
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer resumeGroupFileTransfer(String chatId, String fileTranferId, FileTransferListener listener) throws JoynServiceException
+    {
+        Logger.i(TAG, "resumeGroupFileTransfer() entry fileTranferId=" + fileTranferId);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.resumeGroupFileTransfer(chatId, fileTranferId, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Transfers a file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferGeoLocFile(String contact, String filename, String fileicon, FileTransferListener listener) throws JoynServiceException, JoynContactFormatException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferGeoLocFile() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " listener=" + listener);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferFile(contact, filename, fileicon, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+   /**
+     * Transfers a file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @param timeLen Length of the audio/video file
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferPublicChatFile(String contact, String filename, String fileicon, FileTransferListener listener, int timeLen) throws JoynServiceException, JoynContactFormatException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferPublicChatFile() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " listener=" + listener + " ,timelen=" + timeLen);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferPublicChatFile(contact, filename, fileicon, listener, timeLen);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * transfers a file to a group of contacts outside of a current group chat. The
+     * parameter file contains the complete filename including the path to be transferred.
+     * See also the method GroupChat.sendFile() of the Chat API to send a file from an
+     * existing group chat conversation
+     *
+     * @param chat id of the group chat
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param length of the audio/video file
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToGroup(String chatId, Set<String> contacts, String filename, int timeLen, FileTransferListener listener) throws JoynServiceException
+    {
+        return transferFileToGroup(chatId, contacts, filename, null, timeLen, listener);
+    }
+
+    /**
+     * transfers a file to a group of contacts with an optional file icon.
+     *
+     * @param chat id of the group chat
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param length of the audio/video file
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToGroup(String chatId, Set<String> contacts, String filename, String fileicon, int timeLen, FileTransferListener listener) throws JoynServiceException
+    {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }*/
+        Logger.i(TAG, "transferFileToGroup() entry contact= " + contacts + " chatId=" + chatId + " filename=" + filename + " fileicon = " + fileicon + " timelen:" + timeLen + " listener=" + listener);
+        if (api != null) {
+            try {
+                List<String> contactsList = new ArrayList<String>(contacts);
+                IFileTransfer ftIntf = api.transferFileToGroup(chatId, contactsList, filename, fileicon, timeLen, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * transfers a file to a group of contacts outside of a group chat with an optional file icon.
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToGroup(Set<String> contacts, String filename, String fileicon, FileTransferListener listener) throws JoynServiceException
+    {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }*/
+
+        if (api != null) {
+            try {
+            return null;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * transfers a file to a group of contacts outside of a group chat.
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToGroup(Set<String> contacts, String filename, FileTransferListener listener) throws JoynServiceException
+    {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }*/
+
+        if (api != null) {
+            try {
+            return null;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Transfers a media file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param timeLen Length of audio/video file
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferMedia(String contact, String filename, String fileicon, int timeLen, FileTransferListener listener) throws JoynServiceException
+    {
+            /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferMedia() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " timeLen = " + timeLen + " listener=" + listener);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferMedia(contact, filename, fileicon, listener, timeLen);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * transfers a file to a group of contacts outside of a group chat with an optional file icon.
+     *
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToMultirecepient(Set<String> contacts, String filename, boolean fileIcon, FileTransferListener listener, int timeLen) throws JoynServiceException
+    {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }*/
+        Logger.i(TAG, "transferFileToMultirecepient() entry contact= " + contacts + " filename= " + filename + " listener= " + listener + " Timelen" + timeLen);
+        if (api != null) {
+            try {
+                List<String> contactsList = new ArrayList<String>(contacts);
+                IFileTransfer ftIntf = api.transferFileToMultirecepient(contactsList, filename, fileIcon, listener, timeLen);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of file transfers in progress
+     *
+     * @return List of file transfers
+     * @throws JoynServiceException
+     */
+    public Set<FileTransfer> getFileTransfers() throws JoynServiceException {
+        Logger.i(TAG, "getFileTransfers() entry " + api);
+        if (api != null) {
+            try {
+                Set<FileTransfer> result = new HashSet<FileTransfer>();
+                List<IBinder> ftList = api.getFileTransfers();
+                for (IBinder binder : ftList) {
+                    FileTransfer ft = new FileTransfer(IFileTransfer.Stub.asInterface(binder));
+                    result.add(ft);
+                }
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current file transfer from its unique ID
+     *
+     * @return File transfer or null if not found
+     * @throws JoynServiceException
+     */
+    public FileTransfer getFileTransfer(String transferId) throws JoynServiceException {
+        Logger.i(TAG, "getFileTransfer() entry " + transferId + " api=" + api);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.getFileTransfer(transferId);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current file transfer from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return File transfer or null if not found
+     * @throws JoynServiceException
+     */
+    public FileTransfer getFileTransferFor(Intent intent) throws JoynServiceException {
+        Logger.i(TAG, "getFileTransferFor() entry " + intent + " api=" + api);
+        if (api != null) {
+            try {
+                String transferId = intent.getStringExtra(FileTransferIntent.EXTRA_TRANSFER_ID);
+                if (transferId != null) {
+                    return getFileTransfer(transferId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public void initiateFileSpamReport(String contact, String FtId) throws JoynServiceException {
+        Logger.i(TAG, "initiateSpamReport entry " + contact + ":" + FtId);
+        if (api != null) {
+            try {
+                api.initiateFileSpamReport(contact, FtId);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Adds a spam listener.
+     *
+     * @param listener Spam Report listener
+     * @throws JoynServiceException
+     */
+    public void addFileSpamReportListener(FileSpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addSpamReportListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addFileSpamReportListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Removes a spam listener
+     *
+     * @param listener Spam Report listener
+     * @throws JoynServiceException
+     */
+    public void removeFileSpamReportListener(FileSpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeSpamReportListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeFileSpamReportListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a file transfer invitation listener
+     *
+     * @param listener New file transfer listener
+     * @throws JoynServiceException
+     */
+    public void addNewFileTransferListener(NewFileTransferListener listener) throws JoynServiceException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_RECEIVE) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_RECEIVE");
+        }*/
+        Logger.i(TAG, "addNewFileTransferListener() entry " + listener + " api=" + api);
+        if (api != null) {
+            try {
+                api.addNewFileTransferListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a file transfer invitation listener
+     *
+     * @param listener New file transfer listener
+     * @throws JoynServiceException
+     */
+    public void removeNewFileTransferListener(NewFileTransferListener listener) throws JoynServiceException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_RECEIVE) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_RECEIVE");
+        }*/
+        Logger.i(TAG, "removeNewFileTransferListener() entry " + listener + " api=" + api);
+        if (api != null) {
+            try {
+                api.removeNewFileTransferListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    public FileTransfer transferBurnFile(String contact, String filename, String fileicon, FileTransferListener listener) throws JoynServiceException, JoynContactFormatException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferBurnFile() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " listener=" + listener);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferBurnFile(contact, filename, fileicon, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.aidl b/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.aidl
new file mode 100644
index 0000000..37f728d
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ft;
+
+/**
+ * File transfer configuration object
+ */
+parcelable FileTransferServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.java b/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.java
new file mode 100644
index 0000000..76e9038
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.java
@@ -0,0 +1,197 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+
+/**
+ * File transfer service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransferServiceConfiguration implements Parcelable {
+
+    public static final String TAG = "TAPI-FileTransferServiceConfiguration";
+    /**
+     * File transfer size threshold
+     */
+    private long warnSize;
+
+    /**
+     * File transfer size limit
+     */
+    private long maxSize;
+
+    /**
+     * File transfer auto accept mode
+     */
+    private boolean autoAcceptMode;
+
+    /**
+     * File icon
+     */
+    private boolean fileIcon;
+
+    /**
+     * File icon size limit
+     */
+    private long maxFileIconSize;
+
+    /**
+     * File icon size limit
+     */
+    private int maxFileTransfers;
+
+
+    /**
+     * Constructor
+     *
+     * @param warnSize File transfer size threshold
+     * @param maxSize File transfer size limit
+     * @param autoAcceptMode File transfer auto accept mode
+     * @param fileIcon File icon
+     * @param maxFileIconSize File icon size limit
+     * @hide
+     */
+    public FileTransferServiceConfiguration(long warnSize, long maxSize, boolean autoAcceptMode, boolean fileIcon, long maxFileIconSize , int maxFileTransfers) {
+        Logger.i(TAG, "FileTransferServiceConfiguration entry" + "warnSize " + warnSize + "maxSize " + maxSize + "autoAcceptMode " + autoAcceptMode +
+                "fileIcon" + fileIcon + "maxFileIconSize " + maxFileIconSize + "maxFileTransfers" + maxFileTransfers);
+        this.warnSize = warnSize;
+        this.maxSize = maxSize;
+        this.autoAcceptMode = autoAcceptMode;
+        this.fileIcon = fileIcon;
+        this.maxFileIconSize = maxFileIconSize;
+        this.maxFileTransfers = maxFileTransfers;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public FileTransferServiceConfiguration(Parcel source) {
+        this.warnSize = source.readLong();
+        this.maxSize = source.readLong();
+        this.autoAcceptMode = source.readInt() != 0;
+        this.fileIcon = source.readInt() != 0;
+        this.maxFileIconSize = source.readLong();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(warnSize);
+        dest.writeLong(maxSize);
+        dest.writeInt(autoAcceptMode ? 1 : 0);
+        dest.writeInt(fileIcon ? 1 : 0);
+        dest.writeLong(maxFileIconSize);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<FileTransferServiceConfiguration> CREATOR
+            = new Parcelable.Creator<FileTransferServiceConfiguration>() {
+        public FileTransferServiceConfiguration createFromParcel(Parcel source) {
+            return new FileTransferServiceConfiguration(source);
+        }
+
+        public FileTransferServiceConfiguration[] newArray(int size) {
+            return new FileTransferServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Returns the file transfer size threshold when the user should be warned about
+     * the potential charges associated to the transfer of a large file. It returns
+     * 0 if there no need to warn.
+     *
+     * @return Size in kilobytes
+     */
+    public long getWarnSize() {
+        return warnSize;
+    }
+
+    /**
+     * Returns the file transfer size limit. It returns 0 if there is no limitation.
+     *
+     * @return Size in kilobytes
+     */
+    public long getMaxSize() {
+        return maxSize;
+    }
+
+    /**
+     * Is file transfer invitation automatically accepted
+     *
+     * @return Returns true if automatically accepted else returns false
+     */
+    public boolean getAutoAcceptMode() {
+        return autoAcceptMode;
+    }
+
+    /**
+     * Is file icon supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isFileIconSupported() {
+        return fileIcon;
+    }
+
+    /**
+     * Returns the file transfer size limit. It returns 0 if there is no limitation.
+     *
+     * @return Size in kilobytes
+     */
+    public long getMaxFileIconSize() {
+        return maxFileIconSize;
+    }
+
+    /**
+     * Returns the maximum number of file transfer session simultaneously
+     *
+     * @return numenr of sessions
+     */
+    public int getMaxFileTransfers() {
+        return maxFileTransfers;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl b/src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl
new file mode 100644
index 0000000..2aae4ae
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl
@@ -0,0 +1,10 @@
+package org.gsma.joyn.ft;
+
+/**
+ * New chat invitation event listener
+ */
+interface IFileSpamReportListener {
+	void onFileSpamReportSuccess( String contact, String ftId);
+	
+	void onFileSpamReportFailed( String contact, String ftId, int errorCode);
+}
diff --git a/src/java/org/gsma/joyn/ft/IFileTransfer.aidl b/src/java/org/gsma/joyn/ft/IFileTransfer.aidl
new file mode 100644
index 0000000..acb3a78
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/IFileTransfer.aidl
@@ -0,0 +1,43 @@
+package org.gsma.joyn.ft;
+
+import org.gsma.joyn.ft.IFileTransferListener;
+
+/**
+ * File transfer interface
+ */
+interface IFileTransfer {
+
+	String getTransferId();
+
+	String getRemoteContact();
+
+	String getFileName();
+
+	long getFileSize();
+
+	String getFileType();
+
+	String getFileIconName();
+
+	int getState();
+	
+	int getDirection();
+		
+	boolean isHttpFileTransfer();
+		
+	int getTransferDuration();
+		
+	void acceptInvitation();
+
+	void rejectInvitation();
+
+	void abortTransfer();
+	
+	void pauseTransfer();
+	
+	void resumeTransfer();
+
+	void addEventListener(in IFileTransferListener listener);
+
+	void removeEventListener(in IFileTransferListener listener);
+}
diff --git a/src/java/org/gsma/joyn/ft/IFileTransferListener.aidl b/src/java/org/gsma/joyn/ft/IFileTransferListener.aidl
new file mode 100644
index 0000000..d3bd179
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/IFileTransferListener.aidl
@@ -0,0 +1,20 @@
+package org.gsma.joyn.ft;
+
+/**
+ * Callback methods for file transfer events
+ */
+interface IFileTransferListener {
+	void onTransferStarted();
+	
+	void onTransferAborted();
+
+	void onTransferPaused();
+	
+	void onTransferResumed(in String oldFileTransferId, in String newFileTransferId);
+
+	void onTransferError(in int error);
+	
+	void onTransferProgress(in long currentSize, in long totalSize);
+
+	void onFileTransferred(in String filename);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/IFileTransferService.aidl b/src/java/org/gsma/joyn/ft/IFileTransferService.aidl
new file mode 100644
index 0000000..6521240
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/IFileTransferService.aidl
@@ -0,0 +1,64 @@
+package org.gsma.joyn.ft;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.ft.IFileTransfer;
+import org.gsma.joyn.ft.IFileTransferListener;
+import org.gsma.joyn.ft.INewFileTransferListener;
+import org.gsma.joyn.ft.IFileSpamReportListener;
+import org.gsma.joyn.ft.FileTransferServiceConfiguration;
+
+/**
+ * File transfer service API
+ */
+interface IFileTransferService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	FileTransferServiceConfiguration getConfiguration();
+
+	List<IBinder> getFileTransfers();
+	
+	IFileTransfer getFileTransfer(in String transferId);
+
+	IFileTransfer transferFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+	
+	IFileTransfer resumeFileTransfer(in String fileTranferId, in IFileTransferListener listener);
+
+	IFileTransfer transferBurnFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+
+        IFileTransfer transferGeoLocFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+	
+      IFileTransfer transferPublicChatFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener,int timeLen);
+	
+	IFileTransfer transferLargeModeFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+
+    IFileTransfer transferLargeModeBurnFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+	
+	IFileTransfer transferFileToGroup(in String chatId,in List<String> contacts, in String filename, in String fileicon,in int timeLen, in IFileTransferListener listener);
+	
+	IFileTransfer transferMedia(in String contact,in String filename,in String fileicon,in IFileTransferListener listener,in int timeLen);
+	
+	IFileTransfer transferFileToMultirecepient(in List<String> contacts,in String filename,in boolean fileIcon,in IFileTransferListener listener,in int timeLen);
+	
+	void addNewFileTransferListener(in INewFileTransferListener listener);
+
+	void removeNewFileTransferListener(in INewFileTransferListener listener);
+	
+	int getServiceVersion();
+
+	void initiateFileSpamReport(String contact, String messageId);
+	
+	void addFileSpamReportListener(in IFileSpamReportListener listener);
+	
+	void removeFileSpamReportListener(in IFileSpamReportListener listener);
+
+  int getMaxFileTransfers();
+  
+  IFileTransfer resumeGroupFileTransfer(in String chatId, in String fileTranferId, in IFileTransferListener listener);
+  
+  IFileTransfer resumePublicFileTransfer(in String fileTranferId, in IFileTransferListener listener, int timeLen);
+  
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl b/src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl
new file mode 100644
index 0000000..d7eb0cb
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl
@@ -0,0 +1,24 @@
+package org.gsma.joyn.ft;
+
+/**
+ * Callback method for new file transfer invitations and delivery reports
+ */
+interface INewFileTransferListener {
+	void onNewFileTransfer(in String transferId);
+	
+	void onReportFileDelivered(String transferId);
+	
+	void onReportFileDisplayed(String transferId);
+	
+	void onFileDeliveredReport(String transferId,String contact);
+	
+	void onFileDisplayedReport(String transferId,String contact);
+	
+	void onNewFileTransferReceived(String transferId,boolean isAutoAccept,boolean isGroup,String chatSessionId,String ChatId,int timeLen);
+	
+	void onNewPublicAccountChatFile(String transferId,boolean isAutoAccept,boolean isGroup,String chatSessionId,String ChatId);
+	
+    void onNewBurnFileTransfer(String transferId,boolean isGroup,String chatSessionId,String ChatId); 
+	
+	
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/MultiFileTransferLog.java b/src/java/org/gsma/joyn/ft/MultiFileTransferLog.java
new file mode 100644
index 0000000..5452e79
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/MultiFileTransferLog.java
@@ -0,0 +1,134 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import android.net.Uri;
+
+/**
+ * Content provider for file transfer history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultiFileTransferLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.multift/multift");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the file transfer.
+     * <P>Type: TEXT</P>
+     */
+    public static final String FT_ID = "ft_id";
+
+    /**
+     * The name of the column containing the MSISDN of the sender.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the filename (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILENAME = "filename";
+
+    /**
+     * The name of the column containing the file size to be transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String FILESIZE = "filesize";
+
+    /**
+     * The name of the column containing the MIME-type of the file.
+     * <P>Type: TEXT</P>
+     */
+    public static final String MIME_TYPE = "mime_type";
+
+    /**
+     * The name of the column containing the direction of the transfer.
+     * <P>Type: INTEGER</P>
+     * @see FileTransfer.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the amount of data transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String TRANSFERRED = "transferred";
+
+    /**
+     * The name of the column containing the time when transfer is initiated.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the time when file is sent. If 0 means not sent.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_SENT = "timestamp_sent";
+
+    /**
+     * The name of the column containing the time when file is delivered. If 0 means not delivered.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_DELIVERED = "timestamp_delivered";
+
+    /**
+     * The name of the column containing the time when file is displayed. If 0 means not displayed.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_DISPLAYED = "timestamp_displayed";
+
+    /**
+     * The name of the column containing the state of the transfer.
+     * <P>Type: INTEGER</P>
+     * @see FileTransfer.State
+     */
+    public static final String STATE = "state";
+
+    /**
+     * The name of the column containing the file icon (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILEICON = "fileicon";
+
+    /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PARTICIPANTS_LIST = "participants";
+
+    /**
+     * The name of the column containing the chat ID used for the file transfer in group chat.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CHAT_ID = "chat_id";
+
+    public static final String MSG_ID = "msg_id";
+
+    public static final String DURATION = "duration";
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/NewFileTransferListener.java b/src/java/org/gsma/joyn/ft/NewFileTransferListener.java
new file mode 100644
index 0000000..97d7182
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/NewFileTransferListener.java
@@ -0,0 +1,97 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+
+/**
+ * New file transfer invitations event and delivery reports listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewFileTransferListener extends INewFileTransferListener.Stub {
+    /**
+     * Callback method for new file transfer invitations
+     *
+     * @param transferId Transfer ID
+     */
+    public abstract void onNewFileTransfer(String transferId);
+
+    /**
+     * Callback called when the file has been delivered
+     *
+     * @param transferId Transfer ID
+     */
+    public abstract void onReportFileDelivered(String transferId);
+
+    /**
+     * Callback called when the file has been displayed
+     *
+     * @param transferId Transfer ID
+     */
+    public abstract void onReportFileDisplayed(String transferId);
+
+    /**
+     * Callback method for new file transfer invitations
+     *
+     * @param transferId Transfer ID
+     */
+    public void onNewFileTransferReceived(
+                String transferId,
+                boolean isAutoAccept,
+                boolean isGroup,
+                String chatSessionId,
+                String ChatId,
+                int timeLen) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when the file has been delivered
+     *
+     * @param transferId Transfer ID
+     */
+    public void onFileDeliveredReport(String transferId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when the file has been displayed
+     *
+     * @param transferId Transfer ID
+     */
+    public void onFileDisplayedReport(String transferId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    public void onNewBurnFileTransfer(
+                String transferId,
+                boolean isGroup,
+                String chatSessionId,
+                String ChatId) {
+        // default implementation for TAPI extension
+    }
+
+    public void onNewPublicAccountChatFile(
+                String transferId,
+                boolean isAutoAccept,
+                boolean isGroup,
+                String chatSessionId,
+                String ChatId) {
+        // default implementation for TAPI extension
+    }
+}
diff --git a/src/java/org/gsma/joyn/ft/package-info.java b/src/java/org/gsma/joyn/ft/package-info.java
new file mode 100644
index 0000000..51feeae
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * This API exposes all functionality to transfer files in real time.
+ * <p>
+ */
+package org.gsma.joyn.ft;
diff --git a/src/java/org/gsma/joyn/gsh/GeolocSharing.java b/src/java/org/gsma/joyn/gsh/GeolocSharing.java
new file mode 100644
index 0000000..b6f6cd4
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/GeolocSharing.java
@@ -0,0 +1,272 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.chat.Geoloc;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * Geoloc sharing
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GeolocSharing {
+
+    public static final String TAG = "TAPI-GeolocSharing";
+    /**
+     * Geoloc sharing state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Sharing invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Sharing invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Sharing is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Geoloc has been transferred with success
+         */
+        public final static int TRANSFERRED = 4;
+
+        /**
+         * Sharing has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Sharing has failed
+         */
+        public final static int FAILED = 6;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the sharing
+     */
+    public static class Direction {
+        /**
+         * Incoming sharing
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing sharing
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Geoloc sharing error
+     */
+    public static class Error {
+        /**
+         * Sharing has failed
+         */
+        public final static int SHARING_FAILED = 0;
+
+        /**
+         * Sharing invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Geoloc sharing interface
+     */
+    private IGeolocSharing sharingInf;
+
+    /**
+     * Constructor
+     *
+     * @param sharingInf Geoloc sharing interface
+     */
+    GeolocSharing(IGeolocSharing sharingInf) {
+        this.sharingInf = sharingInf;
+    }
+
+    /**
+     * Returns the sharing ID of the geoloc sharing
+     *
+     * @return Sharing ID
+     * @throws JoynServiceException
+     */
+    public String getSharingId() throws JoynServiceException {
+        Logger.i(TAG, "getSharingId() entry ");
+        try {
+            return sharingInf.getSharingId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact() entry ");
+        try {
+            return sharingInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the geolocation info
+     *
+     * @return Geoloc object
+     * @throws JoynServiceException
+     * @see Geoloc
+     */
+    public Geoloc getGeoloc() throws JoynServiceException {
+        Logger.i(TAG, "getGeoloc() entry ");
+        try {
+            return sharingInf.getGeoloc();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the sharing
+     *
+     * @return State
+     * @see GeolocSharing.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        Logger.i(TAG, "getState() entry ");
+        try {
+            return sharingInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the sharing (incoming or outgoing)
+     *
+     * @return Direction
+     * @see GeolocSharing.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        Logger.i(TAG, "getDirection() entry ");
+        try {
+            return sharingInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts geoloc sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        Logger.i(TAG, "acceptInvitation() entry ");
+        try {
+            sharingInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects geoloc sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        Logger.i(TAG, "rejectInvitation() entry ");
+        try {
+            sharingInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the sharing
+     *
+     * @throws JoynServiceException
+     */
+    public void abortSharing() throws JoynServiceException {
+        Logger.i(TAG, "abortSharing() entry ");
+        try {
+            sharingInf.abortSharing();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on geoloc sharing events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(GeolocSharingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener() entry " + listener);
+        try {
+            sharingInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from geoloc sharing
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(GeolocSharingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener() entry " + listener);
+        try {
+            sharingInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/gsh/GeolocSharingIntent.java b/src/java/org/gsma/joyn/gsh/GeolocSharingIntent.java
new file mode 100644
index 0000000..d8fff30
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/GeolocSharingIntent.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+/**
+ * Intent for geoloc sharing invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GeolocSharingIntent {
+    /**
+     * Broadcast action: a new geoloc sharing invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_SHARING_ID} containing the unique ID of the geoloc sharing.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.gsh.action.NEW_GEOLOC_SHARING";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the geoloc sharing
+     */
+    public final static String EXTRA_SHARING_ID = "sharingId";
+}
diff --git a/src/java/org/gsma/joyn/gsh/GeolocSharingListener.java b/src/java/org/gsma/joyn/gsh/GeolocSharingListener.java
new file mode 100644
index 0000000..d0c5a0a
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/GeolocSharingListener.java
@@ -0,0 +1,60 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Geoloc sharing event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class GeolocSharingListener extends IGeolocSharingListener.Stub {
+    /**
+     * Callback called when the sharing is started
+     */
+    public abstract void onSharingStarted();
+
+    /**
+     * Callback called when the sharing has been aborted
+     */
+    public abstract void onSharingAborted();
+
+    /**
+     * Callback called when the sharing has failed
+     *
+     * @param error Error
+     * @see GeolocSharing.Error
+     */
+    public abstract void onSharingError(int error);
+
+    /**
+     * Callback called during the sharing progress
+     *
+     * @param currentSize Current transferred size in bytes
+     * @param totalSize Total size to transfer in bytes
+     */
+    public abstract void onSharingProgress(long currentSize, long totalSize);
+
+    /**
+     * Callback called when the geoloc has been shared
+     *
+     * @param geoloc Geoloc object
+     */
+    public abstract void onGeolocShared(Geoloc geoloc);
+}
diff --git a/src/java/org/gsma/joyn/gsh/GeolocSharingService.java b/src/java/org/gsma/joyn/gsh/GeolocSharingService.java
new file mode 100644
index 0000000..c9f7e57
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/GeolocSharingService.java
@@ -0,0 +1,286 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.Permissions;
+import org.gsma.joyn.chat.Geoloc;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+import org.gsma.joyn.Logger;
+/**
+ * This class offers the main entry point to share geolocation info
+ * during a CS call. Several applications may connect/disconnect to
+ * the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GeolocSharingService extends JoynService {
+    /**
+     * API
+     */
+    private IGeolocSharingService api = null;
+
+    public static final String TAG = "TAPI-GeolocSharingService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public GeolocSharingService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "GeolocSharing connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IGeolocSharingService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry " + className);
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getGeolocServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IGeolocSharingService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected entry " + className);
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Shares a geolocation with a contact. An exception if thrown if there is no ongoing
+     * CS call. The parameter contact supports the following formats: MSISDN in national
+     * or international format, SIP address, SIP-URI or Tel-URI. If the format of the
+     * contact is not supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @param geoloc Geolocation info
+     * @param listener Geoloc sharing event listener
+     * @return Geoloc sharing
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     * @see Geoloc
+     */
+    public GeolocSharing shareGeoloc(String contact, Geoloc geoloc, GeolocSharingListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_LOCATION_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_LOCATION_SEND");
+        }
+        if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_USE_CHAT) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_USE_CHAT");
+        }
+
+        Logger.i(TAG, "shareGeoloc() entry contact=" + contact + " geoloc =" + geoloc + " listener =" + listener);
+        if (api != null) {
+            try {
+                IGeolocSharing sharingIntf = api.shareGeoloc(contact, geoloc, listener);
+                if (sharingIntf != null) {
+                    return new GeolocSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of geoloc sharings in progress
+     *
+     * @return List of geoloc sharings
+     * @throws JoynServiceException
+     */
+    public Set<GeolocSharing> getGeolocSharings() throws JoynServiceException {
+        Logger.i(TAG, "getGeolocSharings entry ");
+        if (api != null) {
+            try {
+                Set<GeolocSharing> result = new HashSet<GeolocSharing>();
+                List<IBinder> ishList = api.getGeolocSharings();
+                for (IBinder binder : ishList) {
+                    GeolocSharing sharing = new GeolocSharing(IGeolocSharing.Stub.asInterface(binder));
+                    result.add(sharing);
+                }
+                Logger.i(TAG, "getGeolocSharings returning " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current geoloc sharing from its unique ID
+     *
+     * @param sharingId Sharing ID
+     * @return Geoloc sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public GeolocSharing getGeolocSharing(String sharingId) throws JoynServiceException {
+        Logger.i(TAG, "getGeolocSharing entry " + sharingId);
+        if (api != null) {
+            try {
+                IGeolocSharing sharingIntf = api.getGeolocSharing(sharingId);
+                if (sharingIntf != null) {
+                    return new GeolocSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current geoloc sharing from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return Geoloc sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public GeolocSharing getGeolocSharingFor(Intent intent) throws JoynServiceException {
+        Logger.i(TAG, "getGeolocSharingFor entry " + intent);
+        if (api != null) {
+            try {
+                String sharingId = intent.getStringExtra(GeolocSharingIntent.EXTRA_SHARING_ID);
+                if (sharingId != null) {
+                    return getGeolocSharing(sharingId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a new geoloc sharing invitation listener
+     *
+     * @param listener New geoloc sharing listener
+     * @throws JoynServiceException
+     */
+    public void addNewGeolocSharingListener(NewGeolocSharingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addNewGeolocSharingListener entry " + listener);
+        if (api != null) {
+            try {
+                api.addNewGeolocSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a new geoloc sharing invitation listener
+     *
+     * @param listener New geoloc sharing listener
+     * @throws JoynServiceException
+     */
+    public void removeNewGeolocSharingListener(NewGeolocSharingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeNewGeolocSharingListener entry " + listener);
+        if (api != null) {
+            try {
+                api.removeNewGeolocSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl b/src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl
new file mode 100644
index 0000000..bf30a39
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl
@@ -0,0 +1,30 @@
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.gsh.IGeolocSharingListener;
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Geoloc sharing interface
+ */
+interface IGeolocSharing {
+
+	String getSharingId();
+
+	String getRemoteContact();
+
+	Geoloc getGeoloc();
+
+	int getState();
+	
+	int getDirection();
+		
+	void acceptInvitation();
+
+	void rejectInvitation();
+
+	void abortSharing();
+	
+	void addEventListener(in IGeolocSharingListener listener);
+
+	void removeEventListener(in IGeolocSharingListener listener);
+}
diff --git a/src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl b/src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl
new file mode 100644
index 0000000..64199bf
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl
@@ -0,0 +1,18 @@
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Callback methods for geoloc sharing events
+ */
+interface IGeolocSharingListener {
+	void onSharingStarted();
+	
+	void onSharingAborted();
+
+	void onSharingError(in int error);
+	
+	void onSharingProgress(in long currentSize, in long totalSize);
+
+	void onGeolocShared(in Geoloc geoloc);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl b/src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl
new file mode 100644
index 0000000..110a663
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl
@@ -0,0 +1,30 @@
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.gsh.IGeolocSharing;
+import org.gsma.joyn.gsh.IGeolocSharingListener;
+import org.gsma.joyn.gsh.INewGeolocSharingListener;
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Geoloc sharing service API
+ */
+interface IGeolocSharingService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	List<IBinder> getGeolocSharings();
+	
+	IGeolocSharing getGeolocSharing(in String sharingId);
+
+	IGeolocSharing shareGeoloc(in String contact, in Geoloc geoloc, in IGeolocSharingListener listener);
+	
+	void addNewGeolocSharingListener(in INewGeolocSharingListener listener);
+
+	void removeNewGeolocSharingListener(in INewGeolocSharingListener listener);
+	
+	int getServiceVersion();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl b/src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl
new file mode 100644
index 0000000..87df505
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl
@@ -0,0 +1,8 @@
+package org.gsma.joyn.gsh;
+
+/**
+ * Callback method for new geoloc sharing invitations
+ */
+interface INewGeolocSharingListener {
+	void onNewGeolocSharing(in String sharingId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/gsh/NewGeolocSharingListener.java b/src/java/org/gsma/joyn/gsh/NewGeolocSharingListener.java
new file mode 100644
index 0000000..af4da26
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/NewGeolocSharingListener.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+
+/**
+ * New geoloc sharing invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewGeolocSharingListener extends INewGeolocSharingListener.Stub {
+    /**
+     * Callback called when a new geoloc sharing invitation has been received
+     *
+     * @param sharingId Sharing ID
+     */
+    public abstract void onNewGeolocSharing(String sharingId);
+}
diff --git a/src/java/org/gsma/joyn/gsh/package-info.java b/src/java/org/gsma/joyn/gsh/package-info.java
new file mode 100644
index 0000000..ff846c2
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * This API exposes exposes all functionality related to sharing geolocations
+ * during a CS call via the Geoloc Sharing service.
+ * <p>
+ */
+package org.gsma.joyn.gsh;
diff --git a/src/java/org/gsma/joyn/ipcall/AudioCodec.aidl b/src/java/org/gsma/joyn/ipcall/AudioCodec.aidl
new file mode 100644
index 0000000..16b123c
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/AudioCodec.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * Audio codec object
+ */
+parcelable AudioCodec;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/AudioCodec.java b/src/java/org/gsma/joyn/ipcall/AudioCodec.java
new file mode 100644
index 0000000..fa615b9
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/AudioCodec.java
@@ -0,0 +1,202 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Audio codec
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class AudioCodec implements Parcelable {
+    /**
+     * Audio encoding
+     */
+    private String encoding;
+
+    /**
+     * Payload
+     */
+    private int payload;
+
+    /**
+     * Sample rate
+     */
+    private int sampleRate;
+
+    /**
+     * Audio parameters
+     */
+    private String parameters;
+
+    public static final String TAG = "AudioCodec";
+
+    /**
+     * Constructor
+     *
+     * @param encoding Audio encoding
+     * @param payload Payload
+     * @param sampleRate Sample rate
+     * @param parameters Codec parameters
+     * @hide
+     */
+    public AudioCodec(String encoding, int payload, int sampleRate, String parameters) {
+        Logger.i(TAG, "AudioCodec entry " + "encoding-" + encoding + "payload-" + "sampleRate-" + sampleRate + "parameters-" + parameters);
+        this.encoding = encoding;
+        this.payload = payload;
+        this.sampleRate = sampleRate;
+        this.parameters = parameters;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public AudioCodec(Parcel source) {
+        this.encoding = source.readString();
+        this.payload = source.readInt();
+        this.sampleRate = source.readInt();
+        this.parameters = source.readString();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(encoding);
+        dest.writeInt(payload);
+        dest.writeInt(sampleRate);
+        dest.writeString(parameters);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<AudioCodec> CREATOR
+            = new Parcelable.Creator<AudioCodec>() {
+        public AudioCodec createFromParcel(Parcel source) {
+            return new AudioCodec(source);
+        }
+
+        public AudioCodec[] newArray(int size) {
+            return new AudioCodec[size];
+        }
+    };
+
+    /**
+    * Returns the encoding name (e.g. H264)
+    *
+    * @return Encoding name
+    */
+    public String getEncoding() {
+        Logger.i(TAG, "getEncoding value " + encoding);
+        return encoding;
+    }
+
+    /**
+     * Returns the codec payload type (e.g. 96)
+     *
+     * @return Payload type
+     */
+    public int getPayloadType() {
+        Logger.i(TAG, "getPayloadType value " + payload);
+        return payload;
+    }
+
+    /**
+     * Returns the codec sample rate (e.g. 15)
+     *
+     * @return Clock rate
+     */
+    public int getSampleRate() {
+        Logger.i(TAG, "getSampleRate value " + sampleRate);
+        return sampleRate;
+    }
+
+    /**
+     * Returns the list of codec parameters (e.g. packetization-mode).
+     * Parameters are are semicolon separated.
+     *
+     * @return Parameters
+     */
+    public String getParameters() {
+        Logger.i(TAG, "getParameters value " + parameters);
+        return parameters;
+    }
+
+    /**
+     * Returns the value of codec parameter key (e.g. profile-level-id, packetization-mode).
+     *
+     * @return Parameters
+     */
+    public String getParameter(String key) {
+        String value = null;
+        String[] parameters = getParameters().split(",");
+        ArrayList<String> codecparams = new ArrayList<String>(Arrays.asList(parameters));
+        for (int i = 0; i < codecparams.size() ; i++)
+        {
+            if (codecparams.get(i).startsWith(key))
+            {
+                value = codecparams.get(i).substring(key.length() + 1);
+            }
+        }
+        Logger.i(TAG, "getParameter key - " + key + " value -" + value);
+        return value;
+    }
+
+    /**
+     * Compare codec encodings
+     *
+     * @param codec Codec to compare
+     * @return True if codecs are equals
+     */
+    public boolean compare(AudioCodec codec) {
+        boolean ret = false;
+        if (getEncoding().equalsIgnoreCase(codec.getEncoding())) {
+            ret = true;
+        }
+        Logger.i(TAG, "compare value " + ret);
+        return ret;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCall.aidl b/src/java/org/gsma/joyn/ipcall/IIPCall.aidl
new file mode 100644
index 0000000..434f0d6
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCall.aidl
@@ -0,0 +1,41 @@
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.ipcall.IIPCallListener;
+import org.gsma.joyn.ipcall.IIPCallPlayer;
+import org.gsma.joyn.ipcall.IIPCallRenderer;
+
+/**
+ * IP call interface
+ */
+interface IIPCall {
+
+	String getCallId();
+
+	String getRemoteContact();
+
+	int getState();
+
+	int getDirection();
+	
+	void acceptInvitation(IIPCallPlayer player, IIPCallRenderer renderer);
+
+	void rejectInvitation();
+
+	void abortCall();
+
+	boolean isVideo();
+
+	void addVideo();
+
+	void removeVideo();
+
+	boolean isOnHold();
+
+	void holdCall();
+
+	void continueCall();
+	
+	void addEventListener(in IIPCallListener listener);
+
+	void removeEventListener(in IIPCallListener listener);
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl
new file mode 100644
index 0000000..4f32392
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl
@@ -0,0 +1,17 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * Callback methods for IP call events
+ */
+interface IIPCallListener {	
+
+	void onCallStarted();
+	
+	void onCallAborted();
+
+	void onCallHeld();
+
+	void onCallContinue();
+
+	void onCallError(in int error);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl
new file mode 100644
index 0000000..51f28e1
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl
@@ -0,0 +1,34 @@
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.ipcall.IIPCallPlayerListener;
+import org.gsma.joyn.ipcall.AudioCodec;
+import org.gsma.joyn.ipcall.VideoCodec;
+
+/**
+ * IP call player interface
+ */
+interface IIPCallPlayer {
+	void open(in AudioCodec audiocodec, in VideoCodec videocodec, in String remoteHost, in int remoteAudioPort, in int remoteVideoPort);
+	
+	void close();
+
+	void start();
+
+	void stop();
+
+	int getLocalAudioRtpPort();
+
+	AudioCodec getAudioCodec();
+
+	AudioCodec[] getSupportedAudioCodecs();
+
+	int getLocalVideoRtpPort();
+
+	VideoCodec getVideoCodec();
+	
+	VideoCodec[] getSupportedVideoCodecs();
+
+	void addEventListener(in IIPCallPlayerListener listener);
+
+	void removeEventListener(in IIPCallPlayerListener listener);
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl
new file mode 100644
index 0000000..9414885
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * IP call player event listener interface
+ */
+interface IIPCallPlayerListener {
+	void onPlayerOpened();
+
+	void onPlayerStarted();
+
+	void onPlayerStopped();
+
+	void onPlayerClosed();
+
+	void onPlayerFailed();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl
new file mode 100644
index 0000000..927d52e
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl
@@ -0,0 +1,34 @@
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.ipcall.IIPCallRendererListener;
+import org.gsma.joyn.ipcall.AudioCodec;
+import org.gsma.joyn.ipcall.VideoCodec;
+
+/**
+ * IP call renderer interface
+ */
+interface IIPCallRenderer {
+	void open(in AudioCodec audiocodec, in VideoCodec videocodec, in String remoteHost, in int remoteAudioPort, in int remoteVideoPort);
+
+	void close();
+
+	void start();
+
+	void stop();
+
+	int getLocalAudioRtpPort();
+
+	AudioCodec getAudioCodec();
+
+	AudioCodec[] getSupportedAudioCodecs();
+
+	int getLocalVideoRtpPort();
+
+	VideoCodec getVideoCodec();
+	
+	VideoCodec[] getSupportedVideoCodecs();
+
+	void addEventListener(in IIPCallRendererListener listener);
+
+	void removeEventListener(in IIPCallRendererListener listener);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl
new file mode 100644
index 0000000..46786a1
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * IP call renderer event listener interface
+ */
+interface IIPCallRendererListener {
+	void onRendererOpened();
+
+	void onRendererStarted();
+
+	void onRendererStopped();
+
+	void onRendererClosed();
+
+	void onRendererFailed();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallService.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallService.aidl
new file mode 100644
index 0000000..52b3f08
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallService.aidl
@@ -0,0 +1,36 @@
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.ipcall.IIPCall;
+import org.gsma.joyn.ipcall.IIPCallListener;
+import org.gsma.joyn.ipcall.INewIPCallListener;
+import org.gsma.joyn.ipcall.IIPCallPlayer;
+import org.gsma.joyn.ipcall.IIPCallRenderer;
+import org.gsma.joyn.ipcall.IPCallServiceConfiguration;
+
+/**
+ * IP call service API
+ */
+interface IIPCallService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	IPCallServiceConfiguration getConfiguration();
+
+	List<IBinder> getIPCalls();
+	
+	IIPCall getIPCall(in String callId);
+
+	IIPCall initiateCall(in String contact, in IIPCallPlayer player, in IIPCallRenderer renderer, in IIPCallListener listener);
+	
+	IIPCall initiateVisioCall(in String contact, in IIPCallPlayer player, in IIPCallRenderer renderer, in IIPCallListener listener);
+
+	void addNewIPCallListener(in INewIPCallListener listener);
+
+	void removeNewIPCallListener(in INewIPCallListener listener);
+	
+	int getServiceVersion();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl b/src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl
new file mode 100644
index 0000000..6981562
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl
@@ -0,0 +1,8 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * Callback method for new IP call invitations
+ */
+interface INewIPCallListener {
+	void onNewIPCall(in String callId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/IPCall.java b/src/java/org/gsma/joyn/ipcall/IPCall.java
new file mode 100644
index 0000000..26e7c09
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCall.java
@@ -0,0 +1,361 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.JoynServiceException;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * IP call
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCall {
+
+    /**
+     * IP call state
+     */
+
+    public static final String TAG = "IPCall";
+
+
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Call invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Call invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Call is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * call has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Call has been terminated
+         */
+        public static final int TERMINATED = 6;
+
+        /**
+         * Call has failed
+         */
+        public final static int FAILED = 7;
+
+        /**
+         * Call on hold
+         */
+        public final static int HOLD = 8;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the call
+     */
+    public static class Direction {
+        /**
+         * Incoming call
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing call
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Call error
+     */
+    public static class Error {
+        /**
+         * Call has failed
+         */
+        public final static int CALL_FAILED = 0;
+
+        /**
+         * Call invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * IP call interface
+     */
+    private IIPCall callInf;
+
+    /**
+     * Constructor
+     *
+     * @param callInf IP call interface
+     */
+    IPCall(IIPCall callInf) {
+        this.callInf = callInf;
+    }
+
+    /**
+     * Returns the call ID of call
+     *
+     * @return Call ID
+     * @throws JoynServiceException
+     */
+    public String getCallId() throws JoynServiceException {
+        Logger.i(TAG, "getCallId entry");
+        try {
+            String callId = callInf.getCallId();
+            Logger.i(TAG, "getCallId entry" + callId);
+            return callId;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact entry");
+        try {
+            String contact = callInf.getRemoteContact();
+            Logger.i(TAG, "getRemoteContact value " + contact);
+            return contact;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the call
+     *
+     * @return State
+     * @see IPCall.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        Logger.i(TAG, "getState entry");
+        try {
+            int State = callInf.getState();
+            Logger.i(TAG, "getState value " + State);
+            return State;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the call (incoming or outgoing)
+     *
+     * @return Direction
+     * @see IPCall.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        Logger.i(TAG, "getDirection entry");
+        try {
+            int direction = callInf.getDirection();
+            Logger.i(TAG, "getDirection value" + direction);
+            return direction;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts call invitation
+     *
+     * @param player IP call player
+     * @param renderer IP call renderer
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation(IPCallPlayer player, IPCallRenderer renderer) throws JoynServiceException {
+        try {
+            Logger.i(TAG, "acceptInvitation entry");
+            callInf.acceptInvitation(player, renderer);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects call invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "rejectInvitation entry");
+            callInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the call
+     *
+     * @throws JoynServiceException
+     */
+    public void abortCall() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "abortCall entry");
+            callInf.abortCall();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Is video activated
+     *
+     * @return Boolean
+     * @throws JoynServiceException
+     */
+    public boolean isVideo() throws JoynServiceException {
+        try {
+            boolean isVideo = callInf.isVideo();
+            Logger.i(TAG, "abortCall value" + isVideo);
+            return isVideo;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Add video stream
+     *
+     * @throws JoynServiceException
+     */
+    public void addVideo() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "addVideo entry");
+            callInf.addVideo();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Remove video stream
+     *
+     * @throws JoynServiceException
+     */
+    public void removeVideo() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "removeVideo entry");
+            callInf.removeVideo();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Is call on hold
+     *
+     * @return Boolean
+     * @throws JoynServiceException
+     */
+    public boolean isOnHold() throws JoynServiceException {
+        try {
+            boolean isonHold = callInf.isOnHold();
+            Logger.i(TAG, "isOnHold value" + isonHold);
+            return isonHold;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Puts the call on hold
+     *
+     * @throws JoynServiceException
+     */
+    public void holdCall() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "holdCall entry");
+            callInf.holdCall();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Continues the call that hold's on
+     *
+     * @throws JoynServiceException
+     */
+    public void continueCall() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "continueCall entry");
+            callInf.continueCall();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on IP call events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(IPCallListener listener) throws JoynServiceException {
+        try {
+            Logger.i(TAG, "addEventListener entry" + listener);
+            callInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from IP call events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(IPCallListener listener) throws JoynServiceException {
+        try {
+            Logger.i(TAG, "removeEventListener entry" + listener);
+            callInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallIntent.java b/src/java/org/gsma/joyn/ipcall/IPCallIntent.java
new file mode 100644
index 0000000..248545e
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallIntent.java
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+/**
+ * Intent for IP call invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCallIntent {
+    /**
+     * Broadcast action: a new IP call invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_CALL_ID} containing the unique ID of the IP call.
+     * <li> {@link #EXTRA_AUDIO_ENCODING} containing the audio encoding.
+     * <li> {@link #EXTRA_VIDEO_ENCODING} containing the video encoding.
+     * <li> {@link #EXTRA_VIDEO_FORMAT} containing the video format.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.ipcall.action.NEW_CALL";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the call
+     */
+    public final static String EXTRA_CALL_ID = "callId";
+
+    /**
+     * Audio encoding (e.g. AMR)
+     */
+    public final static String EXTRA_AUDIO_ENCODING = "audioEncoding";
+
+    /**
+     * Video encoding (e.g. H264)
+     */
+    public final static String EXTRA_VIDEO_ENCODING = "videoEncoding";
+
+    /**
+     * Video format (e.g. QCIF)
+     */
+    public final static String EXTRA_VIDEO_FORMAT = "videoFormat";
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallListener.java b/src/java/org/gsma/joyn/ipcall/IPCallListener.java
new file mode 100644
index 0000000..b4d88c1
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallListener.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+
+/**
+ * IP call event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallListener extends IIPCallListener.Stub {
+
+
+    /**
+     * Callback called when the call is started
+     */
+    public abstract void onCallStarted();
+
+    /**
+     * Callback called when the call has been aborted or terminated
+     */
+    public abstract void onCallAborted();
+
+    /**
+     * Callback called when the call has failed
+     *
+     * @param error Error
+     * @see IPCall.Error
+     */
+    public abstract void onCallError(int error);
+
+    /**
+     * Callback called when the call has been held
+     */
+    public abstract void onCallHeld();
+
+    /**
+     * Callback called when the call continues after on hold
+     */
+    public abstract void onCallContinue();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallLog.java b/src/java/org/gsma/joyn/ipcall/IPCallLog.java
new file mode 100644
index 0000000..054c463
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallLog.java
@@ -0,0 +1,77 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import android.net.Uri;
+
+/**
+ * Content provider for IP call history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCallLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.ipcall/ipcall");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the call.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CALL_ID = "call_id";
+
+    /**
+     * The name of the column containing the MSISDN of the remote party.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the direction of the call.
+     * <P>Type: INTEGER</P>
+     * @see IPCall.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the date of the call (in milliseconds).
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the duration of the call (in seconds). The
+     * value is only set at the end of the call.
+     * <P>Type: LONG</P>
+     */
+    public static final String DURATION = "duration";
+
+    /**
+     * The name of the column containing the state of the call.
+     * <P>Type: INTEGER</P>
+     * @see IPCall.State
+     */
+    public static final String STATE = "state";
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallPlayer.java b/src/java/org/gsma/joyn/ipcall/IPCallPlayer.java
new file mode 100644
index 0000000..ada02d4
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallPlayer.java
@@ -0,0 +1,167 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.HashSet;
+import java.util.Set;
+
+
+
+/**
+ * IP call player offers an interface to manage the IP call player instance
+ * independently of the joyn service. The IP call player is implemented in
+ * the application side. The IP call player captures the audio/video from the
+ * device micro/camera, encodes the audio/video into the selected formats,
+ * streams the encoded audio samples and video frames over the network in RTP.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallPlayer extends IIPCallPlayer.Stub {
+    /**
+     * IP call player error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Network connection failed
+         */
+        public final static int NETWORK_FAILURE = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * IP call player event listeners
+     */
+    private Set<IPCallPlayerListener> listeners = new HashSet<IPCallPlayerListener>();
+
+    /**
+     * Constructor
+     */
+    public IPCallPlayer() {
+    }
+
+    /**
+     * Opens the player and prepares resources (e.g. encoder, micro, camera)
+     *
+     * @param audiocodec Audio codec
+     * @param videocodec Video codec
+     * @param remoteHost Remote RTP host
+     * @param remoteAudioPort Remote audio RTP port
+     * @param remoteVideoPort Remote video RTP port
+     */
+    public abstract void open(AudioCodec audiocodec, VideoCodec videocodec, String remoteHost, int remoteAudioPort, int remoteVideoPort);
+
+    /**
+     * Closes the player and deallocates resources
+     *
+     * @throws JoynServiceException
+     */
+    public abstract void close();
+
+    /**
+     * Starts the player
+     */
+    public abstract void start();
+
+    /**
+     * Stops the player
+     */
+    public abstract void stop();
+
+    /**
+     * Returns the local RTP port used to stream audio
+     *
+     * @return Port number
+     */
+    public abstract int getLocalAudioRtpPort();
+
+    /**
+     * Returns the current audio codec
+     *
+     * @return Audo codec
+     */
+    public abstract AudioCodec getAudioCodec();
+
+    /**
+     * Returns the list of audio codecs supported by the player
+     *
+     * @return List of audio codecs
+     */
+    public abstract AudioCodec[] getSupportedAudioCodecs();
+
+    /**
+     * Returns the local RTP port used to stream video
+     *
+     * @return Port number
+     */
+    public abstract int getLocalVideoRtpPort();
+
+    /**
+     * Returns the current video codec
+     *
+     * @return Video codec
+     */
+    public abstract VideoCodec getVideoCodec();
+
+    /**
+     * Returns the list of video codecs supported by the player
+     *
+     * @return List of video codecs
+     */
+    public abstract VideoCodec[] getSupportedVideoCodecs();
+
+    /**
+     * Returns the list of player event listeners
+     *
+     * @return Listeners
+     */
+    public Set<IPCallPlayerListener> getEventListeners() {
+        return listeners;
+    }
+
+    /**
+     * Adds a listener on player events
+     *
+     * @param listener Listener
+     */
+    public void addEventListener(IPCallPlayerListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a listener from player events
+     *
+     * @param listener Listener
+     */
+    public void removeEventListener(IPCallPlayerListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all listeners from player events
+     */
+    public void removeAllEventListeners() {
+        listeners.clear();
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallPlayerListener.java b/src/java/org/gsma/joyn/ipcall/IPCallPlayerListener.java
new file mode 100644
index 0000000..65083c5
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallPlayerListener.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+
+/**
+ * This class offers callback methods on IP call player events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallPlayerListener extends IIPCallPlayerListener.Stub {
+    /**
+     * Callback called when the player is opened
+     */
+    public abstract void onPlayerOpened();
+
+    /**
+     * Callback called when the player is started
+     */
+    public abstract void onPlayerStarted();
+
+    /**
+     * Callback called when the player is stopped
+     */
+    public abstract void onPlayerStopped();
+
+    /**
+     * Callback called when the player is closed
+     */
+    public abstract void onPlayerClosed();
+
+    /**
+     * Callback called when the player has failed
+     *
+     * @param error Error
+     */
+    public abstract void onPlayerFailed();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallRenderer.java b/src/java/org/gsma/joyn/ipcall/IPCallRenderer.java
new file mode 100644
index 0000000..588b527
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallRenderer.java
@@ -0,0 +1,163 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * IP call renderer offers an interface to manage the IP call renderer instance
+ * independently of the joyn service. The IP call renderer is implemented in
+ * the application side. The IP call renderer receives the audio/video streaming
+ * over the network in RTP, decodes the audio samples and video frames, plays
+ * decoded audio samples and displays the decoded picture on the device screen.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallRenderer extends IIPCallRenderer.Stub {
+    /**
+     * IP call renderer error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Network connection failed
+         */
+        public final static int NETWORK_FAILURE = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * IP call renderer event listeners
+     */
+    private Set<IPCallRendererListener> listeners = new HashSet<IPCallRendererListener>();
+
+    /**
+     * Constructor
+     */
+    public IPCallRenderer() {
+    }
+
+    /**
+     * Opens the renderer and prepares resources (e.g. decoder)
+     *
+     * @param audiocodec Audio codec
+     * @param videocodec Video codec
+     * @param remoteHost Remote RTP host
+     * @param remoteAudioPort Remote audio RTP port
+     * @param remoteVideoPort Remote video RTP port
+     */
+    public abstract void open(AudioCodec audiocodec, VideoCodec videocodec, String remoteHost, int remoteAudioPort, int remoteVideoPort);
+
+    /**
+     * Closes the renderer and deallocates resources
+     */
+    public abstract void close();
+
+    /**
+     * Starts the renderer
+     */
+    public abstract void start();
+
+    /**
+     * Stops the renderer
+     */
+    public abstract void stop();
+
+    /**
+     * Returns the current audio codec
+     *
+     * @return Audo codec
+     */
+    public abstract AudioCodec getAudioCodec();
+
+    /**
+     * Returns the list of audio codecs supported by the player
+     *
+     * @return List of audio codecs
+     */
+    public abstract AudioCodec[] getSupportedAudioCodecs();
+
+    /**
+     * Returns the local RTP port used to stream video
+     *
+     * @return Port number
+     */
+    public abstract int getLocalVideoRtpPort();
+
+    /**
+     * Returns the local RTP port used to stream audio
+     *
+     * @return Port number
+     */
+    public abstract int getLocalAudioRtpPort();
+
+    /**
+     * Returns the current video codec
+     *
+     * @return Video codec
+     */
+    public abstract VideoCodec getVideoCodec();
+
+    /**
+     * Returns the list of video codecs supported by the player
+     *
+     * @return List of video codecs
+     */
+    public abstract VideoCodec[] getSupportedVideoCodecs();
+
+    /**
+     * Returns the list of renderer event listeners
+     *
+     * @return Listeners
+     */
+    public Set<IPCallRendererListener> getEventListeners() {
+        return listeners;
+    }
+
+    /**
+     * Adds a listener on renderer events
+     *
+     * @param listener Listener
+     */
+    public void addEventListener(IPCallRendererListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a listener from renderer events
+     *
+     * @param listener Listener
+     */
+    public void removeEventListener(IPCallRendererListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all listeners from renderer events
+     */
+    public void removeAllEventListeners() {
+        listeners.clear();
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallRendererListener.java b/src/java/org/gsma/joyn/ipcall/IPCallRendererListener.java
new file mode 100644
index 0000000..72cf6e7
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallRendererListener.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+
+/**
+ * This class offers callback methods on IP call renderer events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallRendererListener extends IIPCallRendererListener.Stub {
+    /**
+     * Callback called when the renderer is opened
+     */
+    public abstract void onRendererOpened();
+
+    /**
+     * Callback called when the renderer is started
+     */
+    public abstract void onRendererStarted();
+
+    /**
+     * Callback called when the renderer is stopped
+     */
+    public abstract void onRendererStopped();
+
+    /**
+     * Callback called when the renderer is closed
+     */
+    public abstract void onRendererClosed();
+
+    /**
+     * Callback called when the renderer has failed
+     *
+     * @param error Error
+     */
+    public abstract void onRendererFailed();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallService.java b/src/java/org/gsma/joyn/ipcall/IPCallService.java
new file mode 100644
index 0000000..8a0a8f1
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallService.java
@@ -0,0 +1,415 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+import org.gsma.joyn.Permissions;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.os.IBinder;
+import android.os.IInterface;
+
+import android.os.RemoteException;
+import org.gsma.joyn.Logger;
+
+/**
+ * This class offers the main entry point to initiate IP calls. Several
+ * applications may connect/disconnect to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCallService extends JoynService {
+    /**
+     * API
+     */
+    private IIPCallService api = null;
+
+    public static final String TAG = "IPCallService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public IPCallService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_USE_IPCALL) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_USE_IPCALL");
+        }
+        Logger.i(TAG, "connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+        Logger.i(TAG, "setApi() entry" + api);
+        this.api = (IIPCallService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected() entry");
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getIPCallServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IIPCallService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected() entry");
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of IP call service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public IPCallServiceConfiguration getConfiguration() throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "getConfiguration() entry");
+            try {
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates an IP call with a contact (audio only). The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or Tel-URI. If the
+     * format of the contact is not supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @param player IP call player
+     * @param renderer IP call renderer
+     * @param listener IP call event listener
+     * @return IP call
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public IPCall initiateCall(String contact, IPCallPlayer player, IPCallRenderer renderer, IPCallListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            Logger.i(TAG, "initiateCall() entry" + "contact" + contact + "player" + player + "renderer" + renderer +  "listener" + listener);
+            try {
+                IIPCall callIntf = api.initiateCall(contact, player, renderer, listener);
+                if (callIntf != null) {
+                    return new IPCall(callIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates an IP call visio with a contact (audio and video). The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or Tel-URI. If the format of
+     * the contact is not supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @param player IP call player
+     * @param renderer IP call renderer
+     * @param listener IP call event listener
+     * @return IP call
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public IPCall initiateVisioCall(String contact, IPCallPlayer player, IPCallRenderer renderer, IPCallListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            try {
+                Logger.i(TAG, "initiateVisioCall() entry" + "contact" + contact + "player" + player + "renderer" + renderer +  "listener" + listener);
+                IIPCall callIntf = api.initiateVisioCall(contact, player, renderer, listener);
+                if (callIntf != null) {
+                    return new IPCall(callIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of IP calls in progress
+     *
+     * @return List of IP calls
+     * @throws JoynServiceException
+     */
+    public Set<IPCall> getIPCalls() throws JoynServiceException {
+        if (api != null) {
+            try {
+                Set<IPCall> result = new HashSet<IPCall>();
+                List<IBinder> vshList = api.getIPCalls();
+                for (IBinder binder : vshList) {
+                    IPCall call = new IPCall(IIPCall.Stub.asInterface(binder));
+                    result.add(call);
+                }
+                Logger.i(TAG, "getIPCalls() value - " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current IP call from its unique ID
+     *
+     * @param callId Call ID
+     * @return IP call or null if not found
+     * @throws JoynServiceException
+     */
+    public IPCall getIPCall(String callId) throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "getIPCall() entry");
+            try {
+                IIPCall callIntf = api.getIPCall(callId);
+                if (callIntf != null) {
+                    return new IPCall(callIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current IP call from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return IP call or null if not found
+     * @throws JoynServiceException
+     */
+    public IPCall getIPCallFor(Intent intent) throws JoynServiceException {
+        if (api != null) {
+            try {
+                Logger.i(TAG, "getIPCallFor() entry");
+                String callId = intent.getStringExtra(IPCallIntent.EXTRA_CALL_ID);
+                if (callId != null) {
+                    return getIPCall(callId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        Logger.i(TAG, "getServiceVersion() entry");
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                    Logger.i(TAG, "getServiceVersion() value" + version);
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "isServiceRegistered() entry");
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+                Logger.i(TAG, "isServiceRegistered() value" + serviceStatus);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a new IP call invitation listener
+     *
+     * @param listener New IP call listener
+     * @throws JoynServiceException
+     */
+    public void addNewIPCallListener(NewIPCallListener listener) throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "addNewIPCallListener() entry" + listener);
+            try {
+                api.addNewIPCallListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a new IP call invitation listener
+     *
+     * @param listener New IP call listener
+     * @throws JoynServiceException
+     */
+    public void removeNewIPCallListener(NewIPCallListener listener) throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "removeNewIPCallListener() entry" + listener);
+            try {
+                api.removeNewIPCallListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.aidl b/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.aidl
new file mode 100644
index 0000000..e13b080
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * IP call configuration object
+ */
+parcelable IPCallServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.java b/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.java
new file mode 100644
index 0000000..fa605d5
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.java
@@ -0,0 +1,108 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * IP call service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCallServiceConfiguration implements Parcelable {
+    /**
+     * Voice call breakout
+     */
+    private boolean voiceBreakout;
+
+    public static final String TAG = "IPCallServiceConfiguration";
+
+    /**
+     * Constructor
+     *
+     * @param voiceBreakout Voice call breakout
+     * @hide
+     */
+    public IPCallServiceConfiguration(boolean voiceBreakout) {
+        Logger.i(TAG, "IPCallServiceConfiguration entry" + voiceBreakout);
+        this.voiceBreakout = voiceBreakout;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public IPCallServiceConfiguration(Parcel source) {
+        this.voiceBreakout = source.readInt() != 0;
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(voiceBreakout ? 1 : 0);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<IPCallServiceConfiguration> CREATOR
+            = new Parcelable.Creator<IPCallServiceConfiguration>() {
+        public IPCallServiceConfiguration createFromParcel(Parcel source) {
+            return new IPCallServiceConfiguration(source);
+        }
+
+        public IPCallServiceConfiguration[] newArray(int size) {
+            return new IPCallServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Is voice call breakout activated. It returns True if the service can reach
+     * any user, else returns False if only joyn users supporting the IP call
+     * capability may be called.
+     *
+     * @return Boolean
+     */
+    public boolean isVoiceCallBreakout() {
+        Logger.i(TAG, "isVoiceCallBreakout value " + voiceBreakout);
+        return voiceBreakout;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/NewIPCallListener.java b/src/java/org/gsma/joyn/ipcall/NewIPCallListener.java
new file mode 100644
index 0000000..40cea4b
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/NewIPCallListener.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+
+/**
+ * New IP call invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewIPCallListener extends INewIPCallListener.Stub {
+    /**
+     * Callback called when a new IP call invitation has been received
+     *
+     * @param callId Call ID
+     */
+    public abstract void onNewIPCall(String callId);
+}
diff --git a/src/java/org/gsma/joyn/ipcall/VideoCodec.aidl b/src/java/org/gsma/joyn/ipcall/VideoCodec.aidl
new file mode 100644
index 0000000..363d4be
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/VideoCodec.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * Video codec object
+ */
+parcelable VideoCodec;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/VideoCodec.java b/src/java/org/gsma/joyn/ipcall/VideoCodec.java
new file mode 100644
index 0000000..4d01ac4
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/VideoCodec.java
@@ -0,0 +1,291 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.gsma.joyn.H264Config;
+import org.gsma.joyn.Logger;
+
+
+/**
+ * Video codec
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoCodec implements Parcelable {
+    /**
+     * Video encoding
+     */
+    private String encoding;
+
+    /**
+     * Payload
+     */
+    private int payload;
+
+    /**
+     * Clock rate
+     */
+    private int clockRate;
+
+    /**
+     * Frame rate
+     */
+    private int frameRate;
+
+    /**
+     * Bit rate
+     */
+    private int bitRate;
+
+    /**
+     * Screen width
+     */
+    private int width;
+
+    /**
+     * Screen height
+     */
+    private int height;
+
+    /**
+     * Video parameters
+     */
+    private String parameters;
+
+    public static final String TAG = "VideoCodec";
+
+    /**
+     * Constructor
+     *
+     * @param encoding Video encoding
+     * @param payload Payload
+     * @param clockRate Clock rate
+     * @param framerate Frame rate
+     * @param bitRate Bit rate
+     * @param width Video width
+     * @param height Video height
+     * @param parameters Codec parameters
+     * @hide
+     */
+    public VideoCodec(String encoding, int payload, int clockRate, int frameRate, int bitRate, int width, int height, String parameters) {
+        Logger.i(TAG, "VideoCodec entry" + "encoding" + encoding + "payload" + "clockRate" + clockRate + "frameRate" + frameRate + "bitRate" +
+        bitRate + "width" + width + "height" + height +  "parameters" + parameters);
+        this.encoding = encoding;
+        this.payload = payload;
+        this.clockRate = clockRate;
+        this.frameRate = frameRate;
+        this.bitRate = bitRate;
+        this.width = width;
+        this.height = height;
+        this.parameters = parameters;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public VideoCodec(Parcel source) {
+        this.encoding = source.readString();
+        this.payload = source.readInt();
+        this.clockRate = source.readInt();
+        this.frameRate = source.readInt();
+        this.bitRate = source.readInt();
+        this.width = source.readInt();
+        this.height = source.readInt();
+        this.parameters = source.readString();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(encoding);
+        dest.writeInt(payload);
+        dest.writeInt(clockRate);
+        dest.writeInt(frameRate);
+        dest.writeInt(bitRate);
+        dest.writeInt(width);
+        dest.writeInt(height);
+        dest.writeString(parameters);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<VideoCodec> CREATOR
+            = new Parcelable.Creator<VideoCodec>() {
+        public VideoCodec createFromParcel(Parcel source) {
+            return new VideoCodec(source);
+        }
+
+        public VideoCodec[] newArray(int size) {
+            return new VideoCodec[size];
+        }
+    };
+
+    /**
+    * Returns the encoding name (e.g. H264)
+    *
+    * @return Encoding name
+    */
+    public String getEncoding() {
+        Logger.i(TAG, "getEncoding value " + encoding);
+        return encoding;
+    }
+
+    /**
+     * Returns the codec payload type (e.g. 96)
+     *
+     * @return Payload type
+     */
+    public int getPayloadType() {
+        Logger.i(TAG, "getPayloadType value " + payload);
+        return payload;
+    }
+
+    /**
+     * Returns the codec clock rate (e.g. 90000)
+     *
+     * @return Clock rate
+     */
+    public int getClockRate() {
+        Logger.i(TAG, "getClockRate value " + clockRate);
+        return clockRate;
+    }
+
+    /**
+     * Returns the codec frame rate (e.g. 10)
+     *
+     * @return Frame rate
+     */
+    public int getFrameRate() {
+        Logger.i(TAG, "getFrameRate value " + frameRate);
+        return frameRate;
+    }
+
+    /**
+     * Returns the codec bit rate (e.g. 64000)
+     *
+     * @return Bit rate
+     */
+    public int getBitRate() {
+        Logger.i(TAG, "getBitRate value " + bitRate);
+        return bitRate;
+    }
+
+    /**
+     * Returns the video width (e.g. 176)
+     *
+     * @return Video width
+     */
+    public int getVideoWidth() {
+        Logger.i(TAG, "getVideoWidth value " + width);
+        return width;
+    }
+
+    /**
+     * Returns the video height (e.g. 144)
+     *
+     * @return Video height
+     */
+    public int getVideoHeight() {
+        Logger.i(TAG, "getVideoHeight value " + height);
+        return height;
+    }
+
+    /**
+     * Returns the list of codec parameters (e.g. profile-level-id, packetization-mode).
+     * Parameters are are semicolon separated.
+     *
+     * @return Parameters
+     */
+    public String getParameters() {
+        Logger.i(TAG, "getParameters value " + parameters);
+        return parameters;
+    }
+
+    /**
+     * Returns the value of codec parameter key (e.g. profile-level-id, packetization-mode).
+     *
+     * @return Parameters
+     */
+    public String getParameter(String key) {
+        String value = null;
+        String[] parameters = getParameters().split(",");
+        ArrayList<String> codecparams = new ArrayList<String>(Arrays.asList(parameters));
+        for (int i = 0; i < codecparams.size() ; i++)
+        {
+            if (codecparams.get(i).startsWith(key))
+            {
+                value = codecparams.get(i).substring(key.length() + 1);
+            }
+        }
+        Logger.i(TAG, "getParameter value " + value);
+        return value;
+    }
+
+    /**
+     * Compare codec
+     *
+     * @param codec Codec to compare
+     * @return Returns True if codecs are equals, else returns False
+     */
+    public boolean compare(VideoCodec codec) {
+        boolean ret = false;
+        if (getEncoding().equalsIgnoreCase(codec.getEncoding())
+                && (getVideoWidth() == codec.getVideoWidth() || getVideoWidth() == 0 || codec.getVideoWidth() == 0)
+                && (getVideoHeight() == codec.getVideoHeight() || getVideoHeight() == 0 || codec.getVideoHeight() == 0)) {
+            if (getEncoding().equalsIgnoreCase(H264Config.CODEC_NAME)) {
+                if (H264Config.getCodecProfileLevelId(getParameters()).compareToIgnoreCase(H264Config.getCodecProfileLevelId(codec.getParameters())) == 0) {
+                    ret =  true;
+                }
+            } else {
+                if (getParameters().equalsIgnoreCase(codec.getParameters())) {
+                    ret = true;
+                }
+            }
+        }
+        Logger.i(TAG, "compare value " + ret);
+        return ret;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/package-info.java b/src/java/org/gsma/joyn/ipcall/package-info.java
new file mode 100644
index 0000000..4bdb9fa
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * This API exposes all functionality related to IP voice call and IP video call services.
+ * <p>
+ */
+package org.gsma.joyn.ipcall;
diff --git a/src/java/org/gsma/joyn/ish/IImageSharing.aidl b/src/java/org/gsma/joyn/ish/IImageSharing.aidl
new file mode 100644
index 0000000..6e38443
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/IImageSharing.aidl
@@ -0,0 +1,33 @@
+package org.gsma.joyn.ish;
+
+import org.gsma.joyn.ish.IImageSharingListener;
+
+/**
+ * Image sharing interface
+ */
+interface IImageSharing {
+
+	String getSharingId();
+
+	String getRemoteContact();
+
+	String getFileName();
+
+	long getFileSize();
+
+	String getFileType();
+
+	int getState();
+	
+	int getDirection();
+		
+	void acceptInvitation();
+
+	void rejectInvitation();
+
+	void abortSharing();
+	
+	void addEventListener(in IImageSharingListener listener);
+
+	void removeEventListener(in IImageSharingListener listener);
+}
diff --git a/src/java/org/gsma/joyn/ish/IImageSharingListener.aidl b/src/java/org/gsma/joyn/ish/IImageSharingListener.aidl
new file mode 100644
index 0000000..5258290
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/IImageSharingListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.ish;
+
+/**
+ * Callback methods for image sharing events
+ */
+interface IImageSharingListener {
+	void onSharingStarted();
+	
+	void onSharingAborted();
+
+	void onSharingError(in int error);
+	
+	void onSharingProgress(in long currentSize, in long totalSize);
+
+	void onImageShared(in String filename);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ish/IImageSharingService.aidl b/src/java/org/gsma/joyn/ish/IImageSharingService.aidl
new file mode 100644
index 0000000..dd2ef78
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/IImageSharingService.aidl
@@ -0,0 +1,34 @@
+package org.gsma.joyn.ish;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.ish.IImageSharing;
+import org.gsma.joyn.ish.IImageSharingListener;
+import org.gsma.joyn.ish.INewImageSharingListener;
+import org.gsma.joyn.ish.ImageSharingServiceConfiguration;
+
+/**
+ * Image sharing service API
+ */
+interface IImageSharingService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	ImageSharingServiceConfiguration getConfiguration();
+    
+	List<IBinder> getImageSharings();
+	
+	String getJoynAccountViaNumber(in String number);
+	
+	IImageSharing getImageSharing(in String sharingId);
+
+	IImageSharing shareImage(in String contact, in String filename, in IImageSharingListener listener);
+	
+	void addNewImageSharingListener(in INewImageSharingListener listener);
+
+	void removeNewImageSharingListener(in INewImageSharingListener listener);
+	
+	int getServiceVersion();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl b/src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl
new file mode 100644
index 0000000..d260046
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl
@@ -0,0 +1,8 @@
+package org.gsma.joyn.ish;
+
+/**
+ * Callback method for new image sharing invitations
+ */
+interface INewImageSharingListener {
+	void onNewImageSharing(in String sharingId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ish/ImageSharing.java b/src/java/org/gsma/joyn/ish/ImageSharing.java
new file mode 100644
index 0000000..656b9bf
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharing.java
@@ -0,0 +1,290 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+import org.gsma.joyn.JoynServiceException;
+
+/**
+ * Image sharing
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharing {
+
+    /**
+     * Image sharing state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Sharing invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Sharing invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Sharing is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Image has been transferred with success
+         */
+        public final static int TRANSFERRED = 4;
+
+        /**
+         * Sharing has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Sharing has failed
+         */
+        public final static int FAILED = 6;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the sharing
+     */
+    public static class Direction {
+        /**
+         * Incoming sharing
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing sharing
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Image sharing error
+     */
+    public static class Error {
+        /**
+         * Sharing has failed
+         */
+        public final static int SHARING_FAILED = 0;
+
+        /**
+         * Sharing invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        /**
+         * Image saving has failed
+         */
+        public final static int SAVING_FAILED = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Image sharing interface
+     */
+    private IImageSharing sharingInf;
+
+    /**
+     * Constructor
+     *
+     * @param sharingInf Image sharing interface
+     */
+    ImageSharing(IImageSharing sharingInf) {
+        this.sharingInf = sharingInf;
+    }
+
+    /**
+     * Returns the sharing ID of the image sharing
+     *
+     * @return Sharing ID
+     * @throws JoynServiceException
+     */
+    public String getSharingId() throws JoynServiceException {
+        try {
+            return sharingInf.getSharingId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        try {
+            return sharingInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the complete filename including the path of the file to be transferred
+     *
+     * @return Filename
+     * @throws JoynServiceException
+     */
+    public String getFileName() throws JoynServiceException {
+        try {
+            return sharingInf.getFileName();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the size of the file to be transferred
+     *
+     * @return Size in bytes
+     * @throws JoynServiceException
+     */
+    public long getFileSize() throws JoynServiceException {
+        try {
+            return sharingInf.getFileSize();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the MIME type of the file to be transferred
+     *
+     * @return Type
+     * @throws JoynServiceException
+     */
+    public String getFileType() throws JoynServiceException {
+        try {
+            return sharingInf.getFileType();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the sharing
+     *
+     * @return State
+     * @see ImageSharing.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        try {
+            return sharingInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the sharing (incoming or outgoing)
+     *
+     * @return Direction
+     * @see ImageSharing.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        try {
+            return sharingInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts image sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        try {
+            sharingInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects image sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        try {
+            sharingInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the sharing
+     *
+     * @throws JoynServiceException
+     */
+    public void abortSharing() throws JoynServiceException {
+        try {
+            sharingInf.abortSharing();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on image sharing events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(ImageSharingListener listener) throws JoynServiceException {
+        try {
+            sharingInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from image sharing
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(ImageSharingListener listener) throws JoynServiceException {
+        try {
+            sharingInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingIntent.java b/src/java/org/gsma/joyn/ish/ImageSharingIntent.java
new file mode 100644
index 0000000..91f916a
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingIntent.java
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+/**
+ * Intent for image sharing invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharingIntent {
+    /**
+     * Broadcast action: a new image sharing invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_SHARING_ID} containing the unique ID of the image sharing.
+     * <li> {@link #EXTRA_FILENAME} containing the filename of image to be shared.
+     * <li> {@link #EXTRA_FILESIZE} containing the size of the image to be shared.
+     * <li> {@link #EXTRA_FILETYPE} containing the MIME type of the image to be shared.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.ish.action.NEW_IMAGE_SHARING";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the image sharing
+     */
+    public final static String EXTRA_SHARING_ID = "sharingId";
+
+    /**
+     * Name of the file
+     */
+    public final static String EXTRA_FILENAME = "filename";
+
+    /**
+     * Size of the file in byte
+     */
+    public final static String EXTRA_FILESIZE = "filesize";
+
+    /**
+     * MIME type of the file
+     */
+    public final static String EXTRA_FILETYPE = "filetype";
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingListener.java b/src/java/org/gsma/joyn/ish/ImageSharingListener.java
new file mode 100644
index 0000000..63ec1ff
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingListener.java
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+
+/**
+ * Image sharing event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class ImageSharingListener extends IImageSharingListener.Stub {
+    /**
+     * Callback called when the sharing is started
+     */
+    public abstract void onSharingStarted();
+
+    /**
+     * Callback called when the sharing has been aborted
+     */
+    public abstract void onSharingAborted();
+
+    /**
+     * Callback called when the sharing has failed
+     *
+     * @param error Error
+     * @see ImageSharing.Error
+     */
+    public abstract void onSharingError(int error);
+
+    /**
+     * Callback called during the sharing progress
+     *
+     * @param currentSize Current transferred size in bytes
+     * @param totalSize Total size to transfer in bytes
+     */
+    public abstract void onSharingProgress(long currentSize, long totalSize);
+
+    /**
+     * Callback called when the image has been shared
+     *
+     * @param filename Filename including the path of the transferred file
+     */
+    public abstract void onImageShared(String filename);
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingLog.java b/src/java/org/gsma/joyn/ish/ImageSharingLog.java
new file mode 100644
index 0000000..68e6692
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingLog.java
@@ -0,0 +1,94 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+import android.net.Uri;
+
+/**
+ * Content provider for image sharing history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharingLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.ish/ish");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the image sharing.
+     * <P>Type: TEXT</P>
+     */
+    public static final String SHARING_ID = "sharing_id";
+
+    /**
+     * The name of the column containing the MSISDN of the sender.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the filename (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILENAME = "filename";
+
+    /**
+     * The name of the column containing the image size to be transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String FILESIZE = "filesize";
+
+    /**
+     * The name of the column containing the MIME-type of the file.
+     * <P>Type: TEXT</P>
+     */
+    public static final String MIME_TYPE = "mime_type";
+
+    /**
+     * The name of the column containing the direction of the sharing.
+     * <P>Type: INTEGER</P>
+     * @see ImageSharing.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the amount of data transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String TRANSFERRED = "transferred";
+
+    /**
+     * The name of the column containing the date of the sharing (in milliseconds).
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the state of the sharing.
+     * <P>Type: INTEGER</P>
+     * @see ImageSharing.State
+     */
+    public static final String STATE = "state";
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingService.java b/src/java/org/gsma/joyn/ish/ImageSharingService.java
new file mode 100644
index 0000000..eb058a4
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingService.java
@@ -0,0 +1,398 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+import org.gsma.joyn.ICoreServiceWrapper;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+
+import android.os.RemoteException;
+import org.gsma.joyn.Logger;
+
+/**
+ * This class offers the main entry point to transfer image during
+ * a CS call. Several applications may connect/disconnect to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharingService extends JoynService {
+    /**
+     * API
+     */
+    private IImageSharingService api = null;
+
+    public static final String TAG = "ImageSharingService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public ImageSharingService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IImageSharingService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getImageSharingServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IImageSharingService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of image sharing service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public ImageSharingServiceConfiguration getConfiguration() throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Shares an image with a contact. The parameter file contains the complete filename
+     * including the path of the image to be shared. An exception if thrown if there is
+     * no ongoing CS call. The parameter contact supports the following formats: MSISDN
+     * in national or international format, SIP address, SIP-URI or Tel-URI. If the format
+     * of the contact is not supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @param filename Filename to share
+     * @param listener Image sharing event listener
+     * @return Image sharing
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public ImageSharing shareImage(String contact, String filename, ImageSharingListener listener) throws JoynServiceException, JoynContactFormatException {
+
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_IMAGESHARE_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_IMAGESHARE_SEND");
+        } */
+        if (api != null) {
+            try {
+                IImageSharing sharingIntf = api.shareImage(contact, filename, listener);
+                if (sharingIntf != null) {
+                    return new ImageSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of image sharings in progress
+     *
+     * @return List of image sharings
+     * @throws JoynServiceException
+     */
+    public Set<ImageSharing> getImageSharings() throws JoynServiceException {
+        if (api != null) {
+            try {
+                Set<ImageSharing> result = new HashSet<ImageSharing>();
+                List<IBinder> ishList = api.getImageSharings();
+                for (IBinder binder : ishList) {
+                    ImageSharing sharing = new ImageSharing(IImageSharing.Stub.asInterface(binder));
+                    result.add(sharing);
+                }
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current image sharing from its unique ID
+     *
+     * @param sharingId Sharing ID
+     * @return Image sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public ImageSharing getImageSharing(String sharingId) throws JoynServiceException {
+        if (api != null) {
+            try {
+                IImageSharing sharingIntf = api.getImageSharing(sharingId);
+                if (sharingIntf != null) {
+                    return new ImageSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current image sharing from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return Image sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public ImageSharing getImageSharingFor(Intent intent) throws JoynServiceException {
+        if (api != null) {
+            try {
+                String sharingId = intent.getStringExtra(ImageSharingIntent.EXTRA_SHARING_ID);
+                if (sharingId != null) {
+                    return getImageSharing(sharingId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Get joyn account mapped with the specific GSM number(Only in debug mode).
+     *
+     * @param number The GSM number to be mapped to joyn account.
+     * @return The joyn account.
+     * @throws JoynServiceException
+     */
+    public String getJoynAccountViaNumber(String number) throws JoynServiceException, JoynServiceNotAvailableException {
+        if (api != null) {
+            try {
+                return api.getJoynAccountViaNumber(number);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        if (api != null) {
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    /**
+     * Registers a new image sharing invitation listener
+     *
+     * @param listener New image sharing listener
+     * @throws JoynServiceException
+     */
+    public void addNewImageSharingListener(NewImageSharingListener listener) throws JoynServiceException {
+
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_IMAGESHARE_RECEIVE) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_IMAGESHARE_RECEIVE");
+        }*/
+        if (api != null) {
+            try {
+                api.addNewImageSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a new image sharing invitation listener
+     *
+     * @param listener New image sharing listener
+     * @throws JoynServiceException
+     */
+    public void removeNewImageSharingListener(NewImageSharingListener listener) throws JoynServiceException {
+
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_IMAGESHARE_RECEIVE) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_IMAGESHARE_RECEIVE");
+        }*/
+        if (api != null) {
+            try {
+                api.removeNewImageSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.aidl b/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.aidl
new file mode 100644
index 0000000..1f2eccf
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ish;
+
+/**
+ * Image sharing configuration object
+ */
+parcelable ImageSharingServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.java b/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.java
new file mode 100644
index 0000000..00f5dbf
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.java
@@ -0,0 +1,121 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Image sharing service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharingServiceConfiguration {
+    /**
+     * Image size threshold
+     */
+    private long warnSize;
+
+    /**
+     * Image size limit
+     */
+    private long maxSize;
+
+    /**
+     * Constructor
+     *
+     * @param warnSize Image size threshold
+     * @param maxSize Image size limit
+     * @hide
+     */
+    public ImageSharingServiceConfiguration(long warnSize, long maxSize) {
+        this.warnSize = warnSize;
+        this.maxSize = maxSize;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public ImageSharingServiceConfiguration(Parcel source) {
+        this.warnSize = source.readLong();
+        this.maxSize = source.readLong();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(warnSize);
+        dest.writeLong(maxSize);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<ImageSharingServiceConfiguration> CREATOR
+            = new Parcelable.Creator<ImageSharingServiceConfiguration>() {
+        public ImageSharingServiceConfiguration createFromParcel(Parcel source) {
+            return new ImageSharingServiceConfiguration(source);
+        }
+
+        public ImageSharingServiceConfiguration[] newArray(int size) {
+            return new ImageSharingServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Returns the image size threshold when the user should be warned about the
+     * potential charges associated to the transfer of a large file. It returns 0
+     * if there no need to warn.
+     *
+     * @return Size in kilobytes
+     */
+    public long getWarnSize() {
+        return warnSize;
+    }
+
+    /**
+     * Returns the maximum authorized size of the image that can be sent. It
+     * returns 0 if there is no limitation.
+     *
+     * @return Size in kilobytes
+     */
+    public long getMaxSize() {
+        return maxSize;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ish/NewImageSharingListener.java b/src/java/org/gsma/joyn/ish/NewImageSharingListener.java
new file mode 100644
index 0000000..bc5e695
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/NewImageSharingListener.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+
+/**
+ * New image sharing invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewImageSharingListener extends INewImageSharingListener.Stub {
+    /**
+     * Callback called when a new image sharing invitation has been received
+     *
+     * @param sharingId Sharing ID
+     */
+    public abstract void onNewImageSharing(String sharingId);
+}
diff --git a/src/java/org/gsma/joyn/ish/package-info.java b/src/java/org/gsma/joyn/ish/package-info.java
new file mode 100644
index 0000000..782de90
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * This API exposes exposes all functionality related to transferring images
+ * during a CS call via the Image Sharing service.
+ * <p>
+ */
+package org.gsma.joyn.ish;
diff --git a/src/java/org/gsma/joyn/package-info.java b/src/java/org/gsma/joyn/package-info.java
new file mode 100644
index 0000000..3b9e9c3
--- /dev/null
+++ b/src/java/org/gsma/joyn/package-info.java
@@ -0,0 +1,41 @@
+/**
+ * The RCS service is implemented into an Android background service
+ * which offers a high level API: the RCS Terminal API.
+ * <p>
+ * The RCS API is a client/server interface based on database
+ * providers, AIDL API & Intents. Several UI may be connected at a time
+ * to manage RCS events and to interact with the single stack instance
+ * running in background.
+ * <p>
+ * The RCS API permits to implement RCS application (e.g. enhanced
+ * address book, content sharing app, chat view, widgets) by hiding RCS
+ * protocols complexity.
+ * <p>
+ * The RCS API offers the following service API:<br>
+ * - Capability API: contact capabilities discovery.<br>
+ * - Chat API: 1-1 chat and group chat.<br>
+ * - File Transfer API: transfer a file.<br>
+ * - Video Share API: live video sharing during a CS call.<br>
+ * - Image Share API: image sharing during a CS call.<br>
+ * - UX API: links third party applications with RCS applications.<br>
+ * <p>
+ * The RCS API uses the following Android concepts:<br>
+ * - Intents mechanism to broadcast incoming events (e.g. notification) and
+ * incoming invitations to any Android activity or broadcast receiver which are
+ * declared in the device.<br>
+ * - AIDL interfaces to initiate and to manage session in real time (start,
+ * session monitoring, stop). Session events are managed thanks to callback mechanism.<br>
+ * <p>
+ * Note: Methods of the RCS API throw an exception if the RCS service is not available, not
+ * initialized or not registered to the IMS platform.
+ * <p>
+ * Note: Remote application exceptions are not yet supported by the
+ * AIDL SDK, a generic AIDL exception is thrown instead.
+ * <p>
+ * Note: The supported formats for a contact used as a method parameter are:<br>
+ * - Phone number in national or international format (e.g. +33xxx).<br>
+ * - SIP address (e.g. "John" <sip:+33xxx@domain.com>).<br>
+ * - SIP-URI (e.g. sip:+33xxx@domain.com).<br>
+ * - Tel-URI (e.g. tel:+33xxx).<br>
+ */
+package org.gsma.joyn;
diff --git a/src/java/org/gsma/joyn/session/IMultimediaSession.aidl b/src/java/org/gsma/joyn/session/IMultimediaSession.aidl
new file mode 100644
index 0000000..fc8473e
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/IMultimediaSession.aidl
@@ -0,0 +1,31 @@
+package org.gsma.joyn.session;
+
+import org.gsma.joyn.session.IMultimediaSessionListener;
+
+/**
+ * Multimedia session interface
+ */
+interface IMultimediaSession {
+	String getSessionId();
+	
+	String getRemoteContact();
+	
+	String getServiceId();
+	
+	int getState();
+	
+	int getDirection();
+	
+	void acceptInvitation();
+	
+	void rejectInvitation();
+	
+	void abortSession();
+	
+	void addEventListener(in IMultimediaSessionListener listener);
+	
+	void removeEventListener(in IMultimediaSessionListener listener);
+
+	boolean sendMessage(in byte[] content);
+}
+
diff --git a/src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl b/src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl
new file mode 100644
index 0000000..78c6187
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.session;
+
+/**
+ * Callback methods for multimedia session events
+ */
+interface IMultimediaSessionListener {
+	void onSessionStarted();
+	
+	void onSessionRinging();
+
+	void onSessionAborted();
+
+	void onSessionError(in int error);
+
+	void onNewMessage(in byte[] content);
+}
diff --git a/src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl b/src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl
new file mode 100644
index 0000000..6f47c91
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl
@@ -0,0 +1,28 @@
+package org.gsma.joyn.session;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.session.IMultimediaSession;
+import org.gsma.joyn.session.IMultimediaSessionListener;
+
+/**
+ * Multimedia session service API
+ */
+interface IMultimediaSessionService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	List<IBinder> getSessions(in String serviceId);
+	
+	IMultimediaSession getSession(in String sessionId);
+	
+	IMultimediaSession initiateSession(in String serviceId, in String contact, in IMultimediaSessionListener listener);
+	
+	boolean sendMessage(in String serviceId, in String contact, in byte[] content);
+	
+	int getServiceVersion();
+}
+
+
diff --git a/src/java/org/gsma/joyn/session/MultimediaMessageIntent.java b/src/java/org/gsma/joyn/session/MultimediaMessageIntent.java
new file mode 100644
index 0000000..b5bc965
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaMessageIntent.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.session;
+
+/**
+ * Intent for incoming multimedia messages
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultimediaMessageIntent {
+    /**
+     * Broadcast action: a new multimedia message has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the message.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the message (extracted from the SIP address).
+     * <li> {@link #EXTRA_CONTENT} containing the multimedia message content.
+     * <li> The service ID is read from the method Intent.getType() which returns the MIME type included
+     *  in the intent and corresponding to the invoked service.
+     * </ul>
+     */
+    public final static String ACTION_NEW_MESSAGE = "org.gsma.joyn.session.action.NEW_MESSAGE";
+
+    /**
+     * MSISDN of the contact sending the message
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the message
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Multimedia message content
+     */
+    public final static String EXTRA_CONTENT = "content";
+}
diff --git a/src/java/org/gsma/joyn/session/MultimediaSession.java b/src/java/org/gsma/joyn/session/MultimediaSession.java
new file mode 100644
index 0000000..6d830ac
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaSession.java
@@ -0,0 +1,278 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.session;
+
+import org.gsma.joyn.JoynServiceException;
+
+/**
+ * This class maintains the information related to a multimedia
+ * session and offers methods to manage it and to send messages
+ * in real time.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultimediaSession {
+    /**
+     * Multimedia session state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Session invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Session invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Session is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Session has been aborted or
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Session has been terminated
+         */
+        public static final int TERMINATED = 6;
+
+        /**
+         * Session has failed
+         */
+        public final static int FAILED = 7;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the session
+     */
+    public static class Direction {
+        /**
+         * Incoming session
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing session
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Session error
+     */
+    public static class Error {
+        /**
+         * Session invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 0;
+
+        /**
+         * Session has failed
+         */
+        public final static int SESSION_FAILED = 1;
+
+        /**
+         * Media has failed
+         */
+        public final static int MEDIA_FAILED = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Multimedia session interface
+     */
+    private IMultimediaSession sessionInf;
+
+    /**
+     * Constructor
+     *
+     * @param sessionInf Multimedia session interface
+     */
+    MultimediaSession(IMultimediaSession sessionInf) {
+        this.sessionInf = sessionInf;
+    }
+
+    /**
+     * Returns the session ID of the multimedia session
+     *
+     * @return Session ID
+     * @throws JoynServiceException
+     */
+    public String getSessionId() throws JoynServiceException {
+        try {
+            return sessionInf.getSessionId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        try {
+            return sessionInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the service ID
+     *
+     * @return Service ID
+     * @throws JoynServiceException
+     */
+    public String getServiceId() throws JoynServiceException {
+        try {
+            return sessionInf.getServiceId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the session
+     *
+     * @return State
+     * @see MultimediaSession.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        try {
+            return sessionInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the session (incoming or outgoing)
+     *
+     * @return Direction
+     * @see MultimediaSession.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        try {
+            return sessionInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts session invitation.
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        try {
+            sessionInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects session invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        try {
+            sessionInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the session
+     *
+     * @throws JoynServiceException
+     */
+    public void abortSession() throws JoynServiceException {
+        try {
+            sessionInf.abortSession();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on session events
+     *
+     * @param listener Session event listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(MultimediaSessionListener listener) throws JoynServiceException {
+        try {
+            sessionInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener on session events
+     *
+     * @param listener Session event listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(MultimediaSessionListener listener) throws JoynServiceException {
+        try {
+            sessionInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a message in real time
+     *
+     * @param content Message content
+     * @return Returns true if sent successfully else returns false
+     * @throws JoynServiceException
+     */
+    public boolean sendMessage(byte[] content) throws JoynServiceException {
+        try {
+            return sessionInf.sendMessage(content);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/session/MultimediaSessionIntent.java b/src/java/org/gsma/joyn/session/MultimediaSessionIntent.java
new file mode 100644
index 0000000..474a730
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaSessionIntent.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.session;
+
+/**
+ * Intent for multimedia session invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultimediaSessionIntent {
+    /**
+     * Broadcast action: a new multimedia session invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_SESSION_ID} containing the unique ID of the multimedia session.
+     * <li> The service ID is read from the method Intent.getType() which returns the MIME type included
+     *  in the intent and corresponding to the invoked service.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.session.action.NEW_SESSION";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the multimedia session
+     */
+    public final static String EXTRA_SESSION_ID = "sessionId";
+}
diff --git a/src/java/org/gsma/joyn/session/MultimediaSessionListener.java b/src/java/org/gsma/joyn/session/MultimediaSessionListener.java
new file mode 100644
index 0000000..b9073dd
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaSessionListener.java
@@ -0,0 +1,57 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.session;
+
+
+
+/**
+ * This class offers callback methods on multimedia session events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class MultimediaSessionListener extends IMultimediaSessionListener.Stub {
+    /**
+     * Callback called when the session is pending.
+     */
+    public abstract void onSessionRinging();
+
+    /**
+     * Callback called when the session is started
+     */
+    public abstract void onSessionStarted();
+
+    /**
+     * Callback called when the session has been aborted or terminated
+     */
+    public abstract void onSessionAborted();
+
+    /**
+     * Callback called when the session has failed
+     *
+     * @param error Error
+     * @see MultimediaSession.Error
+     */
+    public abstract void onSessionError(int error);
+
+    /**
+     * Callback called when a new message has been received
+     *
+     * @param content Message content
+     */
+    public abstract void onNewMessage(byte[] content);
+}
diff --git a/src/java/org/gsma/joyn/session/MultimediaSessionService.java b/src/java/org/gsma/joyn/session/MultimediaSessionService.java
new file mode 100644
index 0000000..aa3ffed
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaSessionService.java
@@ -0,0 +1,250 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.session;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+
+/**
+ * This class offers the main entry point to initiate and to manage
+ * multimedia sessions. Several applications may connect/disconnect
+ * to the API.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultimediaSessionService extends JoynService {
+    /**
+     * API
+     */
+    private IMultimediaSessionService api = null;
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public MultimediaSessionService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IMultimediaSessionService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getMultimediaSessionServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IMultimediaSessionService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Initiates a new multimedia session for real time messaging with a remote contact and
+     * for a given service. The messages exchanged in real time during the session may be from
+     * any type. The parameter contact supports the following formats: MSISDN in national or
+     * international format, SIP address, SIP-URI or Tel-URI. If the format of the contact is
+     * not supported an exception is thrown.
+     *
+     * @param serviceId Service ID
+     * @param contact Contact
+     * @param listener Multimedia session event listener
+     * @return Multimedia session
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public MultimediaSession initiateSession(String serviceId, String contact, MultimediaSessionListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            try {
+                IMultimediaSession sessionIntf = api.initiateSession(serviceId, contact, listener);
+                if (sessionIntf != null) {
+                    return new MultimediaSession(sessionIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of sessions associated to a given service ID
+     *
+     * @param serviceId Service ID
+     * @return List of sessions
+     * @throws JoynServiceException
+     */
+    public Set<MultimediaSession> getSessions(String serviceId) throws JoynServiceException {
+        if (api != null) {
+            try {
+                Set<MultimediaSession> result = new HashSet<MultimediaSession>();
+                List<IBinder> mmsList = api.getSessions(serviceId);
+                for (IBinder binder : mmsList) {
+                    MultimediaSession session = new MultimediaSession(IMultimediaSession.Stub.asInterface(binder));
+                    result.add(session);
+                }
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current session from its unique session ID
+     *
+     * @return Multimedia session or null if not found
+     * @throws JoynServiceException
+     */
+    public MultimediaSession getSession(String sessionId) throws JoynServiceException {
+        if (api != null) {
+            try {
+                IMultimediaSession sessionIntf = api.getSession(sessionId);
+                if (sessionIntf != null) {
+                    return new MultimediaSession(sessionIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current session from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return Multimedia session or null if not found
+     * @throws JoynServiceException
+     */
+    public MultimediaSession getSessionFor(Intent intent) throws JoynServiceException {
+        if (api != null) {
+            try {
+                String sessionId = intent.getStringExtra(MultimediaSessionIntent.EXTRA_SESSION_ID);
+                if (sessionId != null) {
+                    return getSession(sessionId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Sends a message in pager mode to a contact and for a given service. The message may
+     * be any type of content. The parameter contact supports the following formats: MSISDN in
+     * national or international format, SIP address, SIP-URI or Tel-URI. If the format of the
+     * contact is not supported an exception is thrown.
+     *
+     * @param serviceId Service ID
+     * @param contact Contact
+     * @param content Message content
+     * @return Returns true if sent successfully else returns false
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public boolean sendMessage(String serviceId, String contact, byte[] content) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            try {
+                return api.sendMessage(serviceId, contact, content);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/session/package-info.java b/src/java/org/gsma/joyn/session/package-info.java
new file mode 100644
index 0000000..7e9e4ea
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This API exposes all functionality to initiate multimedia sessions between two end points based on a dedicated service ID (or feature tag).<p>
+ */
+package org.gsma.joyn.session;
diff --git a/src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl b/src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl
new file mode 100644
index 0000000..b519ff5
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl
@@ -0,0 +1,8 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Callback method for new video sharing invitations
+ */
+interface INewVideoSharingListener {
+	void onNewVideoSharing(in String sharingId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl b/src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl
new file mode 100644
index 0000000..78dc47a
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl
@@ -0,0 +1,28 @@
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.vsh.VideoCodec;
+import org.gsma.joyn.vsh.IVideoPlayerListener;
+
+/**
+ * Video player interface
+ */
+interface IVideoPlayer {
+	void open(in VideoCodec codec, in String remoteHost, in int remotePort);
+	
+	void close();
+
+	void start();
+
+	void stop();
+
+	int getLocalRtpPort();
+
+	VideoCodec getCodec();
+
+	VideoCodec[] getSupportedCodecs();
+
+	void addEventListener(in IVideoPlayerListener listener);
+
+	void removeEventListener(in IVideoPlayerListener listener);	
+    void setOrientationHeaderId(in int headerId);
+}
diff --git a/src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl b/src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl
new file mode 100644
index 0000000..613c23c
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Video player event listener interface
+ */
+interface IVideoPlayerListener {
+	void onPlayerOpened();
+
+	void onPlayerStarted();
+
+	void onPlayerStopped();
+
+	void onPlayerClosed();
+
+	void onPlayerFailed();
+}
diff --git a/src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl b/src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl
new file mode 100644
index 0000000..33f8445
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl
@@ -0,0 +1,29 @@
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.vsh.VideoCodec;
+import org.gsma.joyn.vsh.IVideoRendererListener;
+
+/**
+ * Video renderer interface
+ */
+interface IVideoRenderer {
+	void open(in VideoCodec codec, in String remoteHost, in int remotePort);
+
+	void close();
+
+	void start();
+
+	void stop();
+
+	int getLocalRtpPort();
+
+	VideoCodec getCodec();
+
+	VideoCodec[] getSupportedCodecs();
+	
+	void addEventListener(in IVideoRendererListener listener);
+
+	void removeEventListener(in IVideoRendererListener listener);
+	
+	void setOrientationHeaderId(in int headerId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl b/src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl
new file mode 100644
index 0000000..24d28b2
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl
@@ -0,0 +1,17 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Video renderer event listener interface
+ */
+interface IVideoRendererListener {
+	void onRendererOpened();
+
+	void onRendererStarted();
+
+	void onRendererStopped();
+
+	void onRendererClosed();
+
+	void onRendererFailed();		
+	
+}
diff --git a/src/java/org/gsma/joyn/vsh/IVideoSharing.aidl b/src/java/org/gsma/joyn/vsh/IVideoSharing.aidl
new file mode 100644
index 0000000..a1ba72b
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoSharing.aidl
@@ -0,0 +1,35 @@
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.vsh.IVideoSharingListener;
+import org.gsma.joyn.vsh.IVideoRenderer;
+import org.gsma.joyn.vsh.VideoCodec;
+
+/**
+ * Video sharing interface
+ */
+interface IVideoSharing {
+
+	String getSharingId();
+
+	String getRemoteContact();
+
+	VideoCodec getVideoCodec();
+
+	int getState();
+
+	String getVideoEncoding();
+	
+	String getVideoFormat();
+
+	int getDirection();
+	
+	void acceptInvitation(IVideoRenderer renderer);
+
+	void rejectInvitation();
+
+	void abortSharing();
+	
+	void addEventListener(in IVideoSharingListener listener);
+
+	void removeEventListener(in IVideoSharingListener listener);
+}
diff --git a/src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl b/src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl
new file mode 100644
index 0000000..4b3cf09
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl
@@ -0,0 +1,12 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Callback methods for video sharing events
+ */
+interface IVideoSharingListener {
+	void onSharingStarted();
+	
+	void onSharingAborted();
+
+	void onSharingError(in int error);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl b/src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl
new file mode 100644
index 0000000..98cd0a3
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl
@@ -0,0 +1,33 @@
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.vsh.IVideoSharing;
+import org.gsma.joyn.vsh.IVideoSharingListener;
+import org.gsma.joyn.vsh.INewVideoSharingListener;
+import org.gsma.joyn.vsh.IVideoPlayer;
+import org.gsma.joyn.vsh.VideoSharingServiceConfiguration;
+
+/**
+ * Video sharing service API
+ */
+interface IVideoSharingService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	VideoSharingServiceConfiguration getConfiguration();
+
+	List<IBinder> getVideoSharings();
+	
+	IVideoSharing getVideoSharing(in String sharingId);
+
+	IVideoSharing shareVideo(in String contact, in IVideoPlayer player, in IVideoSharingListener listener);
+	
+	void addNewVideoSharingListener(in INewVideoSharingListener listener);
+
+	void removeNewVideoSharingListener(in INewVideoSharingListener listener);
+	
+	int getServiceVersion();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/NewVideoSharingListener.java b/src/java/org/gsma/joyn/vsh/NewVideoSharingListener.java
new file mode 100644
index 0000000..332813e
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/NewVideoSharingListener.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+
+/**
+ * New video sharing invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewVideoSharingListener extends INewVideoSharingListener.Stub {
+    /**
+     * Callback called when a new video sharing invitation has been received
+     *
+     * @param sharingId Sharing ID
+     */
+    public abstract void onNewVideoSharing(String sharingId);
+
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoCodec.aidl b/src/java/org/gsma/joyn/vsh/VideoCodec.aidl
new file mode 100644
index 0000000..f6c95a9
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoCodec.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Video codec object
+ */
+parcelable VideoCodec;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/VideoCodec.java b/src/java/org/gsma/joyn/vsh/VideoCodec.java
new file mode 100644
index 0000000..3d2bbf6
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoCodec.java
@@ -0,0 +1,276 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.gsma.joyn.H264Config;
+
+/**
+ * Video codec
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoCodec implements Parcelable {
+    /**
+     * Video encoding
+     */
+    private String encoding;
+
+    /**
+     * Payload
+     */
+    private int payload;
+
+    /**
+     * Clock rate
+     */
+    private int clockRate;
+
+    /**
+     * Frame rate
+     */
+    private int frameRate;
+
+    /**
+     * Bit rate
+     */
+    private int bitRate;
+
+    /**
+     * Screen width
+     */
+    private int width;
+
+    /**
+     * Screen height
+     */
+    private int height;
+
+    /**
+     * Video parameters
+     */
+    private String parameters;
+
+    /**
+     * Constructor
+     *
+     * @param encoding Video encoding
+     * @param payload Payload
+     * @param clockRate Clock rate
+     * @param framerate Frame rate
+     * @param bitRate Bit rate
+     * @param width Video width
+     * @param height Video height
+     * @param parameters Codec parameters
+     * @hide
+     */
+    public VideoCodec(String encoding, int payload, int clockRate, int frameRate, int bitRate, int width, int height, String parameters) {
+        this.encoding = encoding;
+        this.payload = payload;
+        this.clockRate = clockRate;
+        this.frameRate = frameRate;
+        this.bitRate = bitRate;
+        this.width = width;
+        this.height = height;
+        this.parameters = parameters;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public VideoCodec(Parcel source) {
+        this.encoding = source.readString();
+        this.payload = source.readInt();
+        this.clockRate = source.readInt();
+        this.frameRate = source.readInt();
+        this.bitRate = source.readInt();
+        this.width = source.readInt();
+        this.height = source.readInt();
+        this.parameters = source.readString();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(encoding);
+        dest.writeInt(payload);
+        dest.writeInt(clockRate);
+        dest.writeInt(frameRate);
+        dest.writeInt(bitRate);
+        dest.writeInt(width);
+        dest.writeInt(height);
+        dest.writeString(parameters);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<VideoCodec> CREATOR
+            = new Parcelable.Creator<VideoCodec>() {
+        public VideoCodec createFromParcel(Parcel source) {
+            return new VideoCodec(source);
+        }
+
+        public VideoCodec[] newArray(int size) {
+            return new VideoCodec[size];
+        }
+    };
+
+    /**
+    * Returns the encoding name (e.g. H264)
+    *
+    * @return Encoding name
+    */
+    public String getEncoding() {
+        return encoding;
+    }
+
+    /**
+     * Returns the codec payload type (e.g. 96)
+     *
+     * @return Payload type
+     */
+    public int getPayloadType() {
+        return payload;
+    }
+
+    /**
+     * Returns the codec clock rate (e.g. 90000)
+     *
+     * @return Clock rate
+     */
+    public int getClockRate() {
+        return clockRate;
+    }
+
+    /**
+     * Returns the codec frame rate (e.g. 10)
+     *
+     * @return Frame rate
+     */
+    public int getFrameRate() {
+        return frameRate;
+    }
+
+    /**
+     * Returns the codec bit rate (e.g. 64000)
+     *
+     * @return Bit rate
+     */
+    public int getBitRate() {
+        return bitRate;
+    }
+
+    /**
+     * Returns the video width (e.g. 176)
+     *
+     * @return Video width
+     */
+    public int getVideoWidth() {
+        return width;
+    }
+
+    /**
+     * Returns the video height (e.g. 144)
+     *
+     * @return Video height
+     */
+    public int getVideoHeight() {
+        return height;
+    }
+
+    /**
+     * Returns the list of codec parameters (e.g. profile-level-id, packetization-mode).
+     * Parameters are are semicolon separated.
+     *
+     * @return Parameters
+     */
+    public String getParameters() {
+        return parameters;
+    }
+
+
+    /**
+     * Returns the value of codec parameter key (e.g. profile-level-id, packetization-mode).
+     *
+     * @return Parameters
+     */
+    public String getParameter(String key) {
+        String value = null;
+        String[] parameters = getParameters().split(",");
+        ArrayList<String> codecparams = new ArrayList<String>(Arrays.asList(parameters));
+        for (int i = 0; i < codecparams.size() ; i++)
+        {
+            if (codecparams.get(i).startsWith(key))
+            {
+                value = codecparams.get(i).substring(key.length() + 1);
+            }
+        }
+        return value;
+    }
+
+    /**
+     * Compare codec
+     *
+     * @param codec Codec to compare
+     * @return Returns True if codecs are equals, else returns False
+     */
+    public boolean compare(VideoCodec codec) {
+        boolean ret = false;
+        if (getEncoding().equalsIgnoreCase(codec.getEncoding())
+                && (getVideoWidth() == codec.getVideoWidth() || getVideoWidth() == 0 || codec.getVideoWidth() == 0)
+                && (getVideoHeight() == codec.getVideoHeight() || getVideoHeight() == 0 || codec.getVideoHeight() == 0)) {
+            if (getEncoding().equalsIgnoreCase(H264Config.CODEC_NAME)) {
+                if (H264Config.getCodecProfileLevelId(getParameters()).compareToIgnoreCase(H264Config.getCodecProfileLevelId(codec.getParameters())) == 0) {
+                    ret =  true;
+                }
+            } else {
+                if (getParameters().equalsIgnoreCase(codec.getParameters())) {
+                    ret = true;
+                }
+            }
+        }
+        return ret;
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoPlayer.java b/src/java/org/gsma/joyn/vsh/VideoPlayer.java
new file mode 100644
index 0000000..f1a800d
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoPlayer.java
@@ -0,0 +1,145 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import java.util.HashSet;
+import java.util.Set;
+
+
+
+
+/**
+ * Video player offers an interface to manage the video player instance
+ * independently of the joyn service. The video player is implemented in
+ * the application side. The video player captures the video from the device
+ * camera, encodes the video into the selected format and streams the encoded
+ * video frames over the network in RTP.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoPlayer extends IVideoPlayer.Stub {
+    /**
+     * Video player error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Network connection failed
+         */
+        public final static int NETWORK_FAILURE = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Video player event listeners
+     */
+    private Set<IVideoPlayerListener> listeners = new HashSet<IVideoPlayerListener>();
+
+    /**
+     * Constructor
+     */
+    public VideoPlayer() {
+    }
+
+    /**
+     * Opens the player and prepares resources (e.g. encoder, camera)
+     *
+     * @param codec Video codec
+     * @param remoteHost Remote RTP host
+     * @param remotePort Remote RTP port
+     */
+    public abstract void open(VideoCodec codec, String remoteHost, int remotePort);
+
+    /**
+     * Closes the player and deallocates resources
+     *
+     * @throws JoynServiceException
+     */
+    public abstract void close();
+
+    /**
+     * Starts the player
+     */
+    public abstract void start();
+
+    /**
+     * Stops the player
+     */
+    public abstract void stop();
+
+    /**
+     * Returns the local RTP port used to stream video
+     *
+     * @return Port number
+     */
+    public abstract int getLocalRtpPort();
+
+    /**
+     * Returns the list of codecs supported by the player
+     *
+     * @return List of codecs
+     */
+    public abstract VideoCodec[] getSupportedCodecs();
+
+    /**
+     * Returns the current codec
+     *
+     * @return Codec
+     */
+    public abstract VideoCodec getCodec();
+
+    /**
+     * Returns the list of player event listeners
+     *
+     * @return Listeners
+     */
+    public Set<IVideoPlayerListener> getEventListeners() {
+        return listeners;
+    }
+
+    /**
+     * Adds a listener on player events
+     *
+     * @param listener Listener
+     */
+    public void addEventListener(IVideoPlayerListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a listener from player events
+     *
+     * @param listener Listener
+     */
+    public void removeEventListener(IVideoPlayerListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all listeners from player events
+     */
+    public void removeAllEventListeners() {
+        listeners.clear();
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoPlayerListener.java b/src/java/org/gsma/joyn/vsh/VideoPlayerListener.java
new file mode 100644
index 0000000..555a1f6
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoPlayerListener.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+
+/**
+ * This class offers callback methods on video player events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoPlayerListener extends IVideoPlayerListener.Stub {
+    /**
+     * Callback called when the player is opened
+     */
+    public abstract void onPlayerOpened();
+
+    /**
+     * Callback called when the player is started
+     */
+    public abstract void onPlayerStarted();
+
+    /**
+     * Callback called when the player is stopped
+     */
+    public abstract void onPlayerStopped();
+
+    /**
+     * Callback called when the player is closed
+     */
+    public abstract void onPlayerClosed();
+
+    /**
+     * Callback called when the player has failed
+     *
+     * @param error Error
+     */
+    public abstract void onPlayerFailed();
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoRenderer.java b/src/java/org/gsma/joyn/vsh/VideoRenderer.java
new file mode 100644
index 0000000..2fec64d
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoRenderer.java
@@ -0,0 +1,140 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Video renderer offers an interface to manage the video renderer instance
+ * independently of the joyn service. The video renderer is implemented in
+ * the application side. The video renderer receives the video streaming over
+ * the network in RTP, decodes the video frames and displays the decoded
+ * picture on the device screen.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoRenderer extends IVideoRenderer.Stub {
+    /**
+     * Video renderer error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Network connection failed
+         */
+        public final static int NETWORK_FAILURE = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Video renderer event listeners
+     */
+    private Set<IVideoRendererListener> listeners = new HashSet<IVideoRendererListener>();
+
+    /**
+     * Constructor
+     */
+    public VideoRenderer() {
+    }
+
+    /**
+     * Opens the renderer and prepares resources (e.g. decoder)
+     *
+     * @param codec Video codec
+     * @param remoteHost Remote RTP host
+     * @param remotePort Remote RTP port
+     */
+    public abstract void open(VideoCodec codec, String remoteHost, int remotePort);
+
+    /**
+     * Closes the renderer and deallocates resources
+     */
+    public abstract void close();
+
+    /**
+     * Starts the renderer
+     */
+    public abstract void start();
+
+    /**
+     * Stops the renderer
+     */
+    public abstract void stop();
+
+    /**
+     * Returns the local RTP port used to stream video
+     *
+     * @return Port number
+     */
+    public abstract int getLocalRtpPort();
+
+    /**
+     * Returns the current codec
+     *
+     * @return Codec
+     */
+    public abstract VideoCodec getCodec();
+
+    /**
+     * Returns the list of codecs supported by the renderer
+     *
+     * @return List of codecs
+     */
+    public abstract VideoCodec[] getSupportedCodecs();
+
+    /**
+     * Returns the list of renderer event listeners
+     *
+     * @return Listeners
+     */
+    public Set<IVideoRendererListener> getEventListeners() {
+        return listeners;
+    }
+
+    /**
+     * Adds a listener on renderer events
+     *
+     * @param listener Listener
+     */
+    public void addEventListener(IVideoRendererListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a listener from renderer events
+     *
+     * @param listener Listener
+     */
+    public void removeEventListener(IVideoRendererListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all listeners from renderer events
+     */
+    public void removeAllEventListeners() {
+        listeners.clear();
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoRendererListener.java b/src/java/org/gsma/joyn/vsh/VideoRendererListener.java
new file mode 100644
index 0000000..b903ff3
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoRendererListener.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+
+/**
+ * This class offers callback methods on video renderer events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoRendererListener extends IVideoRendererListener.Stub {
+    /**
+     * Callback called when the renderer is opened
+     */
+    public abstract void onRendererOpened();
+
+    /**
+     * Callback called when the renderer is started
+     */
+    public abstract void onRendererStarted();
+
+    /**
+     * Callback called when the renderer is stopped
+     */
+    public abstract void onRendererStopped();
+
+    /**
+     * Callback called when the renderer is closed
+     */
+    public abstract void onRendererClosed();
+
+    /**
+     * Callback called when the renderer has failed
+     *
+     * @param error Error
+     */
+    public abstract void onRendererFailed();
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharing.java b/src/java/org/gsma/joyn/vsh/VideoSharing.java
new file mode 100644
index 0000000..06b307d
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharing.java
@@ -0,0 +1,300 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.JoynServiceException;
+
+/**
+ * Video sharing
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharing {
+
+    /**
+     * Video sharing state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Sharing invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Sharing invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Sharing is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Sharing has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Sharing has been terminated
+         */
+        public static final int TERMINATED = 6;
+
+        /**
+         * Sharing has failed
+         */
+        public final static int FAILED = 7;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the sharing
+     */
+    public static class Direction {
+        /**
+         * Incoming sharing
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing sharing
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Video sharing error
+     */
+    public static class Error {
+        /**
+         * Sharing has failed
+         */
+        public final static int SHARING_FAILED = 0;
+
+        /**
+         * Sharing invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Video encoding
+     */
+    public static class Encoding {
+        /**
+         * H264
+         */
+        public static final int H264 = 0;
+    }
+
+    /**
+     * Video sharing interface
+     */
+    private IVideoSharing sharingInf;
+
+    /**
+     * Constructor
+     *
+     * @param sharingInf Video sharing interface
+     */
+    VideoSharing(IVideoSharing sharingInf) {
+        this.sharingInf = sharingInf;
+    }
+
+    /**
+     * Returns the sharing ID of the video sharing
+     *
+     * @return Sharing ID
+     * @throws JoynServiceException
+     */
+    public String getSharingId() throws JoynServiceException {
+        try {
+            return sharingInf.getSharingId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        try {
+            return sharingInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+
+    /**
+     * Returns the video Encoding like H264
+     *
+     * @return Video codec
+     * @see VideoCodec
+     * @throws JoynServiceException
+     */
+    public String getVideoEncoding() throws JoynServiceException {
+        try {
+            return sharingInf.getVideoEncoding();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the video Format (e.g. QCIF)
+     *
+     * @return Video codec
+     * @see VideoCodec
+     * @throws JoynServiceException
+     */
+    public String getVideoFormat() throws JoynServiceException {
+        try {
+            return sharingInf.getVideoFormat();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the video codec
+     *
+     * @return Video codec
+     * @see VideoCodec
+     * @throws JoynServiceException
+     */
+    public VideoCodec getVideoCodec() throws JoynServiceException {
+        try {
+            return sharingInf.getVideoCodec();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the sharing
+     *
+     * @return State
+     * @see VideoSharing.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        try {
+            return sharingInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the sharing (incoming or outgoing)
+     *
+     * @return Direction
+     * @see VideoSharing.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        try {
+            return sharingInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts video sharing invitation
+     *
+     * @param renderer Video renderer
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation(VideoRenderer renderer) throws JoynServiceException {
+        try {
+            sharingInf.acceptInvitation(renderer);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects video sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        try {
+            sharingInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the sharing
+     *
+     * @throws JoynServiceException
+     */
+    public void abortSharing() throws JoynServiceException {
+        try {
+            sharingInf.abortSharing();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on video sharing events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(VideoSharingListener listener) throws JoynServiceException {
+        try {
+            sharingInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from video sharing
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(VideoSharingListener listener) throws JoynServiceException {
+        try {
+            sharingInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingIntent.java b/src/java/org/gsma/joyn/vsh/VideoSharingIntent.java
new file mode 100644
index 0000000..7e5e862
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingIntent.java
@@ -0,0 +1,77 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+/**
+ * Intent for video sharing invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharingIntent {
+    /**
+     * Broadcast action: a new video sharing invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_SHARING_ID} containing the unique ID of the video sharing.
+     * <li> {@link #EXTRA_ENCODING} containing the video encoding.
+     * <li> {@link #EXTRA_FORMAT} containing the video format.
+     * <li> {@link #EXTRA_WIDTH} containing the video width.
+     * <li> {@link #EXTRA_HEIGHT} containing the video height.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.vsh.action.NEW_VIDEO_SHARING";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the video sharing
+     */
+    public final static String EXTRA_SHARING_ID = "sharingId";
+
+    /**
+     * Video encoding (e.g. H264)
+     */
+    public final static String EXTRA_ENCODING = "encoding";
+
+    /**
+     * Video format (e.g. QCIF)
+     */
+    public final static String EXTRA_FORMAT = "format";
+
+    /**
+     * Video width (in pixels)
+     */
+    public final static String EXTRA_WIDTH = "width";
+
+    /**
+     * Video height (in pixels)
+     */
+    public final static String EXTRA_HEIGHT = "height";
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingListener.java b/src/java/org/gsma/joyn/vsh/VideoSharingListener.java
new file mode 100644
index 0000000..c8edea9
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingListener.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+
+/**
+ * Video sharing event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoSharingListener extends IVideoSharingListener.Stub {
+    /**
+     * Callback called when the sharing is started
+     */
+    public abstract void onSharingStarted();
+
+    /**
+     * Callback called when the sharing has been aborted or terminated
+     */
+    public abstract void onSharingAborted();
+
+    /**
+     * Callback called when the sharing has failed
+     *
+     * @param error Error
+     * @see VideoSharing.Error
+     */
+    public abstract void onSharingError(int error);
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingLog.java b/src/java/org/gsma/joyn/vsh/VideoSharingLog.java
new file mode 100644
index 0000000..d4a3b1c
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingLog.java
@@ -0,0 +1,77 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import android.net.Uri;
+
+/**
+ * Content provider for video sharing history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharingLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.vsh/vsh");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the video sharing.
+     * <P>Type: TEXT</P>
+     */
+    public static final String SHARING_ID = "sharing_id";
+
+    /**
+     * The name of the column containing the MSISDN of the sender.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the direction of the sharing.
+     * <P>Type: INTEGER</P>
+     * @see VideoSharing.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the date of the sharing (in milliseconds).
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the duration of the sharing (in seconds). The
+     * value is only set at the end of the call.
+     * <P>Type: LONG</P>
+     */
+    public static final String DURATION = "duration";
+
+    /**
+     * The name of the column containing the state of the sharing.
+     * <P>Type: INTEGER</P>
+     * @see VideoSharing.State
+     */
+    public static final String STATE = "state";
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingService.java b/src/java/org/gsma/joyn/vsh/VideoSharingService.java
new file mode 100644
index 0000000..c42930f
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingService.java
@@ -0,0 +1,397 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+import org.gsma.joyn.ICoreServiceWrapper;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * This class offers the main entry point to share live video during a CS call.
+ * Several applications may connect/disconnect to the API.
+ *
+ * The parameter contact in the API supports the following formats: MSISDN in
+ * national or international format, SIP address, SIP-URI or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharingService extends JoynService {
+    /**
+     * API
+     */
+    private IVideoSharingService api = null;
+
+    public static final String TAG = "VideoSharingService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx
+     *            Application context
+     * @param listener
+     *            Service listener
+     */
+    public VideoSharingService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IVideoSharingService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getVideoSharingServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IVideoSharingService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener
+                        .onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of video sharing service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public VideoSharingServiceConfiguration getConfiguration()
+            throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Shares a live video with a contact. The parameter renderer contains the
+     * video player provided by the application. An exception if thrown if there
+     * is no ongoing CS call. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI
+     * or Tel-URI. If the format of the contact is not supported an exception is
+     * thrown.
+     *
+     * @param contact
+     *            Contact
+     * @param player
+     *            Video player
+     * @param listener
+     *            Video sharing event listener
+     * @return Video sharing
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public VideoSharing shareVideo(String contact, VideoPlayer player,
+            VideoSharingListener listener) throws JoynServiceException,
+            JoynContactFormatException {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_VIDEOSHARE_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_VIDEOSHARE_SEND");
+        }  */
+        if (api != null) {
+            try {
+                IVideoSharing sharingIntf = api.shareVideo(contact, player,
+                        listener);
+                if (sharingIntf != null) {
+                    return new VideoSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of video sharings in progress
+     *
+     * @return List of video sharings
+     * @throws JoynServiceException
+     */
+    public Set<VideoSharing> getVideoSharings() throws JoynServiceException {
+        if (api != null) {
+            try {
+                Set<VideoSharing> result = new HashSet<VideoSharing>();
+                List<IBinder> vshList = api.getVideoSharings();
+                for (IBinder binder : vshList) {
+                    VideoSharing sharing = new VideoSharing(
+                            IVideoSharing.Stub.asInterface(binder));
+                    result.add(sharing);
+                }
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current video sharing from its unique ID
+     *
+     * @param sharingId
+     *            Sharing ID
+     * @return Video sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public VideoSharing getVideoSharing(String sharingId)
+            throws JoynServiceException {
+        if (api != null) {
+            try {
+                IVideoSharing sharingIntf = api.getVideoSharing(sharingId);
+                if (sharingIntf != null) {
+                    return new VideoSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current video sharing from its invitation Intent
+     *
+     * @param intent
+     *            Invitation intent
+     * @return Video sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public VideoSharing getVideoSharingFor(Intent intent)
+            throws JoynServiceException {
+        if (api != null) {
+            try {
+                String sharingId = intent
+                        .getStringExtra(VideoSharingIntent.EXTRA_SHARING_ID);
+                if (sharingId != null) {
+                    return getVideoSharing(sharingId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        if (api != null) {
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    /**
+     * Registers a new video sharing invitation listener
+     *
+     * @param listener
+     *            New video sharing listener
+     * @throws JoynServiceException
+     */
+    public void addNewVideoSharingListener(NewVideoSharingListener listener)
+            throws JoynServiceException {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_VIDEOSHARE_READ) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_VIDEOSHARE_READ");
+        } */
+        if (api != null) {
+            try {
+                api.addNewVideoSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a new video sharing invitation listener
+     *
+     * @param listener
+     *            New video sharing listener
+     * @throws JoynServiceException
+     */
+    public void removeNewVideoSharingListener(NewVideoSharingListener listener)
+            throws JoynServiceException {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_VIDEOSHARE_READ) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_VIDEOSHARE_READ");
+        } */
+        if (api != null) {
+            try {
+                api.removeNewVideoSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.aidl b/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.aidl
new file mode 100644
index 0000000..f45a174
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Video sharing configuration object
+ */
+parcelable VideoSharingServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.java b/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.java
new file mode 100644
index 0000000..82d70bf
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.java
@@ -0,0 +1,101 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Video sharing service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharingServiceConfiguration implements Parcelable {
+    /**
+     * Maximum duration of the video sharing
+     */
+    private long maxTime;
+
+    /**
+     * Constructor
+     *
+     * @param maxTime Maximum authorized duration of the video sharing
+     * @hide
+     */
+    public VideoSharingServiceConfiguration(long maxTime) {
+        this.maxTime = maxTime;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public VideoSharingServiceConfiguration(Parcel source) {
+        this.maxTime = source.readLong();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(maxTime);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<VideoSharingServiceConfiguration> CREATOR
+            = new Parcelable.Creator<VideoSharingServiceConfiguration>() {
+        public VideoSharingServiceConfiguration createFromParcel(Parcel source) {
+            return new VideoSharingServiceConfiguration(source);
+        }
+
+        public VideoSharingServiceConfiguration[] newArray(int size) {
+            return new VideoSharingServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Returns the maximum authorized duration of the video sharing. It returns 0 if
+     * there is no limitation.
+     *
+     * @return Duration in seconds
+     */
+    public long getMaxTime() {
+        return maxTime;
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/package-info.java b/src/java/org/gsma/joyn/vsh/package-info.java
new file mode 100644
index 0000000..fa778cf
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * This API exposes all functionality related to sharing live video stream
+ * during a CS call via the Video Sharing service.
+ * <p>
+ */
+package org.gsma.joyn.vsh;
-- 
2.7.4

